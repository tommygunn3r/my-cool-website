<script type="module">
        function closeGame() { window.location.href = '/index.html'; }
        window.closeGame = closeGame;

        import { db } from '/firebase-config.js';
        import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { doc, getDoc, setDoc } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

        let auth = null;
        let userId = '';
        let playerName = '';
        let balance = 0;

        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingMsg = document.getElementById('loadingMsg');
        const startGameBtn = document.getElementById('startGameBtn');
        const balanceText = document.getElementById('balanceText');

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameCanvasContainer');

        const dropButton = document.getElementById('dropButton');

        const settingsModal = document.getElementById('settingsModal');
        const settingsBtn = document.getElementById('settingsBtn');
        const closeSettings = document.getElementById('closeSettings');
        const soundToggle = document.getElementById('soundToggle');
        const particleToggle = document.getElementById('particleToggle');
        const hintToggle = document.getElementById('hintToggle');

        let soundEnabled = true;
        let particlesEnabled = true;
        let hintEnabled = true;

        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        function playTone(freq, duration, type = 'sine', vol = 0.25) {
            if (!soundEnabled) return;
            if (audioContext.state === 'suspended') audioContext.resume();
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.type = type;
            osc.frequency.value = freq;
            osc.connect(gain);
            gain.connect(audioContext.destination);
            gain.gain.setValueAtTime(vol, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            osc.start();
            osc.stop(audioContext.currentTime + duration);
        }
        function playDropSound() { playTone(260, 0.09, 'square'); }
        function playPegHitSound() { playTone(440 + Math.random()*80, 0.05, 'triangle', 0.15); }
        function playPrizeSound(mult) {
            if (mult >= 10) {
                playTone(523.25, 0.12);
                setTimeout(() => playTone(659.25, 0.12), 100);
                setTimeout(() => playTone(783.99, 0.16), 200);
            } else if (mult >= 5) {
                playTone(440, 0.12);
                setTimeout(() => playTone(660, 0.12), 110);
            } else if (mult >= 2) {
                playTone(370, 0.08);
                setTimeout(() => playTone(440, 0.1), 70);
            } else {
                playTone(280, 0.06);
            }
        }
        function playBonusStartSound() {
            playTone(300, 0.15);
            setTimeout(() => playTone(430, 0.2), 100);
            setTimeout(() => playTone(550, 0.25), 220);
        }
        function playBonusHitSound() { playTone(680, 0.07, 'square', 0.2); }
        function playBonusExplosionSound() {
            for (let i = 0; i < 12; i++) {
                setTimeout(() => playTone(200 + Math.random()*200, 0.06, 'sawtooth', 0.12), i*30);
            }
        }

        async function initAuth() {
            try {
                auth = getAuth(db.app);
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        playerName = user.displayName || "Player";
                        await loadUserBalance();
                        loadingMsg.textContent = 'READY';
                        startGameBtn.style.display = 'inline-block';
                    } else {
                        window.location.href = '/index.html';
                    }
                });
            } catch (err) {
                console.error('Auth init failed:', err);
                loadingMsg.textContent = 'AUTH ERROR';
            }
        }

        async function loadUserBalance() {
            try {
                const userDoc = doc(db, 'users', userId);
                const snap = await getDoc(userDoc);
                if (snap.exists()) {
                    balance = snap.data().gunnercoins || 0;
                } else {
                    balance = 0;
                }
                balanceText.textContent = balance.toLocaleString();
            } catch (e) {
                console.error('Balance load error:', e);
            }
        }

        function updateBalance(delta) {
            balance += delta;
            if (balance < 0) balance = 0;
            balanceText.textContent = balance.toLocaleString();
            const userDoc = doc(db, 'users', userId);
            setDoc(userDoc, { gunnercoins: balance }, { merge: true });
        }

        // ---------- GAME LOGIC ----------
        let width = 0;
        let height = 0;

        let gameState = 'idle'; 
        let mainCoin = null;
        let coins = [];
        let pegGrid = [];
        
        // SCROLLING LOGIC
        // A repeating pattern that loops well
        const prizePattern = [10, 5, 2, 1, 2, 5]; 
        let scrollPos = 0;
        const scrollSpeed = 1.2; // Speed of movement (Left to Right)
        let boxWidth = 0;
        let patternTotalWidth = 0;

        let hoverCoinX = null;
        let hoverEnabled = true;
        let lastMultiplier = 0;
        let lastHitWasX10 = false;

        const gravity = 0.38;
        const pegRadius = 8;
        const coinRadius = 22; 
        const dropZoneHeightRatio = 0.15;
        let dropZoneHeightPx = 0;

        const prizeBoxHeight = 80;
        let prizeTrackY = 0;

        let particles = [];

        let bonus = {
            hp: 100,
            maxHp: 100,
            active: false,
            cracking: false,
            miniCoins: [],
            giantCoinScale: 2.8,
            bannerShown: false,
        };

        const gunnerCoinImg = new Image();
        gunnerCoinImg.src = '/games/assets/casino/gunnercoin.png';

        const pegImg = new Image();
        pegImg.src = '/games/assets/casino/peg.png';

        const boxImgMap = {
            1: new Image(),
            2: new Image(),
            5: new Image(),
            10: new Image()
        };
        boxImgMap[1].src = '/games/assets/casino/box_x1.png';
        boxImgMap[2].src = '/games/assets/casino/box_x2.png';
        boxImgMap[5].src = '/games/assets/casino/box_x5.png';
        boxImgMap[10].src = '/games/assets/casino/box_x10.png';

        function resizeCanvas() {
            const rect = gameContainer.getBoundingClientRect();
            if (rect.width === 0 || rect.height === 0) return;
            
            canvas.width = rect.width;
            canvas.height = rect.height;
            width = rect.width;
            height = rect.height;
            dropZoneHeightPx = height * dropZoneHeightRatio;
            prizeTrackY = height - prizeBoxHeight - 10;
            
            // Calculate Box Sizing
            // We want roughly 5 visible boxes
            boxWidth = width / 5;
            patternTotalWidth = boxWidth * prizePattern.length;
            
            setupPegGrid();
        }

        // Grid logic prevents edge drops
        function setupPegGrid() {
            pegGrid = [];
            let idealSpacing = 85; 
            let cols = Math.round(width / idealSpacing);
            if (cols < 3) cols = 3;
            const spacingX = width / cols; 
            
            const startY = dropZoneHeightPx + 60;
            const availableHeight = prizeTrackY - startY;
            const rows = Math.floor(availableHeight / 75); 

            for (let r = 0; r < rows; r++) {
                const y = startY + r * 75;
                for (let c = 0; c <= cols; c++) {
                    let x = c * spacingX;
                    if (r % 2 === 1) x += spacingX / 2;
                    // Allow pins at x=0 and x=width
                    if (x >= -10 && x <= width + 10) {
                        pegGrid.push({ x, y });
                    }
                }
            }
        }

        function addMessage(txt) {
            const msg = document.createElement('div');
            msg.className = 'message-overlay';
            msg.textContent = txt;
            gameContainer.appendChild(msg);
            setTimeout(() => msg.remove(), 2100);
        }

        function addParticles(x, y, count, color = 'gold') {
            if (!particlesEnabled) return;
            for (let i = 0; i < count; i++) {
                particles.push({
                    x,
                    y,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3,
                    life: 30 + Math.random()*20,
                    color
                });
            }
        }

        function createCoin(x, y, vy = 1, vx = 0) {
            return {
                x, y,
                vx, vy,
                radius: coinRadius,
                spinning: 0,
                landed: false,
                prize: null
            };
        }

        function startDropFromX(x) {
            if (gameState !== 'idle') return;
            if (balance < 1) {
                addMessage('INSUFFICIENT FUNDS');
                return;
            }
            updateBalance(-1);
            let dropX = Math.max(coinRadius + 2, Math.min(width - coinRadius - 2, x));
            mainCoin = createCoin(dropX, dropZoneHeightPx + 10, 2);
            gameState = 'dropping';
            playDropSound();
            lastMultiplier = 0;
        }

        function updateCoinPhysics(coin, isMini = false) {
            if (coin.landed) return;

            coin.vy += gravity * (isMini ? 1.2 : 1);
            coin.x += coin.vx;
            coin.y += coin.vy;
            coin.spinning += 0.18;

            // Wall Bouncing
            if (coin.x < coin.radius) {
                coin.x = coin.radius;
                coin.vx *= -0.5;
            }
            if (coin.x > width - coin.radius) {
                coin.x = width - coin.radius;
                coin.vx *= -0.5;
            }

            // Peg collisions
            for (let peg of pegGrid) {
                const dx = coin.x - peg.x;
                const dy = coin.y - peg.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const minDist = coin.radius + pegRadius;
                if (dist < minDist) {
                    const nx = dx / dist;
                    const ny = dy / dist;
                    const overlap = minDist - dist;
                    coin.x += nx * overlap;
                    coin.y += ny * overlap;
                    const dot = coin.vx * nx + coin.vy * ny;
                    coin.vx -= 2 * dot * nx;
                    coin.vy -= 2 * dot * ny;
                    coin.vx *= 0.8; 
                    coin.vy *= 0.8; 
                    playPegHitSound();
                    addParticles(coin.x, coin.y, 6, 'gold');
                }
            }

            // Prize collision (Dynamic Scrolling)
            if (coin.y + coin.radius >= prizeTrackY) {
                const mult = getPrizeUnderCoin(coin.x);
                if (mult !== null) {
                    coin.landed = true;
                    coin.prize = mult;
                    handlePrizeResult(mult, isMini);
                } else {
                    coin.landed = true;
                    coin.prize = 0;
                }
            }
            
            if (coin.y - coin.radius > height + 50) {
                coin.landed = true;
                coin.prize = 0;
            }
        }

        // CALCULATE WIN BASED ON SCROLL POSITION
        function getPrizeUnderCoin(x) {
            if (boxWidth <= 0) return 0;
            
            // Because boxes scroll Right, we subtract scrollPos from the coin's X
            // to find its relative position in the pattern.
            // We use modulo to handle the infinite repeat.
            
            let relativeX = (x - scrollPos) % patternTotalWidth;
            if (relativeX < 0) relativeX += patternTotalWidth;
            
            let index = Math.floor(relativeX / boxWidth);
            
            // Safety clamp
            if (index < 0) index = 0;
            if (index >= prizePattern.length) index = 0;
            
            return prizePattern[index];
        }

        function handlePrizeResult(multiplier, isMini) {
            if (!isMini) {
                if (multiplier > 0) {
                    updateBalance(multiplier);
                }
                if (multiplier >= 10 && lastHitWasX10) {
                    triggerCoinBreaker();
                    lastHitWasX10 = false;
                } else {
                    lastHitWasX10 = (multiplier >= 10);
                }
                lastMultiplier = multiplier;
                if (multiplier > 0) {
                    addMessage(`WIN x${multiplier}`);
                    playPrizeSound(multiplier);
                } else {
                    addMessage('NO PRIZE');
                }
            } else {
                if (multiplier > 0) {
                    updateBalance(multiplier);
                    playBonusHitSound();
                }
            }
        }

        function triggerCoinBreaker() {
            gameState = 'bonus_intro';
            bonus.active = true;
            bonus.cracking = true;
            bonus.hp = bonus.maxHp = 100;
            bonus.miniCoins = [];
            bonus.bannerShown = false;
            playBonusStartSound();
            showBonusBanner();
        }

        function showBonusBanner() {
            const overlay = document.createElement('div');
            overlay.className = 'bonus-banner';
            overlay.id = 'bonusBannerOverlay';
            const img = document.createElement('img');
            img.src = '/games/assets/casino/coinbreaker_bonus.png';
            overlay.appendChild(img);
            const txt = document.createElement('div');
            txt.className = 'bonus-text';
            txt.textContent = 'TAP / CLICK TO SMASH THE GIANT COIN';
            overlay.appendChild(txt);
            gameContainer.appendChild(overlay);
            bonus.bannerShown = true;
            setTimeout(() => {
                overlay.style.opacity = '0';
                overlay.style.transition = 'opacity 0.4s';
                setTimeout(() => overlay.remove(), 420);
            }, 1400);
            setTimeout(() => {
                gameState = 'bonus_active';
            }, 500);
        }

        function updateBonusGiantCoinOnClick(evX, evY) {
            if (!bonus.active || !bonus.cracking) return;
            const cx = width / 2;
            const cy = height / 2;
            const maxR = coinRadius * bonus.giantCoinScale * 1.1;
            const dx = evX - cx;
            const dy = evY - cy;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist <= maxR) {
                bonus.hp -= 8 + Math.random()*4;
                if (bonus.hp < 0) bonus.hp = 0;
                playBonusHitSound();
                addParticles(evX, evY, 10, 'gold');
                if (bonus.hp <= 0) {
                    bonus.cracking = false;
                    startBonusMiniCoinExplosion();
                }
            }
        }

        function startBonusMiniCoinExplosion() {
            playBonusExplosionSound();
            const miniCount = 12;
            for (let i = 0; i < miniCount; i++) {
                const angle = (Math.PI * 2 * i) / miniCount;
                const speed = 4 + Math.random() * 2;
                const mc = createCoin(width/2, height/2, Math.sin(angle)*speed, Math.cos(angle)*speed);
                mc.radius = coinRadius * 0.7;
                bonus.miniCoins.push(mc);
            }
            gameState = 'bonus_cleanup';
        }

        function updateParticles() {
            for (let p of particles) {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 1;
                p.vy += 0.03;
            }
            particles = particles.filter(p => p.life > 0);
        }

        function drawParticles() {
            for (let p of particles) {
                const alpha = Math.max(0, p.life / 50);
                ctx.fillStyle = p.color === 'gold'
                    ? `rgba(244, 215, 122, ${alpha})`
                    : `rgba(255,255,255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 2.5, 0, Math.PI*2);
                ctx.fill();
            }
        }

        function drawScene() {
            ctx.clearRect(0,0,width,height);

            const grad = ctx.createRadialGradient(width/2, 0, width*0.1, width/2, height, width);
            grad.addColorStop(0, 'rgba(31,23,46,0.9)');
            grad.addColorStop(0.5, 'rgba(7,4,10,0.96)');
            grad.addColorStop(1, 'rgba(0,0,0,1)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,width,height);

            if (hintEnabled) {
                ctx.fillStyle = 'rgba(255,255,255,0.05)';
                ctx.fillRect(0, 0, width, dropZoneHeightPx);
            }

            // Draw Pegs
            for (let peg of pegGrid) {
                if (pegImg.complete && pegImg.naturalWidth > 0) {
                    const s = pegRadius*2;
                    ctx.drawImage(pegImg, peg.x - s/2, peg.y - s/2, s, s);
                } else {
                    ctx.fillStyle = '#444';
                    ctx.beginPath();
                    ctx.arc(peg.x, peg.y, pegRadius, 0, Math.PI*2);
                    ctx.fill();
                }
            }

            // DRAW SCROLLING PRIZE BOXES
            if (boxWidth > 0) {
                // Determine starting offset for drawing
                // The logical pattern moves right, so we offset draw position by scrollPos % totalWidth
                let effectiveScroll = scrollPos % patternTotalWidth;
                
                // We need to draw enough boxes to cover the screen width
                // Starting from just off-screen left to ensure seamlessness
                
                // Index shift caused by scrolling
                let startIndex = Math.floor(-effectiveScroll / boxWidth); 
                // Draw extra boxes to cover width
                let boxesToDraw = Math.ceil(width / boxWidth) + 2; 

                for (let i = -2; i < boxesToDraw; i++) {
                    let drawX = (i * boxWidth) + effectiveScroll;
                    
                    // Logic to find which prize corresponds to this box slot
                    // We handle negative modulo indices manually
                    let patternIndex = (i % prizePattern.length);
                    if (patternIndex < 0) patternIndex += prizePattern.length;
                    
                    let multiplier = prizePattern[patternIndex];
                    let img = boxImgMap[multiplier];

                    if (img.complete && img.naturalWidth > 0) {
                        ctx.drawImage(img, drawX, prizeTrackY, boxWidth, prizeBoxHeight);
                    } else {
                        ctx.fillStyle = 'rgba(30,30,30,0.9)';
                        ctx.fillRect(drawX, prizeTrackY, boxWidth, prizeBoxHeight);
                        ctx.strokeStyle = (multiplier === 10) ? 'gold' : '#888';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(drawX+1, prizeTrackY+1, boxWidth-2, prizeBoxHeight-2);
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 24px Cinzel, serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('x'+multiplier, drawX + boxWidth/2, prizeTrackY + prizeBoxHeight/2);
                    }
                }
            }

            // Draw Hover Coin
            if (hoverCoinX !== null && hoverEnabled && gameState === 'idle') {
                const y = dropZoneHeightPx * 0.5;
                const size = coinRadius * 2.2;
                ctx.save();
                ctx.translate(hoverCoinX, y);
                ctx.rotate(Math.sin(performance.now()/400)*0.15);
                if (gunnerCoinImg.complete && gunnerCoinImg.naturalWidth > 0) {
                    ctx.drawImage(gunnerCoinImg, -size/2, -size/2, size, size);
                } else {
                    ctx.fillStyle = 'gold';
                    ctx.beginPath();
                    ctx.arc(0, 0, coinRadius*1.1, 0, Math.PI*2);
                    ctx.fill();
                }
                ctx.restore();
            }

            if (mainCoin) {
                drawCoin(mainCoin);
            }

            if (bonus.active) {
                if (bonus.cracking || gameState === 'bonus_active') {
                    drawGiantBonusCoin();
                }
                for (let mc of bonus.miniCoins) {
                    drawCoin(mc, true);
                }
            }

            drawParticles();
        }

        function drawCoin(coin, isMini=false) {
            const size = coin.radius * 2;
            ctx.save();
            ctx.translate(coin.x, coin.y);
            ctx.rotate(coin.spinning);
            if (gunnerCoinImg.complete && gunnerCoinImg.naturalWidth > 0) {
                ctx.drawImage(gunnerCoinImg, -size/2, -size/2, size, size);
            } else {
                ctx.fillStyle = 'gold';
                ctx.beginPath();
                ctx.arc(0,0, coin.radius, 0, Math.PI*2);
                ctx.fill();
            }
            ctx.restore();
        }

        function drawGiantBonusCoin() {
            const r = coinRadius * bonus.giantCoinScale;
            const cx = width/2;
            const cy = height/2;
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(Math.sin(performance.now()/300)*0.08);
            const size = r * 2;
            if (gunnerCoinImg.complete && gunnerCoinImg.naturalWidth > 0) {
                ctx.drawImage(gunnerCoinImg, -size/2, -size/2, size, size);
            } else {
                ctx.fillStyle = 'gold';
                ctx.beginPath();
                ctx.arc(0,0,r,0,Math.PI*2);
                ctx.fill();
            }
            ctx.restore();

            const barW = width * 0.4;
            const barH = 16;
            const x = (width - barW)/2;
            const y = cy + r + 30;
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(x, y, barW, barH);
            const pct = bonus.hp / bonus.maxHp;
            ctx.fillStyle = 'rgba(212,175,55,0.9)';
            ctx.fillRect(x+2, y+2, (barW-4)*pct, barH-4);
            ctx.strokeStyle = 'gold';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, barW, barH);

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 13px Cinzel, serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('COIN BREAKER', width/2, y - 10);
        }

        function loop() {
            requestAnimationFrame(loop);

            if (width === 0 || height === 0) return;

            // Increment scroll
            scrollPos += scrollSpeed;
            if (scrollPos > patternTotalWidth) scrollPos -= patternTotalWidth;

            if (gameState === 'dropping') {
                if (mainCoin && !mainCoin.landed) {
                    updateCoinPhysics(mainCoin, false);
                } else if (mainCoin && mainCoin.landed) {
                    mainCoin = null;
                    gameState = bonus.active ? 'bonus_active' : 'idle';
                }
            }

            if (bonus.active) {
                if (gameState === 'bonus_cleanup' || gameState === 'bonus_active') {
                    for (let mc of bonus.miniCoins) {
                        if (!mc.landed) updateCoinPhysics(mc, true);
                    }
                    bonus.miniCoins = bonus.miniCoins.filter(c => !c.landed || (c.prize === null));
                    let allLanded = true;
                    for (let mc of bonus.miniCoins) {
                        if (!mc.landed) { allLanded = false; break; }
                    }
                    if (gameState === 'bonus_cleanup' && allLanded) {
                        bonus.active = false;
                        bonus.miniCoins = [];
                        gameState = 'idle';
                        addMessage('BONUS COMPLETE');
                    }
                }
            }

            updateParticles();
            drawScene();
        }

        function onPointerMove(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX || (e.touches && e.touches[0].clientX)) - rect.left;
            const y = (e.clientY || (e.touches && e.touches[0].clientY)) - rect.top;
            if (y >= 0 && y <= dropZoneHeightPx) {
                hoverCoinX = x;
            } else {
                hoverCoinX = null;
            }
        }

        function onPointerUp(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX || (e.changedTouches && e.changedTouches[0].clientX)) - rect.left;
            const y = (e.clientY || (e.changedTouches && e.changedTouches[0].clientY)) - rect.top;

            if (bonus.active && (gameState === 'bonus_active' || gameState === 'bonus_intro')) {
                updateBonusGiantCoinOnClick(x, y);
                return;
            }

            if (y >= 0 && y <= dropZoneHeightPx) {
                startDropFromX(x);
            }
        }

        canvas.addEventListener('mousemove', onPointerMove);
        canvas.addEventListener('touchmove', onPointerMove, { passive: true });
        canvas.addEventListener('mouseup', onPointerUp);
        canvas.addEventListener('touchend', onPointerUp);

        dropButton.addEventListener('click', () => {
            if (hoverCoinX === null) {
                startDropFromX(width/2);
            } else {
                startDropFromX(hoverCoinX);
            }
        });

        settingsBtn.addEventListener('click', () => settingsModal.classList.add('active'));
        closeSettings.addEventListener('click', () => settingsModal.classList.remove('active'));

        soundToggle.addEventListener('click', () => {
            soundToggle.classList.toggle('active');
            soundEnabled = soundToggle.classList.contains('active');
        });
        particleToggle.addEventListener('click', () => {
            particleToggle.classList.toggle('active');
            particlesEnabled = particleToggle.classList.contains('active');
        });
        hintToggle.addEventListener('click', () => {
            hintToggle.classList.toggle('active');
            hintEnabled = hintToggle.classList.contains('active');
        });

        startGameBtn.addEventListener('click', () => {
            loadingOverlay.style.opacity = '0';
            loadingOverlay.style.transition = 'opacity 0.4s';
            setTimeout(() => loadingOverlay.style.display = 'none', 420);
            if (audioContext.state === 'suspended') audioContext.resume();
        });

        window.addEventListener('resize', resizeCanvas);

        resizeCanvas();
        loop();
        initAuth();
    </script>
