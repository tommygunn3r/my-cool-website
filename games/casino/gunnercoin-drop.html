<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>GunnerCoin Drop</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Same vibe as Blackjack -->
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Cormorant+Garamond:wght@300;400;600&display=swap" rel="stylesheet">

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --gold: #d4af37;
            --gold-dark: #b8941f;
            --gold-light: #f4e5a7;
            --cream: #f5f3e8;
            --dark: #0b0907;
            --accent: #2b1242;
        }

        body {
            font-family: 'Cormorant Garamond', serif;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            background-color: #000;
            background-image: url('/games/assets/casino/background.png');
            background-size: cover;
            background-position: center;
            color: var(--cream);
        }

        #loadingOverlay {
            position: fixed; inset: 0;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: radial-gradient(circle at top, #311844 0%, #050308 60%, #000 100%);
            z-index: 1000;
        }
        #loadingTitle {
            font-family: 'Cinzel', serif;
            font-size: 3rem;
            letter-spacing: 0.16em;
            color: var(--gold);
            text-shadow: 0 0 18px rgba(0,0,0,0.9);
            margin-bottom: 1rem;
        }
        #loadingLogo {
            width: clamp(220px, 40vw, 420px);
            height: auto;
            margin-bottom: 1.5rem;
        }
        #loadingMsg {
            color: var(--gold-light);
            font-size: 1.1rem;
            letter-spacing: 0.08em;
            margin-bottom: 1.5rem;
            animation: pulse 1.6s infinite;
        }
        #startGameBtn {
            font-family: 'Cinzel', serif;
            font-size: 1.3rem;
            padding: 0.8rem 3rem;
            border-radius: 999px;
            border: none;
            cursor: pointer;
            background: linear-gradient(135deg, var(--gold) 0%, var(--gold-dark) 100%);
            color: #000;
            letter-spacing: 0.14em;
            box-shadow: 0 0 25px rgba(212,175,55,0.6);
            display: none;
        }
        #startGameBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 35px rgba(212,175,55,0.9);
        }
        @keyframes pulse {
            0% { opacity: 0.4; }
            50% { opacity: 1; }
            100% { opacity: 0.4; }
        }

        #gameShell {
            position: relative;
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
        }

        .header {
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.6rem 1.2rem;
            background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.65) 100%);
            border-bottom: 2px solid rgba(212,175,55,0.7);
        }
        .logo {
            display: flex; align-items: center; gap: 0.7rem;
        }
        .logo-main {
            font-family: 'Cinzel', serif;
            letter-spacing: 0.18em;
            font-size: 1.1rem;
            color: var(--gold);
        }
        .logo-sub {
            font-size: 0.9rem;
            letter-spacing: 0.16em;
            text-transform: uppercase;
            color: var(--gold-light);
            opacity: 0.9;
        }
        .balance {
            display: flex; align-items: center; gap: 0.45rem;
            font-size: 1.1rem;
        }
        .coin-icon {
            width: 28px; height: 28px;
            border-radius: 50%;
            background: radial-gradient(circle, var(--gold-light) 0%, var(--gold) 60%, var(--gold-dark) 100%);
            display: flex; align-items: center; justify-content: center;
            font-weight: 700; color: #000;
            box-shadow: 0 0 10px rgba(212,175,55,0.7);
            font-size: 1rem;
        }
        #balanceText {
            font-weight: 600;
            letter-spacing: 0.1em;
        }

        .settings-button {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid var(--gold);
            color: var(--gold);
            width: 40px; height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.1rem;
            transition: all 0.3s;
            display: flex; align-items: center; justify-content: center;
        }
        .settings-button:hover { background: rgba(212,175,55,0.15); transform: rotate(90deg); }

        .main-row {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        #gameCanvasContainer {
            position: relative;
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at top, rgba(0,0,0,0.85) 0%, rgba(0,0,0,0.95) 40%, #000 100%);
        }

        .controls {
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            padding: 0.6rem 0.8rem;
            background: linear-gradient(0deg, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.6) 100%);
            border-top: 2px solid rgba(212,175,55,0.7);
            flex-wrap: wrap;
        }
        .info-pill {
            padding: 0.3rem 0.8rem;
            border-radius: 999px;
            border: 1px solid rgba(212,175,55,0.5);
            background: rgba(0,0,0,0.7);
            font-size: 0.85rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }
        .game-button {
            font-family: 'Cinzel', serif;
            font-size: 0.95rem;
            padding: 0.55rem 1.4rem;
            border-radius: 999px;
            border: none;
            cursor: pointer;
            background: linear-gradient(135deg, var(--gold) 0%, var(--gold-dark) 100%);
            color: #000;
            letter-spacing: 0.12em;
            box-shadow: 0 0 16px rgba(212,175,55,0.6);
        }
        .game-button:disabled {
            opacity: 0.35;
            cursor: not-allowed;
            filter: grayscale(0.8);
            box-shadow: none;
        }

        .fixed-nav {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 200;
        }
        .nav-button {
            padding: 10px 18px;
            background: rgba(10, 10, 10, 0.95);
            border: 2px solid var(--gold);
            border-radius: 10px;
            color: var(--cream);
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 15px rgba(212, 175, 55, 0.3);
            font-family: 'Cinzel', serif;
        }
        .nav-button:hover {
            background: rgba(212, 175, 55, 0.2);
            box-shadow: 0 0 25px rgba(212, 175, 55, 0.6);
            transform: translateY(-2px);
        }

        .message-overlay {
            position: absolute;
            left: 50%; top: 18%;
            transform: translateX(-50%);
            background: radial-gradient(circle, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.9) 60%);
            border-radius: 999px;
            border: 3px solid var(--gold);
            padding: 0.7rem 2.5rem;
            z-index: 50;
            font-family: 'Cinzel', serif;
            font-size: 1.1rem;
            color: var(--gold-light);
            letter-spacing: 0.16em;
            text-align: center;
            white-space: nowrap;
            animation: overlayPop 0.4s ease-out, overlayFade 1.6s ease-out 0.6s forwards;
        }
        @keyframes overlayPop {
            0% { transform: translateX(-50%) scale(0.6); opacity: 0; }
            100% { transform: translateX(-50%) scale(1); opacity: 1; }
        }
        @keyframes overlayFade {
            to { opacity: 0; transform: translateX(-50%) translateY(-10px) scale(0.95); }
        }

        .bonus-banner {
            position: absolute;
            inset: 0;
            background: radial-gradient(circle, rgba(0,0,0,0.85) 0%, rgba(0,0,0,0.98) 60%);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 150;
            animation: bonusFadeIn 0.35s ease-out;
        }
        .bonus-banner img {
            max-width: 85%;
            height: auto;
            margin-bottom: 0.8rem;
        }
        .bonus-text {
            font-family: 'Cinzel', serif;
            letter-spacing: 0.18em;
            font-size: 0.9rem;
            text-transform: uppercase;
            color: var(--gold-light);
        }
        @keyframes bonusFadeIn {
            from { opacity: 0; transform: scale(1.04); }
            to { opacity: 1; transform: scale(1); }
        }

        #settingsModal {
            position: fixed; inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        #settingsModal.active { display: flex; }
        .modal-content {
            background: linear-gradient(135deg, #2a1f1a 0%, var(--dark) 100%);
            padding: 2rem 2.4rem;
            border-radius: 20px;
            border: 3px solid var(--gold);
            max-width: 460px;
            width: 90%;
        }
        .modal-title {
            font-family: 'Cinzel', serif;
            font-size: 1.6rem;
            color: var(--gold);
            margin-bottom: 1.4rem;
            letter-spacing: 0.14em;
        }
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.6rem 0;
            border-bottom: 1px solid rgba(212,175,55,0.3);
            font-size: 1rem;
        }
        .toggle {
            width: 56px; height: 28px;
            background: rgba(0,0,0,0.5);
            border: 2px solid var(--gold);
            border-radius: 999px;
            position: relative;
            cursor: pointer;
            transition: background 0.25s;
        }
        .toggle-slider {
            width: 22px; height: 22px;
            border-radius: 50%;
            background: var(--cream);
            position: absolute;
            top: 2px; left: 2px;
            transition: left 0.25s;
        }
        .toggle.active { background: var(--gold); }
        .toggle.active .toggle-slider { left: 30px; }

        .close-button {
            margin-top: 1.4rem;
            width: 100%;
        }

        @media (max-width: 768px) {
            .header {
                padding: 0.4rem 0.7rem;
            }
            .logo-main { font-size: 0.95rem; }
            .logo-sub { display: none; }
            .nav-button { padding: 8px 14px; font-size: 0.8rem; }
        }
    </style>
</head>
<body>
    <div id="loadingOverlay">
        <div id="loadingTitle">GUNNERCOIN DROP</div>
        <img id="loadingLogo" src="/games/assets/casino/gunnercoin_drop_logo.png" alt="GunnerCoin Drop Logo">
        <div id="loadingMsg">CONNECTING TO ACCOUNT...</div>
        <button id="startGameBtn">PLAY</button>
    </div>

    <div id="gameShell">
        <div class="header">
            <div class="logo">
                <div class="logo-main">GUNNERSGAMES</div>
                <div class="logo-sub">GUNNERCOIN DROP</div>
            </div>
            <button class="settings-button" id="settingsBtn">⚙</button>
            <div class="balance">
                <div class="coin-icon">G</div>
                <span id="balanceText">...</span>
            </div>
        </div>

        <div class="main-row">
            <div id="gameCanvasContainer">
                <canvas id="gameCanvas"></canvas>
                <!-- overlays injected here -->
            </div>
            <div class="controls">
                <div class="info-pill">Drop Cost: 1 GunnerCoin</div>
                <div class="info-pill">Payouts: x1 / x2 / x5 / x10</div>
                <div class="info-pill">Hit x10 twice in a row → COIN BREAKER BONUS</div>
                <button id="dropButton" class="game-button">DROP</button>
            </div>
        </div>
    </div>

    <div class="fixed-nav">
        <a href="#" class="nav-button" onclick="closeGame(); return false;">
            <span>←</span>
            <span>Back to Casino</span>
        </a>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal">
        <div class="modal-content">
            <div class="modal-title">SETTINGS</div>
            <div class="setting-row">
                <span>Sound Effects</span>
                <div class="toggle active" id="soundToggle"><div class="toggle-slider"></div></div>
            </div>
            <div class="setting-row">
                <span>Coin Trail Particles</span>
                <div class="toggle active" id="particleToggle"><div class="toggle-slider"></div></div>
            </div>
            <div class="setting-row">
                <span>Show Drop Hint</span>
                <div class="toggle active" id="hintToggle"><div class="toggle-slider"></div></div>
            </div>
            <button class="game-button close-button" id="closeSettings">CLOSE</button>
        </div>
    </div>

    <script type="module">
        function closeGame() { window.location.href = '/index.html'; }
        window.closeGame = closeGame;

        import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm';

        const supabaseUrl = 'https://pknhslxhpohrzgsfkisr.supabase.co';
        const supabaseKey = 'sb_publishable_-zZw-pi_3q1sdNGhITKuhQ_ECyDARzc';
        const supabase = createClient(supabaseUrl, supabaseKey);

        let userId = '';
        let playerName = '';
        let balance = 0;

        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingMsg = document.getElementById('loadingMsg');
        const startGameBtn = document.getElementById('startGameBtn');
        const balanceText = document.getElementById('balanceText');

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameCanvasContainer');

        const dropButton = document.getElementById('dropButton');

        const settingsModal = document.getElementById('settingsModal');
        const settingsBtn = document.getElementById('settingsBtn');
        const closeSettings = document.getElementById('closeSettings');
        const soundToggle = document.getElementById('soundToggle');
        const particleToggle = document.getElementById('particleToggle');
        const hintToggle = document.getElementById('hintToggle');

        let soundEnabled = true;
        let particlesEnabled = true;
        let hintEnabled = true;

        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        function playTone(freq, duration, type = 'sine', vol = 0.25) {
            if (!soundEnabled) return;
            if (audioContext.state === 'suspended') audioContext.resume();
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.type = type;
            osc.frequency.value = freq;
            osc.connect(gain);
            gain.connect(audioContext.destination);
            gain.gain.setValueAtTime(vol, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            osc.start();
            osc.stop(audioContext.currentTime + duration);
        }
        function playDropSound() { playTone(260, 0.09, 'square'); }
        function playPegHitSound() { playTone(440 + Math.random()*80, 0.05, 'triangle', 0.15); }
        function playPrizeSound(mult) {
            if (mult >= 10) {
                playTone(523.25, 0.12);
                setTimeout(() => playTone(659.25, 0.12), 100);
                setTimeout(() => playTone(783.99, 0.16), 200);
            } else if (mult >= 5) {
                playTone(440, 0.12);
                setTimeout(() => playTone(660, 0.12), 110);
            } else if (mult >= 2) {
                playTone(370, 0.08);
                setTimeout(() => playTone(440, 0.1), 70);
            } else {
                playTone(280, 0.06);
            }
        }
        function playBonusStartSound() {
            playTone(300, 0.15);
            setTimeout(() => playTone(430, 0.2), 100);
            setTimeout(() => playTone(550, 0.25), 220);
        }
        function playBonusHitSound() { playTone(680, 0.07, 'square', 0.2); }
        function playBonusExplosionSound() {
            for (let i = 0; i < 12; i++) {
                setTimeout(() => playTone(200 + Math.random()*200, 0.06, 'sawtooth', 0.12), i*30);
            }
        }

        async function initAuth() {
            try {
                const { data: { session } } = await supabase.auth.getSession();
                
                if (session?.user) {
                    userId = session.user.id;
                    playerName = session.user.user_metadata?.player_name || "Player";
                    await loadUserBalance();
                    loadingMsg.textContent = 'READY';
                    startGameBtn.style.display = 'inline-block';
                } else {
                    window.location.href = '/index.html';
                }
            } catch (err) {
                console.error('Auth init failed:', err);
                loadingMsg.textContent = 'AUTH ERROR';
            }
        }

        async function loadUserBalance() {
            try {
                const { data, error } = await supabase
                    .from('profiles')
                    .select('gunnercoins')
                    .eq('id', userId)
                    .single();
                
                if (error) {
                    console.error('Balance query error:', error);
                    balance = 100;
                } else {
                    balance = data?.gunnercoins || 100;
                }
                
                balanceText.textContent = balance.toLocaleString();
            } catch (e) {
                console.error('Balance load error:', e);
                balance = 100;
                balanceText.textContent = '100';
            }
        }

        async function updateBalance(delta) {
            balance += delta;
            if (balance < 0) balance = 0;
            balanceText.textContent = balance.toLocaleString();
            
            try {
                const { error } = await supabase
                    .from('profiles')
                    .update({ gunnercoins: balance })
                    .eq('id', userId);
                
                if (error) {
                    console.error('Balance update error:', error);
                }
            } catch (e) {
                console.error('Balance update error:', e);
            }
        }

        // ---------- GAME LOGIC ----------
        let width = 0;
        let height = 0;

        let gameState = 'idle'; // 'idle', 'dropping', 'bonus_intro', 'bonus_active', 'bonus_cleanup'
        let mainCoin = null;
        let coins = [];
        let pegGrid = [];
        let prizeBoxes = [];
        let hoverCoinX = null;
        let hoverEnabled = true;
        let lastMultiplier = 0;
        let lastHitWasX10 = false;

        const gravity = 0.38;
        const pegRadius = 8;          // was 11 – smaller peg for easier flow
        const coinRadius = 22;
        const dropZoneHeightRatio = 0.15;
        let dropZoneHeightPx = 0;

        const prizeBoxHeight = 60; // Reduced from 80 to match 25% shrink
        let prizeTrackY = 0;

        let prizeOffset = 0;
        let prizeSpeed = 1.4;
        let prizeScrollDirection = -1; // -1 = left, 1 = right
        let prizeScrollSpeed = 2; // pixels per frame

        let particles = [];

        let bonus = {
            hp: 100,
            maxHp: 100,
            active: false,
            cracking: false,
            miniCoins: [],
            giantCoinScale: 2.8,
            bannerShown: false,
        };

        const gunnerCoinImg = new Image();
        gunnerCoinImg.src = '/games/assets/casino/gunnercoin.png';

        const pegImg = new Image();
        pegImg.src = '/games/assets/casino/peg.png';

        const boxImgMap = {
            1: new Image(),
            2: new Image(),
            5: new Image(),
            10: new Image()
        };
        boxImgMap[1].src = '/games/assets/casino/box_x1.png';
        boxImgMap[2].src = '/games/assets/casino/box_x2.png';
        boxImgMap[5].src = '/games/assets/casino/box_x5.png';
        boxImgMap[10].src = '/games/assets/casino/box_x10.png';

        const bonusBannerImg = new Image();
        bonusBannerImg.src = '/games/assets/casino/coinbreaker_bonus.png';

        function resizeCanvas() {
            const rect = gameContainer.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            width = rect.width;
            height = rect.height;
            dropZoneHeightPx = height * dropZoneHeightRatio;
            prizeTrackY = height - prizeBoxHeight - 10;
            setupPegGrid();
            setupPrizeBoxes();
        }

        // UPDATED: Wider peg spacing so coin can fall
        function setupPegGrid() {
            pegGrid = [];

            const spacingX = 90;   // wider columns
            const spacingY = 90;   // wider rows
            let cols = Math.floor(width / spacingX) - 1;
            if (cols < 3) cols = 3;    // safety for small screens

            const rows = 7;
            const startY = dropZoneHeightPx + 80; // push first row lower

            for (let r = 0; r < rows; r++) {
                const y = startY + r * spacingY;
                for (let c = 0; c < cols; c++) {
                    let x = (c + 1) * spacingX;

                    // stagger every other row (classic Plinko layout)
                    if (r % 2 === 1) x += spacingX / 2;

                    pegGrid.push({ x, y });
                }
            }
        }

        function setupPrizeBoxes() {
            // Symmetric pattern: x1, x2, x5, x10, x10, x5, x2, x1
            const multipliers = [1, 2, 5, 10, 10, 5, 2, 1];
            
            // Shrink boxes by 25%
            const boxWidth = Math.min(135, width / (multipliers.length + 1)) * 0.75;
            
            // Gap should be at least 2x coin diameter (coinRadius * 2 * 2 = ~88px)
            const minGap = coinRadius * 4; // Extra spacing for difficulty
            
            prizeBoxes = [];
            let x = 0;
            for (let i = 0; i < multipliers.length; i++) {
                prizeBoxes.push({
                    multiplier: multipliers[i],
                    width: boxWidth,
                    baseX: x
                });
                x += boxWidth + minGap;
            }
        }

        function startDropFromX(x) {
            if (gameState !== 'idle') return;
            if (balance < 1) {
                addMessage('NOT ENOUGH COINS');
                return;
            }
            updateBalance(-1);
            gameState = 'dropping';
            hoverCoinX = null;
            
            // Switch prize box direction on each drop
            prizeScrollDirection *= -1;
            
            mainCoin = {
                x: x,
                y: dropZoneHeightPx * 0.5,
                vx: 0,
                vy: 0,
                radius: coinRadius,
                spinning: 0,
                landed: false,
                prize: null
            };
            playDropSound();
        }

        function updateCoinPhysics(coin, isMini) {
            coin.vy += gravity;
            coin.x += coin.vx;
            coin.y += coin.vy;
            coin.spinning += 0.15;

            // Peg collisions
            for (let peg of pegGrid) {
                const dx = coin.x - peg.x;
                const dy = coin.y - peg.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < coin.radius + pegRadius) {
                    const angle = Math.atan2(dy, dx);
                    const overlap = (coin.radius + pegRadius) - dist;
                    coin.x += Math.cos(angle) * overlap;
                    coin.y += Math.sin(angle) * overlap;

                    const nx = dx / dist;
                    const ny = dy / dist;
                    const dot = coin.vx*nx + coin.vy*ny;
                    coin.vx = (coin.vx - 2*dot*nx) * 0.7;
                    coin.vy = (coin.vy - 2*dot*ny) * 0.7;

                    if (!isMini) playPegHitSound();
                    if (particlesEnabled) {
                        for (let i = 0; i < 3; i++) {
                            particles.push({
                                x: peg.x, y: peg.y,
                                vx: (Math.random()-0.5)*3,
                                vy: (Math.random()-0.5)*3,
                                life: 15 + Math.random()*10,
                                color: `hsl(${40 + Math.random()*20}, 80%, 60%)`
                            });
                        }
                    }
                }
            }

            // Prize collision
            if (coin.y + coin.radius >= prizeTrackY) {
                for (let box of prizeBoxes) {
                    const totalWidth = (prizeBoxes[prizeBoxes.length-1].baseX + prizeBoxes[prizeBoxes.length-1].width);
                    for (let pass = -2; pass <= 2; pass++) {
                        const boxX = box.baseX + prizeOffset + (pass * totalWidth);
                        if (coin.x >= boxX && coin.x <= boxX + box.width) {
                            coin.landed = true;
                            coin.prize = box.multiplier;
                            if (!isMini) {
                                playPrizeSound(box.multiplier);
                                const winAmt = box.multiplier;
                                updateBalance(winAmt);
                                addMessage(`+${winAmt} COINS`);

                                if (box.multiplier === 10) {
                                    if (lastHitWasX10) {
                                        triggerBonus();
                                        lastHitWasX10 = false;
                                    } else {
                                        lastHitWasX10 = true;
                                    }
                                } else {
                                    lastHitWasX10 = false;
                                }
                                lastMultiplier = box.multiplier;

                                if (particlesEnabled) {
                                    for (let i = 0; i < 15; i++) {
                                        particles.push({
                                            x: coin.x, y: coin.y,
                                            vx: (Math.random()-0.5)*6,
                                            vy: (Math.random()-0.5)*6,
                                            life: 25 + Math.random()*15,
                                            color: (box.multiplier === 10) ? '#FFD700' : '#FFFFFF'
                                        });
                                    }
                                }
                            } else {
                                // Mini coins from bonus
                                const winAmt = box.multiplier * 2;
                                updateBalance(winAmt);
                                if (particlesEnabled) {
                                    for (let i = 0; i < 8; i++) {
                                        particles.push({
                                            x: coin.x, y: coin.y,
                                            vx: (Math.random()-0.5)*4,
                                            vy: (Math.random()-0.5)*4,
                                            life: 20 + Math.random()*10,
                                            color: '#FFAA00'
                                        });
                                    }
                                }
                            }
                            return;
                        }
                    }
                }
            }

            // Boundaries
            if (coin.x < coin.radius) {
                coin.x = coin.radius;
                coin.vx *= -0.7;
            }
            if (coin.x > width - coin.radius) {
                coin.x = width - coin.radius;
                coin.vx *= -0.7;
            }
            if (coin.y > height + 50) {
                coin.landed = true;
            }
        }

        function updateParticles() {
            for (let p of particles) {
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
            }
            particles = particles.filter(p => p.life > 0);
        }

        function drawParticles() {
            for (let p of particles) {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 30;
                ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
            }
            ctx.globalAlpha = 1;
        }

        function addMessage(text) {
            const div = document.createElement('div');
            div.className = 'message-overlay';
            div.textContent = text;
            gameContainer.appendChild(div);
            setTimeout(() => div.remove(), 2200);
        }

        function triggerBonus() {
            gameState = 'bonus_intro';
            bonus.active = true;
            bonus.cracking = false;
            bonus.hp = bonus.maxHp;
            bonus.miniCoins = [];
            bonus.giantCoinScale = 2.8;
            bonus.bannerShown = false;

            playBonusStartSound();

            const bannerDiv = document.createElement('div');
            bannerDiv.className = 'bonus-banner';
            const img = document.createElement('img');
            img.src = bonusBannerImg.src;
            bannerDiv.appendChild(img);
            const txt = document.createElement('div');
            txt.className = 'bonus-text';
            txt.textContent = 'TAP THE COIN TO CRACK IT';
            bannerDiv.appendChild(txt);
            gameContainer.appendChild(bannerDiv);

            setTimeout(() => {
                bannerDiv.remove();
                bonus.bannerShown = true;
                gameState = 'bonus_active';
            }, 2200);
        }

        function updateBonusGiantCoinOnClick(x, y) {
            if (!bonus.active || gameState !== 'bonus_active') return;
            const cx = width/2;
            const cy = height/2;
            const r = coinRadius * bonus.giantCoinScale;
            const dx = x - cx;
            const dy = y - cy;
            if (Math.sqrt(dx*dx + dy*dy) <= r) {
                bonus.hp -= 10;
                playBonusHitSound();
                if (bonus.hp <= 0) {
                    bonus.hp = 0;
                    bonus.cracking = true;
                    setTimeout(() => {
                        playBonusExplosionSound();
                        explodeBonusCoin();
                    }, 300);
                }
            }
        }

        function explodeBonusCoin() {
            const numCoins = 10 + Math.floor(Math.random()*6);
            for (let i = 0; i < numCoins; i++) {
                const angle = (Math.random() * Math.PI * 2);
                const speed = 3 + Math.random()*4;
                bonus.miniCoins.push({
                    x: width/2,
                    y: height/2,
                    vx: Math.cos(angle)*speed,
                    vy: Math.sin(angle)*speed,
                    radius: coinRadius * 0.7,
                    spinning: 0,
                    landed: false,
                    prize: null
                });
            }
            gameState = 'bonus_cleanup';
            if (particlesEnabled) {
                for (let i = 0; i < 40; i++) {
                    particles.push({
                        x: width/2, y: height/2,
                        vx: (Math.random()-0.5)*10,
                        vy: (Math.random()-0.5)*10,
                        life: 30 + Math.random()*20,
                        color: '#FFD700'
                    });
                }
            }
        }

        function drawScene() {
            ctx.clearRect(0, 0, width, height);

            // Drop zone hint
            if (hintEnabled && gameState === 'idle') {
                ctx.fillStyle = 'rgba(212, 175, 55, 0.15)';
                ctx.fillRect(0, 0, width, dropZoneHeightPx);
                ctx.strokeStyle = 'rgba(212, 175, 55, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 4]);
                ctx.strokeRect(0, 0, width, dropZoneHeightPx);
                ctx.setLineDash([]);
            }

            // Pegs
            for (let peg of pegGrid) {
                if (pegImg.complete && pegImg.naturalWidth > 0) {
                    const size = pegRadius * 2;
                    ctx.drawImage(pegImg, peg.x - size/2, peg.y - size/2, size, size);
                } else {
                    ctx.fillStyle = '#555';
                    ctx.beginPath();
                    ctx.arc(peg.x, peg.y, pegRadius, 0, Math.PI*2);
                    ctx.fill();
                }
            }

            // Prize boxes scrolling
            if (gameState === 'idle' || gameState === 'dropping') {
                prizeOffset += prizeScrollDirection * prizeScrollSpeed;
                const totalWidth = (prizeBoxes[prizeBoxes.length-1].baseX + prizeBoxes[prizeBoxes.length-1].width);
                if (prizeOffset < -totalWidth) {
                    prizeOffset += totalWidth;
                } else if (prizeOffset > totalWidth) {
                    prizeOffset -= totalWidth;
                }
            }

            for (let pass = -2; pass <= 2; pass++) {
                const totalWidth = (prizeBoxes[prizeBoxes.length-1].baseX + prizeBoxes[prizeBoxes.length-1].width);
                for (let box of prizeBoxes) {
                    const img = boxImgMap[box.multiplier];
                    const x = box.baseX + prizeOffset + (pass * totalWidth);
                    const y = prizeTrackY;
                    
                    // Only draw if visible on screen
                    if (x + box.width < 0 || x > width) continue;
                    
                    if (img.complete && img.naturalWidth > 0) {
                        ctx.drawImage(img, x, y, box.width, prizeBoxHeight);
                    } else {
                        ctx.fillStyle = 'rgba(30,30,30,0.9)';
                        ctx.fillRect(x, y, box.width, prizeBoxHeight);
                        ctx.strokeStyle = (box.multiplier === 10) ? 'gold' : '#888';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(x+2, y+2, box.width-4, prizeBoxHeight-4);
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 24px Cinzel, serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('x'+box.multiplier, x + box.width/2, y + prizeBoxHeight/2);
                    }
                }
            }

            if (hoverCoinX !== null && hoverEnabled && gameState === 'idle') {
                const y = dropZoneHeightPx * 0.5;
                const size = coinRadius * 2.2;
                ctx.save();
                ctx.translate(hoverCoinX, y);
                ctx.rotate(Math.sin(performance.now()/400)*0.15);
                if (gunnerCoinImg.complete && gunnerCoinImg.naturalWidth > 0) {
                    ctx.drawImage(gunnerCoinImg, -size/2, -size/2, size, size);
                } else {
                    ctx.fillStyle = 'gold';
                    ctx.beginPath();
                    ctx.arc(0, 0, coinRadius*1.1, 0, Math.PI*2);
                    ctx.fill();
                }
                ctx.restore();
            }

            if (mainCoin) {
                drawCoin(mainCoin);
            }

            if (bonus.active) {
                if (bonus.cracking || gameState === 'bonus_active') {
                    drawGiantBonusCoin();
                }
                for (let mc of bonus.miniCoins) {
                    drawCoin(mc, true);
                }
            }

            drawParticles();
        }

        function drawCoin(coin, isMini=false) {
            const size = coin.radius * 2;
            ctx.save();
            ctx.translate(coin.x, coin.y);
            ctx.rotate(coin.spinning);
            if (gunnerCoinImg.complete && gunnerCoinImg.naturalWidth > 0) {
                ctx.drawImage(gunnerCoinImg, -size/2, -size/2, size, size);
            } else {
                ctx.fillStyle = 'gold';
                ctx.beginPath();
                ctx.arc(0,0, coin.radius, 0, Math.PI*2);
                ctx.fill();
            }
            ctx.restore();
        }

        function drawGiantBonusCoin() {
            const r = coinRadius * bonus.giantCoinScale;
            const cx = width/2;
            const cy = height/2;
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(Math.sin(performance.now()/300)*0.08);
            const size = r * 2;
            if (gunnerCoinImg.complete && gunnerCoinImg.naturalWidth > 0) {
                ctx.drawImage(gunnerCoinImg, -size/2, -size/2, size, size);
            } else {
                ctx.fillStyle = 'gold';
                ctx.beginPath();
                ctx.arc(0,0,r,0,Math.PI*2);
                ctx.fill();
            }
            ctx.restore();

            const barW = width * 0.4;
            const barH = 16;
            const x = (width - barW)/2;
            const y = cy + r + 30;
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(x, y, barW, barH);
            const pct = bonus.hp / bonus.maxHp;
            ctx.fillStyle = 'rgba(212,175,55,0.9)';
            ctx.fillRect(x+2, y+2, (barW-4)*pct, barH-4);
            ctx.strokeStyle = 'gold';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, barW, barH);

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 13px Cinzel, serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('COIN BREAKER', width/2, y - 10);
        }

        function loop() {
            requestAnimationFrame(loop);

            if (width === 0 || height === 0) return;

            if (gameState === 'dropping') {
                if (mainCoin && !mainCoin.landed) {
                    updateCoinPhysics(mainCoin, false);
                } else if (mainCoin && mainCoin.landed) {
                    mainCoin = null;
                    gameState = bonus.active ? 'bonus_active' : 'idle';
                }
            }

            if (bonus.active) {
                if (gameState === 'bonus_cleanup' || gameState === 'bonus_active') {
                    for (let mc of bonus.miniCoins) {
                        if (!mc.landed) updateCoinPhysics(mc, true);
                    }
                    bonus.miniCoins = bonus.miniCoins.filter(c => !c.landed || (c.prize === null));
                    let allLanded = true;
                    for (let mc of bonus.miniCoins) {
                        if (!mc.landed) { allLanded = false; break; }
                    }
                    if (gameState === 'bonus_cleanup' && allLanded) {
                        bonus.active = false;
                        bonus.miniCoins = [];
                        gameState = 'idle';
                        addMessage('BONUS COMPLETE');
                    }
                }
            }

            updateParticles();
            drawScene();
        }

        function onPointerMove(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX || (e.touches && e.touches[0].clientX)) - rect.left;
            const y = (e.clientY || (e.touches && e.touches[0].clientY)) - rect.top;
            if (y >= 0 && y <= dropZoneHeightPx) {
                hoverCoinX = x;
            } else {
                hoverCoinX = null;
            }
        }

        function onPointerUp(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX || (e.changedTouches && e.changedTouches[0].clientX)) - rect.left;
            const y = (e.clientY || (e.changedTouches && e.changedTouches[0].clientY)) - rect.top;

            if (bonus.active && (gameState === 'bonus_active' || gameState === 'bonus_intro')) {
                updateBonusGiantCoinOnClick(x, y);
                return;
            }

            if (y >= 0 && y <= dropZoneHeightPx) {
                startDropFromX(x);
            }
        }

        canvas.addEventListener('mousemove', onPointerMove);
        canvas.addEventListener('touchmove', onPointerMove, { passive: true });
        canvas.addEventListener('mouseup', onPointerUp);
        canvas.addEventListener('touchend', onPointerUp);

        dropButton.addEventListener('click', () => {
            if (hoverCoinX === null) {
                startDropFromX(width/2);
            } else {
                startDropFromX(hoverCoinX);
            }
        });

        settingsBtn.addEventListener('click', () => settingsModal.classList.add('active'));
        closeSettings.addEventListener('click', () => settingsModal.classList.remove('active'));

        soundToggle.addEventListener('click', () => {
            soundToggle.classList.toggle('active');
            soundEnabled = soundToggle.classList.contains('active');
        });
        particleToggle.addEventListener('click', () => {
            particleToggle.classList.toggle('active');
            particlesEnabled = particleToggle.classList.contains('active');
        });
        hintToggle.addEventListener('click', () => {
            hintToggle.classList.toggle('active');
            hintEnabled = hintToggle.classList.contains('active');
        });

        startGameBtn.addEventListener('click', () => {
            loadingOverlay.style.opacity = '0';
            loadingOverlay.style.transition = 'opacity 0.4s';
            setTimeout(() => loadingOverlay.style.display = 'none', 420);
            if (audioContext.state === 'suspended') audioContext.resume();
        });

        window.addEventListener('resize', resizeCanvas);

        resizeCanvas();
        loop();
        initAuth();
    </script>
</body>
</html>