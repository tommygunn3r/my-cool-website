<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>GunnerCoin Drop</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Same vibe as Blackjack -->
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Cormorant+Garamond:wght@300;400;600&display=swap" rel="stylesheet">

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --gold: #d4af37;
            --gold-dark: #b8941f;
            --gold-light: #f4e5a7;
            --cream: #f5f3e8;
            --dark: #0b0907;
            --accent: #2b1242;
        }

        body {
            font-family: 'Cormorant Garamond', serif;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            background-color: #000;
            background-image: url('/games/assets/casino/background.png');
            background-size: cover;
            background-position: center;
            color: var(--cream);
        }

        #loadingOverlay {
            position: fixed; inset: 0;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: radial-gradient(circle at top, #311844 0%, #050308 60%, #000 100%);
            z-index: 1000;
        }
        #loadingTitle {
            font-family: 'Cinzel', serif;
            font-size: 3rem;
            letter-spacing: 0.16em;
            color: var(--gold);
            text-shadow: 0 0 18px rgba(0,0,0,0.9);
            margin-bottom: 1rem;
        }
        #loadingLogo {
            width: clamp(220px, 40vw, 420px);
            height: auto;
            margin-bottom: 1.5rem;
        }
        #loadingMsg {
            color: var(--gold-light);
            font-size: 1.1rem;
            letter-spacing: 0.08em;
            margin-bottom: 1.5rem;
            animation: pulse 1.6s infinite;
        }
        #startGameBtn {
            font-family: 'Cinzel', serif;
            font-size: 1.3rem;
            padding: 0.8rem 3rem;
            border-radius: 999px;
            border: none;
            cursor: pointer;
            background: linear-gradient(135deg, var(--gold) 0%, var(--gold-dark) 100%);
            color: #000;
            letter-spacing: 0.14em;
            box-shadow: 0 0 25px rgba(212,175,55,0.6);
            display: none;
        }
        #startGameBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 35px rgba(212,175,55,0.9);
        }
        @keyframes pulse {
            0% { opacity: 0.4; }
            50% { opacity: 1; }
            100% { opacity: 0.4; }
        }

        #gameShell {
            position: relative;
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
        }

        .header {
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.6rem 1.2rem;
            background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.65) 100%);
            border-bottom: 2px solid rgba(212,175,55,0.7);
        }
        .logo {
            display: flex; align-items: center; gap: 0.7rem;
        }
        .logo-main {
            font-family: 'Cinzel', serif;
            letter-spacing: 0.18em;
            font-size: 1.1rem;
            color: var(--gold);
        }
        .logo-sub {
            font-size: 0.9rem;
            letter-spacing: 0.16em;
            text-transform: uppercase;
            color: var(--gold-light);
            opacity: 0.9;
        }
        .balance {
            display: flex; align-items: center; gap: 0.45rem;
            font-size: 1.1rem;
        }
        .coin-icon {
            width: 28px; height: 28px;
            border-radius: 50%;
            background: radial-gradient(circle, var(--gold-light) 0%, var(--gold) 60%, var(--gold-dark) 100%);
            display: flex; align-items: center; justify-content: center;
            font-weight: 700; color: #000;
            box-shadow: 0 0 10px rgba(212,175,55,0.7);
            font-size: 1rem;
        }
        #balanceText {
            font-weight: 600;
            letter-spacing: 0.1em;
        }

        .settings-button {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid var(--gold);
            color: var(--gold);
            width: 40px; height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.1rem;
            transition: all 0.3s;
            display: flex; align-items: center; justify-content: center;
        }
        .settings-button:hover { background: rgba(212,175,55,0.15); transform: rotate(90deg); }

        .main-row {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        #gameCanvasContainer {
            position: relative;
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at top, rgba(0,0,0,0.85) 0%, rgba(0,0,0,0.95) 40%, #000 100%);
        }

        .controls {
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            padding: 0.6rem 0.8rem;
            background: linear-gradient(0deg, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.6) 100%);
            border-top: 2px solid rgba(212,175,55,0.7);
            flex-wrap: wrap;
        }
        .info-pill {
            padding: 0.3rem 0.8rem;
            border-radius: 999px;
            border: 1px solid rgba(212,175,55,0.5);
            background: rgba(0,0,0,0.7);
            font-size: 0.85rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }
        .game-button {
            font-family: 'Cinzel', serif;
            font-size: 0.95rem;
            padding: 0.55rem 1.4rem;
            border-radius: 999px;
            border: none;
            cursor: pointer;
            background: linear-gradient(135deg, var(--gold) 0%, var(--gold-dark) 100%);
            color: #000;
            letter-spacing: 0.12em;
            box-shadow: 0 0 16px rgba(212,175,55,0.6);
        }
        .game-button:disabled {
            opacity: 0.35;
            cursor: not-allowed;
            filter: grayscale(0.8);
            box-shadow: none;
        }

        .fixed-nav {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 200;
        }
        .nav-button {
            padding: 10px 18px;
            background: rgba(10, 10, 10, 0.95);
            border: 2px solid var(--gold);
            border-radius: 10px;
            color: var(--cream);
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 15px rgba(212, 175, 55, 0.3);
            font-family: 'Cinzel', serif;
        }
        .nav-button:hover {
            background: rgba(212, 175, 55, 0.2);
            box-shadow: 0 0 25px rgba(212, 175, 55, 0.6);
            transform: translateY(-2px);
        }

        .message-overlay {
            position: absolute;
            left: 50%; top: 18%;
            transform: translateX(-50%);
            background: radial-gradient(circle, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.9) 60%);
            border-radius: 999px;
            border: 3px solid var(--gold);
            padding: 0.7rem 2.5rem;
            z-index: 50;
            font-family: 'Cinzel', serif;
            font-size: 1.1rem;
            color: var(--gold-light);
            letter-spacing: 0.16em;
            text-align: center;
            white-space: nowrap;
            animation: overlayPop 0.4s ease-out, overlayFade 1.6s ease-out 0.6s forwards;
        }
        @keyframes overlayPop {
            0% { transform: translateX(-50%) scale(0.6); opacity: 0; }
            100% { transform: translateX(-50%) scale(1); opacity: 1; }
        }
        @keyframes overlayFade {
            to { opacity: 0; transform: translateX(-50%) translateY(-10px) scale(0.95); }
        }

        .bonus-banner {
            position: absolute;
            inset: 0;
            background: radial-gradient(circle, rgba(0,0,0,0.85) 0%, rgba(0,0,0,0.98) 60%);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 150;
            animation: bonusFadeIn 0.35s ease-out;
        }
        .bonus-banner img {
            max-width: 85%;
            height: auto;
            margin-bottom: 0.8rem;
        }
        .bonus-text {
            font-family: 'Cinzel', serif;
            letter-spacing: 0.18em;
            font-size: 0.9rem;
            text-transform: uppercase;
            color: var(--gold-light);
        }
        @keyframes bonusFadeIn {
            from { opacity: 0; transform: scale(1.04); }
            to { opacity: 1; transform: scale(1); }
        }

        #settingsModal {
            position: fixed; inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        #settingsModal.active { display: flex; }
        .modal-content {
            background: linear-gradient(135deg, #2a1f1a 0%, var(--dark) 100%);
            padding: 2rem 2.4rem;
            border-radius: 20px;
            border: 3px solid var(--gold);
            max-width: 460px;
            width: 90%;
        }
        .modal-title {
            font-family: 'Cinzel', serif;
            font-size: 1.6rem;
            color: var(--gold);
            margin-bottom: 1.4rem;
            letter-spacing: 0.14em;
        }
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.6rem 0;
            border-bottom: 1px solid rgba(212,175,55,0.3);
            font-size: 1rem;
        }
        .toggle {
            width: 56px; height: 28px;
            background: rgba(0,0,0,0.5);
            border: 2px solid var(--gold);
            border-radius: 999px;
            position: relative;
            cursor: pointer;
            transition: background 0.25s;
        }
        .toggle-slider {
            width: 22px; height: 22px;
            border-radius: 50%;
            background: var(--cream);
            position: absolute;
            top: 2px; left: 2px;
            transition: left 0.25s;
        }
        .toggle.active { background: var(--gold); }
        .toggle.active .toggle-slider { left: 30px; }

        .close-button {
            margin-top: 1.4rem;
            width: 100%;
        }

        @media (max-width: 768px) {
            .header {
                padding: 0.4rem 0.7rem;
            }
            .logo-main { font-size: 0.95rem; }
            .logo-sub { display: none; }
            .nav-button { padding: 8px 14px; font-size: 0.8rem; }
        }
    </style>
</head>
<body>
    <div id="loadingOverlay">
        <div id="loadingTitle">GUNNERCOIN DROP</div>
        <img id="loadingLogo" src="/games/assets/casino/gunnercoin_drop_logo.png" alt="GunnerCoin Drop Logo">
        <div id="loadingMsg">CONNECTING TO ACCOUNT...</div>
        <button id="startGameBtn">PLAY</button>
    </div>

    <div id="gameShell">
        <div class="header">
            <div class="logo">
                <div class="logo-main">GUNNERSGAMES</div>
                <div class="logo-sub">GUNNERCOIN DROP</div>
            </div>
            <button class="settings-button" id="settingsBtn">⚙</button>
            <div class="balance">
                <div class="coin-icon">G</div>
                <span id="balanceText">...</span>
            </div>
        </div>

        <div class="main-row">
            <div id="gameCanvasContainer">
                <canvas id="gameCanvas"></canvas>
                <!-- overlays injected here -->
            </div>
            <div class="controls">
                <div class="info-pill">Drop Cost: 1 GunnerCoin</div>
                <div class="info-pill">Payouts: x1 / x2 / x5 / x10</div>
                <div class="info-pill">Hit x10 twice in a row → COIN BREAKER BONUS</div>
                <button id="dropButton" class="game-button">DROP</button>
            </div>
        </div>
    </div>

    <div class="fixed-nav">
        <a href="#" class="nav-button" onclick="closeGame(); return false;">
            <span>←</span>
            <span>Back to Casino</span>
        </a>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal">
        <div class="modal-content">
            <div class="modal-title">SETTINGS</div>
            <div class="setting-row">
                <span>Sound Effects</span>
                <div class="toggle active" id="soundToggle"><div class="toggle-slider"></div></div>
            </div>
            <div class="setting-row">
                <span>Coin Trail Particles</span>
                <div class="toggle active" id="particleToggle"><div class="toggle-slider"></div></div>
            </div>
            <div class="setting-row">
                <span>Show Drop Hint</span>
                <div class="toggle active" id="hintToggle"><div class="toggle-slider"></div></div>
            </div>
            <button class="game-button close-button" id="closeSettings">CLOSE</button>
        </div>
    </div>

    <script type="module">
        function closeGame() { window.location.href = '/index.html'; }
        window.closeGame = closeGame;

        import { db } from '/firebase-config.js';
        import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { doc, getDoc, setDoc } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

        let auth = null;
        let userId = '';
        let playerName = '';
        let balance = 0;

        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingMsg = document.getElementById('loadingMsg');
        const startGameBtn = document.getElementById('startGameBtn');
        const balanceText = document.getElementById('balanceText');

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameCanvasContainer');

        const dropButton = document.getElementById('dropButton');

        const settingsModal = document.getElementById('settingsModal');
        const settingsBtn = document.getElementById('settingsBtn');
        const closeSettings = document.getElementById('closeSettings');
        const soundToggle = document.getElementById('soundToggle');
        const particleToggle = document.getElementById('particleToggle');
        const hintToggle = document.getElementById('hintToggle');

        let soundEnabled = true;
        let particlesEnabled = true;
        let hintEnabled = true;

        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        function playTone(freq, duration, type = 'sine', vol = 0.25) {
            if (!soundEnabled) return;
            if (audioContext.state === 'suspended') audioContext.resume();
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.type = type;
            osc.frequency.value = freq;
            osc.connect(gain);
            gain.connect(audioContext.destination);
            gain.gain.setValueAtTime(vol, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            osc.start();
            osc.stop(audioContext.currentTime + duration);
        }
        function playDropSound() { playTone(260, 0.09, 'square'); }
        function playPegHitSound() { playTone(440 + Math.random()*80, 0.05, 'triangle', 0.15); }
        function playPrizeSound(mult) {
            if (mult >= 10) {
                playTone(523.25, 0.12);
                setTimeout(() => playTone(659.25, 0.12), 100);
                setTimeout(() => playTone(783.99, 0.16), 200);
            } else if (mult >= 5) {
                playTone(440, 0.12);
                setTimeout(() => playTone(660, 0.12), 110);
            } else if (mult >= 2) {
                playTone(370, 0.08);
                setTimeout(() => playTone(440, 0.1), 70);
            } else {
                playTone(280, 0.06);
            }
        }
        function playBonusStartSound() {
            playTone(300, 0.15);
            setTimeout(() => playTone(430, 0.2), 100);
            setTimeout(() => playTone(550, 0.25), 220);
        }
        function playBonusHitSound() { playTone(680, 0.07, 'square', 0.2); }
        function playBonusExplosionSound() {
            for (let i = 0; i < 12; i++) {
                setTimeout(() => playTone(200 + Math.random()*200, 0.06, 'sawtooth', 0.12), i*30);
            }
        }

        async function initAuth() {
            try {
                auth = getAuth(db.app);
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        playerName = user.displayName || "Player";
                        await loadUserBalance();
                        loadingMsg.textContent = 'READY';
                        startGameBtn.style.display = 'inline-block';
                    } else {
                        window.location.href = '/index.html';
                    }
                });
            } catch (err) {
                console.error('Auth init failed:', err);
                loadingMsg.textContent = 'AUTH ERROR';
            }
        }

        async function loadUserBalance() {
            try {
                const userDoc = doc(db, 'users', userId);
                const snap = await getDoc(userDoc);
                if (snap.exists()) {
                    balance = snap.data().gunnercoins || 0;
                } else {
                    balance = 0;
                }
                balanceText.textContent = balance.toLocaleString();
            } catch (e) {
                console.error('Balance load error:', e);
            }
        }

        function updateBalance(delta) {
            balance += delta;
            if (balance < 0) balance = 0;
            balanceText.textContent = balance.toLocaleString();
            const userDoc = doc(db, 'users', userId);
            setDoc(userDoc, { gunnercoins: balance }, { merge: true });
        }

        // ---------- GAME LOGIC ----------
        let width = 0;
        let height = 0;

        let gameState = 'idle'; // 'idle', 'dropping', 'bonus_intro', 'bonus_active', 'bonus_cleanup'
        let mainCoin = null;
        let coins = [];
        let pegGrid = [];
        let prizeBoxes = [];
        let hoverCoinX = null;
        let hoverEnabled = true;
        let lastMultiplier = 0;
        let lastHitWasX10 = false;

        const gravity = 0.38;
        const pegRadius = 8;          // was 11 – smaller peg for easier flow
        const coinRadius = 22;
        const dropZoneHeightRatio = 0.15;
        let dropZoneHeightPx = 0;

        const prizeBoxHeight = 60; // Reduced from 80 to match 25% shrink
        let prizeTrackY = 0;

        let prizeOffset = 0;
        let prizeSpeed = 1.4;
        let prizeScrollDirection = -1; // -1 = left, 1 = right
        let prizeScrollSpeed = 2; // pixels per frame

        let particles = [];

        let bonus = {
            hp: 100,
            maxHp: 100,
            active: false,
            cracking: false,
            miniCoins: [],
            giantCoinScale: 2.8,
            bannerShown: false,
        };

        const gunnerCoinImg = new Image();
        gunnerCoinImg.src = '/games/assets/casino/gunnercoin.png';

        const pegImg = new Image();
        pegImg.src = '/games/assets/casino/peg.png';

        const boxImgMap = {
            1: new Image(),
            2: new Image(),
            5: new Image(),
            10: new Image()
        };
        boxImgMap[1].src = '/games/assets/casino/box_x1.png';
        boxImgMap[2].src = '/games/assets/casino/box_x2.png';
        boxImgMap[5].src = '/games/assets/casino/box_x5.png';
        boxImgMap[10].src = '/games/assets/casino/box_x10.png';

        const bonusBannerImg = new Image();
        bonusBannerImg.src = '/games/assets/casino/coinbreaker_bonus.png';

        function resizeCanvas() {
            const rect = gameContainer.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            width = rect.width;
            height = rect.height;
            dropZoneHeightPx = height * dropZoneHeightRatio;
            prizeTrackY = height - prizeBoxHeight - 10;
            setupPegGrid();
            setupPrizeBoxes();
        }

        // UPDATED: Wider peg spacing so coin can fall
        function setupPegGrid() {
            pegGrid = [];

            const spacingX = 90;   // wider columns
            const spacingY = 90;   // wider rows
            let cols = Math.floor(width / spacingX) - 1;
            if (cols < 3) cols = 3;    // safety for small screens

            const rows = 7;
            const startY = dropZoneHeightPx + 80; // push first row lower

            for (let r = 0; r < rows; r++) {
                const y = startY + r * spacingY;
                for (let c = 0; c < cols; c++) {
                    let x = (c + 1) * spacingX;

                    // stagger every other row (classic Plinko layout)
                    if (r % 2 === 1) x += spacingX / 2;

                    pegGrid.push({ x, y });
                }
            }
        }

        function setupPrizeBoxes() {
            // Symmetric pattern: x1, x2, x5, x10, x10, x5, x2, x1
            const multipliers = [1, 2, 5, 10, 10, 5, 2, 1];
            
            // Shrink boxes by 25%
            const boxWidth = Math.min(135, width / (multipliers.length + 1)) * 0.75;
            
            // Gap should be at least 2x coin diameter (coinRadius * 2 * 2 = ~88px)
            const minGap = coinRadius * 4; // Extra spacing for difficulty
            
            prizeBoxes = [];
            let x = 0;
            
            for (let m of multipliers) {
                prizeBoxes.push({
                    baseX: x,
                    width: boxWidth,
                    multiplier: m
                });
                x += boxWidth + minGap;
            }
            
            // Store total width for wrapping
            prizeBoxes.totalWidth = x - minGap; // Don't count last gap
        }

        function addMessage(txt) {
            const msg = document.createElement('div');
            msg.className = 'message-overlay';
            msg.textContent = txt;
            gameContainer.appendChild(msg);
            setTimeout(() => msg.remove(), 2100);
        }

        function addParticles(x, y, count, color = 'gold') {
            if (!particlesEnabled) return;
            for (let i = 0; i < count; i++) {
                particles.push({
                    x,
                    y,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3,
                    life: 30 + Math.random()*20,
                    color
                });
            }
        }

        function createCoin(x, y, vy = 1, vx = 0) {
            return {
                x, y,
                vx, vy,
                radius: coinRadius,
                spinning: 0,
                landed: false,
                prize: null
            };
        }

        function startDropFromX(x) {
            if (gameState !== 'idle') return;
            if (balance < 1) {
                addMessage('INSUFFICIENT FUNDS');
                return;
            }
            updateBalance(-1);
            mainCoin = createCoin(x, dropZoneHeightPx + 10, 2);
            gameState = 'dropping';
            playDropSound();
            lastMultiplier = 0;
            
            // Switch scroll direction on each drop
            prizeScrollDirection *= -1;
        }

        function updateCoinPhysics(coin, isMini = false) {
            if (coin.landed) return;

            coin.vy += gravity * (isMini ? 1.2 : 1);
            coin.x += coin.vx;
            coin.y += coin.vy;
            coin.spinning += 0.18;

            // Edge collision – slightly softer rebound
            if (coin.x < coin.radius) {
                coin.x = coin.radius;
                coin.vx *= -0.35;
            }
            if (coin.x > width - coin.radius) {
                coin.x = width - coin.radius;
                coin.vx *= -0.35;
            }

            // Peg collisions
            for (let peg of pegGrid) {
                const dx = coin.x - peg.x;
                const dy = coin.y - peg.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const minDist = coin.radius + pegRadius;
                if (dist > 0 && dist < minDist) {
                    const nx = dx / dist;
                    const ny = dy / dist;
                    const overlap = minDist - dist;
                    coin.x += nx * overlap;
                    coin.y += ny * overlap;
                    const dot = coin.vx * nx + coin.vy * ny;
                    coin.vx -= 2 * dot * nx;
                    coin.vy -= 2 * dot * ny;
                    // Softer damping so it doesn't stall
                    coin.vx *= 0.92;
                    coin.vy *= 0.92;
                    playPegHitSound();
                    addParticles(coin.x, coin.y, 6, 'gold');
                }
            }

            // Prize line
            if (coin.y + coin.radius >= prizeTrackY) {
                const box = getPrizeBoxUnderCoin(coin.x);
                if (box) {
                    coin.landed = true;
                    coin.prize = box.multiplier;
                    handlePrizeResult(box.multiplier, isMini);
                } else {
                    coin.landed = true;
                    coin.prize = 0;
                }
            }

            // Fell off bottom (no prize)
            if (coin.y - coin.radius > height + 50) {
                coin.landed = true;
                coin.prize = 0;
            }
        }

        function getPrizeBoxUnderCoin(x) {
            const totalWidth = prizeBoxes.totalWidth || (prizeBoxes[prizeBoxes.length-1].baseX + prizeBoxes[prizeBoxes.length-1].width);
            
            // Check boxes in multiple passes to handle wrapping
            let idx = 0;
            for (let pass = -1; pass <= 1; pass++) {
                for (let box of prizeBoxes) {
                    const bx = box.baseX + prizeOffset + (pass * totalWidth);
                    if (x >= bx && x <= bx + box.width) {
                        return { ...box, x: bx, index: idx };
                    }
                    idx++;
                }
            }
            return null;
        }

        function handlePrizeResult(multiplier, isMini) {
            if (!isMini) {
                if (multiplier > 0) {
                    updateBalance(multiplier);
                }
                if (multiplier >= 10 && lastHitWasX10) {
                    triggerCoinBreaker();
                    lastHitWasX10 = false;
                } else {
                    lastHitWasX10 = (multiplier >= 10);
                }
                lastMultiplier = multiplier;
                if (multiplier > 0) {
                    addMessage(`WIN x${multiplier}`);
                    playPrizeSound(multiplier);
                } else {
                    addMessage('NO PRIZE');
                }
            } else {
                if (multiplier > 0) {
                    updateBalance(multiplier);
                    playBonusHitSound();
                }
            }
        }

        function triggerCoinBreaker() {
            gameState = 'bonus_intro';
            bonus.active = true;
            bonus.cracking = true;
            bonus.hp = bonus.maxHp = 100;
            bonus.miniCoins = [];
            bonus.bannerShown = false;
            playBonusStartSound();
            showBonusBanner();
        }

        function showBonusBanner() {
            const overlay = document.createElement('div');
            overlay.className = 'bonus-banner';
            overlay.id = 'bonusBannerOverlay';

            const img = document.createElement('img');
            img.src = '/games/assets/casino/coinbreaker_bonus.png';
            overlay.appendChild(img);

            const txt = document.createElement('div');
            txt.className = 'bonus-text';
            txt.textContent = 'TAP / CLICK TO SMASH THE GIANT COIN';
            overlay.appendChild(txt);

            gameContainer.appendChild(overlay);
            bonus.bannerShown = true;

            setTimeout(() => {
                overlay.style.opacity = '0';
                overlay.style.transition = 'opacity 0.4s';
                setTimeout(() => overlay.remove(), 420);
            }, 1400);

            setTimeout(() => {
                gameState = 'bonus_active';
            }, 500);
        }

        function updateBonusGiantCoinOnClick(evX, evY) {
            if (!bonus.active || !bonus.cracking) return;
            const cx = width / 2;
            const cy = height / 2;
            const maxR = coinRadius * bonus.giantCoinScale * 1.1;
            const dx = evX - cx;
            const dy = evY - cy;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist <= maxR) {
                bonus.hp -= 8 + Math.random()*4;
                if (bonus.hp < 0) bonus.hp = 0;
                playBonusHitSound();
                addParticles(evX, evY, 10, 'gold');
                if (bonus.hp <= 0) {
                    bonus.cracking = false;
                    startBonusMiniCoinExplosion();
                }
            }
        }

        function startBonusMiniCoinExplosion() {
            playBonusExplosionSound();
            const miniCount = 12;
            for (let i = 0; i < miniCount; i++) {
                const angle = (Math.PI * 2 * i) / miniCount;
                const speed = 4 + Math.random() * 2;
                const mc = createCoin(width/2, height/2, Math.sin(angle)*speed, Math.cos(angle)*speed);
                mc.radius = coinRadius * 0.7;
                bonus.miniCoins.push(mc);
            }
            gameState = 'bonus_cleanup';
        }

        function updateParticles() {
            for (let p of particles) {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 1;
                p.vy += 0.03;
            }
            particles = particles.filter(p => p.life > 0);
        }

        function drawParticles() {
            for (let p of particles) {
                const alpha = Math.max(0, p.life / 50);
                ctx.fillStyle = p.color === 'gold'
                    ? `rgba(244, 215, 122, ${alpha})`
                    : `rgba(255,255,255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 2.5, 0, Math.PI*2);
                ctx.fill();
            }
        }

        function drawScene() {
            ctx.clearRect(0,0,width,height);

            const grad = ctx.createRadialGradient(width/2, 0, width*0.1, width/2, height, width);
            grad.addColorStop(0, 'rgba(31,23,46,0.9)');
            grad.addColorStop(0.5, 'rgba(7,4,10,0.96)');
            grad.addColorStop(1, 'rgba(0,0,0,1)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,width,height);

            if (hintEnabled) {
                ctx.fillStyle = 'rgba(255,255,255,0.05)';
                ctx.fillRect(0, 0, width, dropZoneHeightPx);
            }

            for (let peg of pegGrid) {
                if (pegImg.complete && pegImg.naturalWidth > 0) {
                    const s = pegRadius*2;
                    ctx.drawImage(pegImg, peg.x - s/2, peg.y - s/2, s, s);
                } else {
                    ctx.fillStyle = '#444';
                    ctx.beginPath();
                    ctx.arc(peg.x, peg.y, pegRadius, 0, Math.PI*2);
                    ctx.fill();
                }
            }


            // Update prize box scrolling
            prizeOffset += prizeScrollSpeed * prizeScrollDirection;
            
            // Wrap around when scrolling
            const totalWidth = prizeBoxes.totalWidth || (prizeBoxes[prizeBoxes.length-1].baseX + prizeBoxes[prizeBoxes.length-1].width);
            if (prizeScrollDirection < 0) {
                // Scrolling left
                if (prizeOffset < -totalWidth) {
                    prizeOffset += totalWidth;
                }
            } else {
                // Scrolling right
                if (prizeOffset > width) {
                    prizeOffset -= totalWidth;
                }
            }

            // Draw boxes multiple times to create seamless loop
            for (let pass = -1; pass <= 1; pass++) {
                for (let box of prizeBoxes) {
                    const img = boxImgMap[box.multiplier];
                    const x = box.baseX + prizeOffset + (pass * totalWidth);
                    const y = prizeTrackY;
                    
                    // Only draw if visible on screen
                    if (x + box.width < 0 || x > width) continue;
                    
                    if (img.complete && img.naturalWidth > 0) {
                        ctx.drawImage(img, x, y, box.width, prizeBoxHeight);
                    } else {
                        ctx.fillStyle = 'rgba(30,30,30,0.9)';
                        ctx.fillRect(x, y, box.width, prizeBoxHeight);
                        ctx.strokeStyle = (box.multiplier === 10) ? 'gold' : '#888';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(x+2, y+2, box.width-4, prizeBoxHeight-4);
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 24px Cinzel, serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('x'+box.multiplier, x + box.width/2, y + prizeBoxHeight/2);
                    }
                }
            }

            if (hoverCoinX !== null && hoverEnabled && gameState === 'idle') {
                const y = dropZoneHeightPx * 0.5;
                const size = coinRadius * 2.2;
                ctx.save();
                ctx.translate(hoverCoinX, y);
                ctx.rotate(Math.sin(performance.now()/400)*0.15);
                if (gunnerCoinImg.complete && gunnerCoinImg.naturalWidth > 0) {
                    ctx.drawImage(gunnerCoinImg, -size/2, -size/2, size, size);
                } else {
                    ctx.fillStyle = 'gold';
                    ctx.beginPath();
                    ctx.arc(0, 0, coinRadius*1.1, 0, Math.PI*2);
                    ctx.fill();
                }
                ctx.restore();
            }

            if (mainCoin) {
                drawCoin(mainCoin);
            }

            if (bonus.active) {
                if (bonus.cracking || gameState === 'bonus_active') {
                    drawGiantBonusCoin();
                }
                for (let mc of bonus.miniCoins) {
                    drawCoin(mc, true);
                }
            }

            drawParticles();
        }

        function drawCoin(coin, isMini=false) {
            const size = coin.radius * 2;
            ctx.save();
            ctx.translate(coin.x, coin.y);
            ctx.rotate(coin.spinning);
            if (gunnerCoinImg.complete && gunnerCoinImg.naturalWidth > 0) {
                ctx.drawImage(gunnerCoinImg, -size/2, -size/2, size, size);
            } else {
                ctx.fillStyle = 'gold';
                ctx.beginPath();
                ctx.arc(0,0, coin.radius, 0, Math.PI*2);
                ctx.fill();
            }
            ctx.restore();
        }

        function drawGiantBonusCoin() {
            const r = coinRadius * bonus.giantCoinScale;
            const cx = width/2;
            const cy = height/2;
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(Math.sin(performance.now()/300)*0.08);
            const size = r * 2;
            if (gunnerCoinImg.complete && gunnerCoinImg.naturalWidth > 0) {
                ctx.drawImage(gunnerCoinImg, -size/2, -size/2, size, size);
            } else {
                ctx.fillStyle = 'gold';
                ctx.beginPath();
                ctx.arc(0,0,r,0,Math.PI*2);
                ctx.fill();
            }
            ctx.restore();

            const barW = width * 0.4;
            const barH = 16;
            const x = (width - barW)/2;
            const y = cy + r + 30;
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(x, y, barW, barH);
            const pct = bonus.hp / bonus.maxHp;
            ctx.fillStyle = 'rgba(212,175,55,0.9)';
            ctx.fillRect(x+2, y+2, (barW-4)*pct, barH-4);
            ctx.strokeStyle = 'gold';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, barW, barH);

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 13px Cinzel, serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('COIN BREAKER', width/2, y - 10);
        }

        function loop() {
            requestAnimationFrame(loop);

            if (width === 0 || height === 0) return;

            if (gameState === 'dropping') {
                if (mainCoin && !mainCoin.landed) {
                    updateCoinPhysics(mainCoin, false);
                } else if (mainCoin && mainCoin.landed) {
                    mainCoin = null;
                    gameState = bonus.active ? 'bonus_active' : 'idle';
                }
            }

            if (bonus.active) {
                if (gameState === 'bonus_cleanup' || gameState === 'bonus_active') {
                    for (let mc of bonus.miniCoins) {
                        if (!mc.landed) updateCoinPhysics(mc, true);
                    }
                    bonus.miniCoins = bonus.miniCoins.filter(c => !c.landed || (c.prize === null));
                    let allLanded = true;
                    for (let mc of bonus.miniCoins) {
                        if (!mc.landed) { allLanded = false; break; }
                    }
                    if (gameState === 'bonus_cleanup' && allLanded) {
                        bonus.active = false;
                        bonus.miniCoins = [];
                        gameState = 'idle';
                        addMessage('BONUS COMPLETE');
                    }
                }
            }

            updateParticles();
            drawScene();
        }

        function onPointerMove(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX || (e.touches && e.touches[0].clientX)) - rect.left;
            const y = (e.clientY || (e.touches && e.touches[0].clientY)) - rect.top;
            if (y >= 0 && y <= dropZoneHeightPx) {
                hoverCoinX = x;
            } else {
                hoverCoinX = null;
            }
        }

        function onPointerUp(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX || (e.changedTouches && e.changedTouches[0].clientX)) - rect.left;
            const y = (e.clientY || (e.changedTouches && e.changedTouches[0].clientY)) - rect.top;

            if (bonus.active && (gameState === 'bonus_active' || gameState === 'bonus_intro')) {
                updateBonusGiantCoinOnClick(x, y);
                return;
            }

            if (y >= 0 && y <= dropZoneHeightPx) {
                startDropFromX(x);
            }
        }

        canvas.addEventListener('mousemove', onPointerMove);
        canvas.addEventListener('touchmove', onPointerMove, { passive: true });
        canvas.addEventListener('mouseup', onPointerUp);
        canvas.addEventListener('touchend', onPointerUp);

        dropButton.addEventListener('click', () => {
            if (hoverCoinX === null) {
                startDropFromX(width/2);
            } else {
                startDropFromX(hoverCoinX);
            }
        });

        settingsBtn.addEventListener('click', () => settingsModal.classList.add('active'));
        closeSettings.addEventListener('click', () => settingsModal.classList.remove('active'));

        soundToggle.addEventListener('click', () => {
            soundToggle.classList.toggle('active');
            soundEnabled = soundToggle.classList.contains('active');
        });
        particleToggle.addEventListener('click', () => {
            particleToggle.classList.toggle('active');
            particlesEnabled = particleToggle.classList.contains('active');
        });
        hintToggle.addEventListener('click', () => {
            hintToggle.classList.toggle('active');
            hintEnabled = hintToggle.classList.contains('active');
        });

        startGameBtn.addEventListener('click', () => {
            loadingOverlay.style.opacity = '0';
            loadingOverlay.style.transition = 'opacity 0.4s';
            setTimeout(() => loadingOverlay.style.display = 'none', 420);
            if (audioContext.state === 'suspended') audioContext.resume();
        });

        window.addEventListener('resize', resizeCanvas);

        resizeCanvas();
        loop();
        initAuth();
    </script>
</body>
</html>
