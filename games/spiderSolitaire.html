<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mom's Spider Solitaire</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* --- Classic Visuals --- */
        body {
            background-color: #1a472a; /* Classic Felt Green */
            overscroll-behavior: none;
            user-select: none;
            -webkit-user-select: none;
            font-family: sans-serif;
        }

        /* Card styling - High Contrast & Clean */
        .card {
            width: 100%;
            aspect-ratio: 2.5/3.5;
            background-color: white;
            border-radius: 0.4rem;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.4);
            position: absolute;
            transition: transform 0.1s, top 0.2s ease-out, left 0.2s ease-out;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 0.2rem;
            cursor: pointer;
            backface-visibility: hidden;
            z-index: 10;
        }
        
        @media (min-width: 640px) {
            .card {
                border-radius: 0.5rem;
                padding: 0.3rem;
                box-shadow: 2px 2px 5px rgba(0,0,0,0.4);
            }
        }

        .card-face-down {
            background: repeating-linear-gradient(
                45deg,
                #3b82f6,
                #3b82f6 10px,
                #2563eb 10px,
                #2563eb 20px
            );
            border: 2px solid white;
        }
        
        /* Hide content on face down cards */
        .card-face-down > * {
            display: none !important;
        }

        .card.selected {
            transform: translateY(-10px);
            box-shadow: 0 0 0 4px #fbbf24, 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            z-index: 50 !important;
        }

        .card.hint-anim {
            animation: wiggle 0.5s ease-in-out;
            z-index: 60 !important;
        }

        @keyframes wiggle {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-5deg); }
            75% { transform: rotate(5deg); }
        }

        /* Suit Colors */
        .suit-red { color: #dc2626; }
        .suit-black { color: #171717; }

        /* Layout Grid */
        .game-board {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 0.4rem;
            width: 100%;
            max-width: 1000px;
            margin: 0 auto;
            padding: 0.5rem;
        }
        
        @media (min-width: 768px) {
             .game-board { gap: 0.75rem; }
        }

        .column {
            position: relative;
            min-height: 60vh;
        }

        /* Top Bar */
        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background-color: rgba(0,0,0,0.25);
            color: white;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        /* Modal */
        .modal {
            background-color: rgba(0, 0, 0, 0.85);
        }
        
        /* Confetti Canvas */
        #confetti-canvas {
            position: fixed;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 100;
        }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden font-sans text-gray-900">

    <canvas id="confetti-canvas"></canvas>

    <!-- Header / Controls -->
    <div class="top-bar shrink-0 z-20">
        <div class="flex gap-2">
            <button onclick="toggleMenu()" class="bg-green-700 hover:bg-green-600 text-white px-3 py-2 sm:px-4 sm:py-2 rounded shadow font-bold border border-green-500 text-sm sm:text-base">
                Menu
            </button>
            <button onclick="undoMove()" id="undoBtn" class="bg-yellow-600 hover:bg-yellow-500 text-white px-3 py-2 sm:px-4 sm:py-2 rounded shadow font-bold border border-yellow-400 disabled:opacity-50 disabled:cursor-not-allowed text-sm sm:text-base">
                Undo
            </button>
        </div>
        
        <div class="flex flex-col items-center">
            <div class="text-lg sm:text-2xl font-bold text-green-50" id="scoreDisplay">Score: 500</div>
            <div class="text-xs sm:text-sm font-medium text-yellow-300" id="highScoreDisplay">Best: 0</div>
        </div>

        <div class="flex gap-2 items-center">
             <button onclick="showHint()" class="bg-blue-600 hover:bg-blue-500 text-white px-3 py-2 sm:px-4 sm:py-2 rounded shadow font-bold border border-blue-400 text-sm sm:text-base">
                Hint
            </button>
            <div class="relative w-16 h-20 sm:w-20 sm:h-28">
                <!-- Stock Pile -->
                <div id="stock-pile" onclick="dealStock()" class="card card-face-down absolute top-0 left-0 cursor-pointer hover:brightness-110 flex items-center justify-center">
                   <!-- "Deal" Label - Clean and Big -->
                   <div class="absolute inset-0 flex flex-col items-center justify-center bg-black bg-opacity-10">
                       <span class="text-white font-black text-lg sm:text-xl tracking-wider drop-shadow-md">DEAL</span>
                       <div class="mt-1 bg-white text-blue-800 font-bold text-xs px-2 py-0.5 rounded-full shadow-sm">
                           <span id="stock-count">5</span> left
                       </div>
                   </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Game Board -->
    <div class="flex-1 relative w-full overflow-hidden">
        
        <!-- Tableau (The 10 columns) -->
        <div class="game-board h-full pt-2" id="tableau">
            <!-- Columns generated by JS -->
        </div>

        <!-- Completed Sets (Foundations) -->
        <div id="foundations" class="absolute bottom-2 right-2 z-0 flex gap-1 opacity-60 pointer-events-none transform scale-75 origin-bottom-right">
            <!-- Completed King stacks will fly here -->
        </div>
    </div>

    <!-- Win Modal -->
    <div id="winModal" class="modal fixed inset-0 hidden flex items-center justify-center z-50">
        <div class="bg-white p-8 rounded-xl shadow-2xl text-center max-w-md mx-4 border-4 border-green-600">
            <h2 class="text-4xl font-bold text-green-700 mb-4">You Won!</h2>
            <p class="text-lg text-gray-700 mb-2">Final Score: <span id="finalScoreDisplay" class="font-bold">0</span></p>
            
            <button onclick="startNewGame()" class="bg-green-600 text-white px-8 py-3 rounded-lg text-xl font-bold shadow-lg hover:bg-green-500 transform hover:scale-105 transition">
                Play Again
            </button>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="menuModal" class="modal fixed inset-0 hidden flex items-center justify-center z-50">
        <div class="bg-white p-6 rounded-xl shadow-2xl max-w-sm w-full mx-4">
            <div class="flex justify-between items-center mb-6 border-b pb-2">
                <h2 class="text-2xl font-bold text-gray-800">Settings</h2>
                <button onclick="toggleMenu()" class="text-gray-500 hover:text-gray-800 text-3xl">&times;</button>
            </div>
            
            <div class="space-y-4">
                <div>
                    <label class="block text-gray-700 font-bold mb-2">Difficulty:</label>
                    <select id="difficultySelect" class="w-full p-3 border border-gray-300 rounded-lg bg-gray-50 text-lg font-medium">
                        <option value="1">Easy (1 Suit) - Spades</option>
                        <option value="2">Medium (2 Suits)</option>
                        <option value="4">Hard (4 Suits)</option>
                    </select>
                </div>

                <button onclick="confirmNewGame()" class="w-full bg-green-600 text-white py-3 rounded-lg font-bold text-lg shadow hover:bg-green-500 mt-4">
                    Start New Game
                </button>
                
                <button onclick="toggleMenu()" class="w-full bg-gray-200 text-gray-800 py-3 rounded-lg font-bold mt-2 hover:bg-gray-300">
                    Resume Game
                </button>
            </div>
        </div>
    </div>

    <div id="messageToast" class="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-black bg-opacity-90 text-white px-6 py-3 rounded-lg pointer-events-none opacity-0 transition-opacity duration-300 z-50 text-center font-bold text-lg shadow-xl border border-gray-600">
        Message
    </div>

    <script type="module">
        // Import Score Manager from your website structure
        import GameScoreManager from '../game-score-manager.js';

        // Initialize score manager
        let scoreManager;
        try {
            // Assuming this game ID is unique for your system
            scoreManager = new GameScoreManager('spider_solitaire', true);
        } catch (e) {
            console.warn("GameScoreManager not found. Leaderboard features disabled for preview.");
            // Mock for preview environment so game doesn't crash
            scoreManager = {
                startSession: () => {},
                submitGameResult: () => {},
                getElapsedTimeFormatted: () => "00:00"
            };
        }

        // --- SVG Assets for Clean Look ---
        const SVG_ICONS = {
            spades: `<svg viewBox="0 0 24 24" fill="currentColor" class="w-full h-full"><path d="M12,2C9,2 7,4.5 7,6.5C7,8.5 9,9.5 9,9.5C9,9.5 4,12.5 4,17C4,20.5 7,22 12,22C17,22 20,20.5 20,17C20,12.5 15,9.5 15,9.5C15,9.5 17,8.5 17,6.5C17,4.5 15,2 12,2M12,19C12,19 11,22 11,22L13,22C13,22 12,19 12,19Z" /></svg>`,
            hearts: `<svg viewBox="0 0 24 24" fill="currentColor" class="w-full h-full"><path d="M12,21.35L10.55,20.03C5.4,15.36 2,12.27 2,8.5C2,5.41 4.42,3 7.5,3C9.24,3 10.91,3.81 12,5.08C13.09,3.81 14.76,3 16.5,3C19.58,3 22,5.41 22,8.5C22,12.27 18.6,15.36 13.45,20.03L12,21.35Z" /></svg>`,
            clubs: `<svg viewBox="0 0 24 24" fill="currentColor" class="w-full h-full"><path d="M12,2C14.2,2 16,3.8 16,6C16,8.2 14.2,10 12,10C9.8,10 8,8.2 8,6C8,3.8 9.8,2 12,2M7,11C9.2,11 11,12.8 11,15C11,16.4 10.3,17.7 9.1,18.4C9.6,18.8 10.8,20.2 11,22H13C13.2,20.2 14.4,18.8 14.9,18.4C13.7,17.7 13,16.4 13,15C13,12.8 14.8,11 17,11C19.2,11 21,12.8 21,15C21,17.2 19.2,19 17,19C16.5,19 16,18.9 15.6,18.7C16.4,19.9 17,21.4 17,22H7C7,21.4 7.6,19.9 8.4,18.7C8,18.9 7.5,19 7,19C4.8,19 3,17.2 3,15C3,12.8 4.8,11 7,11Z" /></svg>`,
            diamonds: `<svg viewBox="0 0 24 24" fill="currentColor" class="w-full h-full"><path d="M19,12L12,22L5,12L12,2" /></svg>`
        };

        // --- Game Constants & State ---
        const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        const VALUES = { 'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13 };
        
        let state = {
            tableau: [[], [], [], [], [], [], [], [], [], []],
            stock: [],
            foundations: 0, 
            history: [], 
            score: 500,
            highScore: 0,
            difficulty: 1, 
            selectedCard: null 
        };

        // --- Initialization ---

        function init() {
            // Load difficulty
            const savedDiff = localStorage.getItem('spider_difficulty');
            if (savedDiff) state.difficulty = parseInt(savedDiff);
            document.getElementById('difficultySelect').value = state.difficulty;

            // Load High Score
            const savedHighScore = localStorage.getItem('spider_highscore');
            if (savedHighScore) state.highScore = parseInt(savedHighScore);
            updateHighScoreDisplay();

            startNewGame();
            window.addEventListener('resize', renderBoard);
        }

        function updateHighScoreDisplay() {
            document.getElementById('highScoreDisplay').textContent = `Best: ${state.highScore}`;
        }

        function toggleMenu() {
            const modal = document.getElementById('menuModal');
            modal.classList.toggle('hidden');
        }

        function confirmNewGame() {
            const select = document.getElementById('difficultySelect');
            state.difficulty = parseInt(select.value);
            localStorage.setItem('spider_difficulty', state.difficulty);
            toggleMenu();
            startNewGame();
        }

        function startNewGame() {
            document.getElementById('winModal').classList.add('hidden');
            stopConfetti();
            document.getElementById('foundations').innerHTML = ''; // Clear visuals

            state.score = 500;
            state.history = [];
            state.foundations = 0;
            state.selectedCard = null;
            updateUndoButton();
            
            // Start Score Manager Session
            scoreManager.startSession();

            createDeck();
            dealInitial();
            renderBoard();
            updateScore();
        }

        function createDeck() {
            let deck = [];
            let suitsToUse = [];
            if (state.difficulty === 1) suitsToUse = ['spades'];
            else if (state.difficulty === 2) suitsToUse = ['spades', 'hearts'];
            else suitsToUse = ['spades', 'hearts', 'clubs', 'diamonds'];

            const setsPerSuit = 8 / suitsToUse.length;

            for (let s of suitsToUse) {
                for (let i = 0; i < setsPerSuit; i++) {
                    for (let r of RANKS) {
                        deck.push({
                            rank: r,
                            suit: s,
                            value: VALUES[r],
                            faceUp: false,
                            id: Math.random().toString(36).substr(2, 9)
                        });
                    }
                }
            }

            // Shuffle
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            state.stock = deck;
        }

        function dealInitial() {
            state.tableau = [[], [], [], [], [], [], [], [], [], []];
            for (let i = 0; i < 54; i++) {
                const col = i % 10;
                const card = state.stock.pop();
                // Last card in col logic
                const isLastForCol = (col < 4 && state.tableau[col].length === 5) || (col >= 4 && state.tableau[col].length === 4);
                card.faceUp = isLastForCol;
                state.tableau[col].push(card);
            }
        }

        // --- Logic ---

        function saveState() {
            const snapshot = {
                tableau: JSON.parse(JSON.stringify(state.tableau)),
                stock: JSON.parse(JSON.stringify(state.stock)),
                score: state.score,
                foundations: state.foundations
            };
            state.history.push(snapshot);
            if (state.history.length > 20) state.history.shift();
            updateUndoButton();
        }

        function undoMove() {
            if (state.history.length === 0) return;
            const prev = state.history.pop();
            state.tableau = prev.tableau;
            state.stock = prev.stock;
            state.score = prev.score;
            state.foundations = prev.foundations;
            state.selectedCard = null;
            
            // Clear foundation visuals and rebuild them based on count
            const fContainer = document.getElementById('foundations');
            fContainer.innerHTML = '';
            // We don't store exactly which suits were in foundation in simple state, 
            // but for visual consistency we can just show generic backs or simple placeholders if needed.
            // For now, simply clearing is safer than desync. 
            // Re-adding placeholder visuals:
            for(let i=0; i<state.foundations; i++) {
                addFoundationGraphic('spades'); // Just a placeholder suit for visual count
            }

            renderBoard();
            updateUndoButton();
            updateScore();
        }

        function updateUndoButton() {
            document.getElementById('undoBtn').disabled = state.history.length === 0;
        }

        function isMoveValid(card, targetColIndex) {
            const targetCol = state.tableau[targetColIndex];
            if (targetCol.length === 0) return true;
            const topCard = targetCol[targetCol.length - 1];
            return topCard.value === card.value + 1;
        }

        function canMoveStack(colIndex, cardIndex) {
            const col = state.tableau[colIndex];
            const card = col[cardIndex];
            for (let i = cardIndex; i < col.length - 1; i++) {
                const current = col[i];
                const next = col[i+1];
                if (current.suit !== next.suit || current.value !== next.value + 1) return false;
            }
            return true;
        }

        function handleCardClick(colIndex, cardIndex) {
            const col = state.tableau[colIndex];
            const card = col[cardIndex];

            if (!card.faceUp) return;

            if (state.selectedCard && state.selectedCard.colIndex === colIndex && state.selectedCard.cardIndex === cardIndex) {
                state.selectedCard = null;
                renderBoard();
                return;
            }

            if (state.selectedCard) {
                attemptMove(state.selectedCard.colIndex, state.selectedCard.cardIndex, colIndex);
            } else {
                if (canMoveStack(colIndex, cardIndex)) {
                    state.selectedCard = { colIndex, cardIndex };
                    renderBoard();
                } else {
                    showMessage("Cards must match suit to move together");
                }
            }
        }

        function handleEmptyColumnClick(colIndex) {
            if (state.selectedCard) {
                attemptMove(state.selectedCard.colIndex, state.selectedCard.cardIndex, colIndex);
            }
        }

        function attemptMove(fromColIdx, fromCardIdx, toColIdx) {
            if (fromColIdx === toColIdx) return;

            const movingStack = state.tableau[fromColIdx].slice(fromCardIdx);
            const leadCard = movingStack[0];
            
            if (isMoveValid(leadCard, toColIdx)) {
                saveState();
                state.tableau[fromColIdx].splice(fromCardIdx);
                state.tableau[toColIdx].push(...movingStack);
                
                if (state.tableau[fromColIdx].length > 0) {
                    const newTop = state.tableau[fromColIdx][state.tableau[fromColIdx].length - 1];
                    if (!newTop.faceUp) {
                        newTop.faceUp = true;
                        state.score += 10;
                    }
                }

                state.score -= 1;
                state.selectedCard = null;
                checkCompletedRun(toColIdx);
                renderBoard();
                updateScore();
            } else {
                showMessage("Invalid Move");
                state.selectedCard = null;
                renderBoard();
            }
        }

        function checkCompletedRun(colIdx) {
            const col = state.tableau[colIdx];
            if (col.length < 13) return;

            const last13 = col.slice(col.length - 13);
            if (last13[0].value !== 13) return; 
            
            let isRun = true;
            const suit = last13[0].suit;
            
            for (let i = 0; i < 13; i++) {
                if (last13[i].suit !== suit || last13[i].value !== 13 - i) {
                    isRun = false;
                    break;
                }
            }

            if (isRun) {
                col.splice(col.length - 13, 13);
                state.foundations++;
                state.score += 100;
                addFoundationGraphic(suit);
                
                if (col.length > 0) {
                    const newTop = col[col.length - 1];
                    newTop.faceUp = true;
                }
                
                // Check WIN Condition
                if (state.foundations === 8) {
                    // 1. Update Local High Score
                    if (state.score > state.highScore) {
                        state.highScore = state.score;
                        localStorage.setItem('spider_highscore', state.highScore);
                        updateHighScoreDisplay();
                    }
                    
                    // 2. Submit to Leaderboard (External)
                    scoreManager.submitGameResult(state.score);

                    setTimeout(() => {
                        document.getElementById('finalScoreDisplay').innerText = `Final Score: ${state.score}`;
                        document.getElementById('winModal').classList.remove('hidden');
                        startConfetti();
                    }, 500);
                }
            }
        }

        function addFoundationGraphic(suit) {
            const fContainer = document.getElementById('foundations');
            const div = document.createElement('div');
            div.className = 'w-10 h-14 sm:w-14 sm:h-20 bg-white rounded border-2 border-gray-300 flex items-center justify-center shadow-md ' + getSuitColor(suit);
            div.innerHTML = `<div class="w-6 h-6 sm:w-8 sm:h-8">${SVG_ICONS[suit]}</div>`;
            fContainer.appendChild(div);
        }

        function dealStock() {
            if (state.stock.length === 0) return;
            const hasEmpty = state.tableau.some(col => col.length === 0);
            if (hasEmpty) {
                showMessage("Cannot deal with empty columns");
                return;
            }
            saveState();
            for (let i = 0; i < 10; i++) {
                if (state.stock.length > 0) {
                    const card = state.stock.pop();
                    card.faceUp = true;
                    state.tableau[i].push(card);
                    checkCompletedRun(i);
                }
            }
            renderBoard();
        }

        // --- Rendering ---

        function getSuitColor(suit) {
            return (suit === 'hearts' || suit === 'diamonds') ? 'suit-red' : 'suit-black';
        }

        function renderBoard() {
            const tableauEl = document.getElementById('tableau');
            tableauEl.innerHTML = '';

            document.getElementById('stock-count').textContent = Math.floor(state.stock.length / 10);
            const stockEl = document.getElementById('stock-pile');
            if (state.stock.length === 0) {
                stockEl.classList.add('opacity-0', 'pointer-events-none');
            } else {
                stockEl.classList.remove('opacity-0', 'pointer-events-none');
            }

            state.tableau.forEach((col, colIndex) => {
                const colEl = document.createElement('div');
                colEl.className = 'column';
                colEl.onclick = (e) => {
                    if(e.target === colEl) handleEmptyColumnClick(colIndex);
                };

                // Calculate overlap based on screen height to prevent overflow
                let overlap = 30; // px
                if (window.innerWidth < 640) overlap = 25;
                if (col.length > 15) overlap = 20;

                col.forEach((card, cardIndex) => {
                    const cardEl = document.createElement('div');
                    cardEl.className = `card ${card.faceUp ? '' : 'card-face-down'} ${getSuitColor(card.suit)}`;
                    cardEl.style.top = `${cardIndex * overlap}px`;
                    cardEl.style.zIndex = cardIndex;

                    // Selection styling
                    if (state.selectedCard && state.selectedCard.colIndex === colIndex && state.selectedCard.cardIndex === cardIndex) {
                        cardEl.classList.add('selected');
                    }

                    if (card.faceUp) {
                        // Top Left
                        const topDiv = document.createElement('div');
                        topDiv.className = 'flex flex-col items-center leading-none select-none';
                        topDiv.innerHTML = `<span class="text-lg font-bold">${card.rank}</span><span class="text-xl">${SVG_ICONS[card.suit]}</span>`;
                        
                        // Center (Large Suit)
                        const centerDiv = document.createElement('div');
                        centerDiv.className = 'absolute inset-0 flex items-center justify-center opacity-100 pointer-events-none';
                        centerDiv.innerHTML = `<span class="text-6xl opacity-30">${ICONS[card.suit]}</span>`;

                        // Bottom Right (Rotated)
                        const botDiv = document.createElement('div');
                        botDiv.className = 'flex flex-col items-center leading-none select-none transform rotate-180';
                        botDiv.innerHTML = `<span class="text-lg font-bold">${card.rank}</span><span class="text-xl">${SVG_ICONS[card.suit]}</span>`;

                        cardEl.appendChild(topDiv);
                        cardEl.appendChild(centerDiv);
                        cardEl.appendChild(botDiv);
                    }

                    // Click Handler
                    cardEl.onclick = (e) => {
                        e.stopPropagation();
                        handleCardClick(colIndex, cardIndex);
                    };

                    // Add to column
                    colEl.appendChild(cardEl);
                });

                tableauEl.appendChild(colEl);
            });
        }

        function updateScore() {
            document.getElementById('scoreDisplay').innerText = `Score: ${state.score}`;
        }

        function showMessage(msg) {
            const el = document.getElementById('messageToast');
            el.innerText = msg;
            el.style.opacity = '1';
            setTimeout(() => {
                el.style.opacity = '0';
            }, 2000);
        }

        function showHint() {
            // Simple AI to find a valid move
            let found = false;
            for (let c = 0; c < 10; c++) {
                if (state.tableau[c].length === 0) continue;
                
                // Find the starting index of the valid stack at bottom
                let stackStart = state.tableau[c].length - 1;
                while (stackStart > 0) {
                    const curr = state.tableau[c][stackStart];
                    const prev = state.tableau[c][stackStart - 1];
                    if (prev.faceUp && prev.suit === curr.suit && prev.value === curr.value + 1) {
                        stackStart--;
                    } else {
                        break;
                    }
                }

                const movingCard = state.tableau[c][stackStart];

                // Try to find target
                for (let t = 0; t < 10; t++) {
                    if (c === t) continue;
                    if (state.tableau[t].length === 0) {
                        animateHint(c, stackStart);
                        return;
                    }
                    const targetTop = state.tableau[t][state.tableau[t].length - 1];
                    if (targetTop.value === movingCard.value + 1) {
                        animateHint(c, stackStart);
                        return;
                    }
                }
            }
            
            showMessage("No moves found. Try dealing?");
        }

        function animateHint(colIdx, cardIdx) {
            // Find the element
            const tableau = document.getElementById('tableau');
            const col = tableau.children[colIdx];
            const card = col.children[cardIdx];
            
            card.classList.add('hint-anim');
            setTimeout(() => card.classList.remove('hint-anim'), 500);
        }

        // --- Simple Confetti Effect ---
        let confettiInterval;
        function startConfetti() {
            const canvas = document.getElementById('confetti-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const pieces = [];
            const colors = ['#f44336', '#2196f3', '#ffeb3b', '#4caf50', '#ff9800'];

            for(let i=0; i<200; i++) {
                pieces.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height - canvas.height,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    size: Math.random() * 10 + 5,
                    speedY: Math.random() * 5 + 2,
                    speedX: Math.random() * 2 - 1
                });
            }

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                pieces.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x, p.y, p.size, p.size);
                    p.y += p.speedY;
                    p.x += p.speedX;
                    if(p.y > canvas.height) p.y = -20;
                });
                confettiInterval = requestAnimationFrame(animate);
            }
            animate();
        }
        
        function stopConfetti() {
            if (confettiInterval) cancelAnimationFrame(confettiInterval);
            const canvas = document.getElementById('confetti-canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // Fallback for ICONS in case SVGs fail for center rendering (re-added definition)
        const ICONS = {
            spades: '♠', hearts: '♥', clubs: '♣', diamonds: '♦'
        };

        // --- Expose Globals for HTML onclick attributes ---
        // Important: Since this is a module, global functions must be attached to window manually
        window.dealStock = dealStock;
        window.toggleMenu = toggleMenu;
        window.undoMove = undoMove;
        window.showHint = showHint;
        window.startNewGame = startNewGame;
        window.confirmNewGame = confirmNewGame;
        window.handleEmptyColumnClick = handleEmptyColumnClick;

        // Start
        init();

    </script>
</body>
</html>
