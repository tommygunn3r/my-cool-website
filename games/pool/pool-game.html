<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Square Pool - Gunner's Games</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Rajdhani', sans-serif;
            background: #000;
            color: #e0e0e0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        #gameContainer {
            position: relative;
        }
        
        #gameCanvas {
            display: block;
            cursor: crosshair;
        }
        
        .hud {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            align-items: center;
            pointer-events: none;
            z-index: 10;
            background: rgba(10, 10, 20, 0.95);
            border: 2px solid rgba(76, 175, 255, 0.3);
            border-radius: 10px;
            padding: 10px 20px;
            backdrop-filter: blur(10px);
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px 10px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.05);
        }

        .player-info.active {
            background: rgba(76, 175, 255, 0.2);
            box-shadow: 0 0 10px rgba(76, 175, 255, 0.3);
        }

        .player-name {
            font-size: 0.95em;
            font-weight: 600;
        }

        .player-score {
            font-size: 0.85em;
            color: #aaa;
        }

        .game-info {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 0 15px;
            border-left: 2px solid rgba(76, 175, 255, 0.3);
            border-right: 2px solid rgba(76, 175, 255, 0.3);
        }

        .game-mode {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1em;
            font-weight: 700;
            color: #4CAF50;
        }

        .game-status {
            font-size: 0.85em;
            color: #aaa;
        }

        .settings-dropdown {
            position: relative;
            pointer-events: auto;
        }

        .settings-btn {
            background: rgba(76, 175, 255, 0.2);
            border: 2px solid rgba(76, 175, 255, 0.3);
            border-radius: 6px;
            padding: 6px 12px;
            color: #fff;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .settings-btn:hover {
            background: rgba(76, 175, 255, 0.3);
            border-color: rgba(76, 175, 255, 0.5);
        }

        .dropdown-menu {
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            background: rgba(10, 10, 20, 0.98);
            border: 2px solid rgba(76, 175, 255, 0.3);
            border-radius: 8px;
            padding: 8px;
            min-width: 180px;
            display: none;
            flex-direction: column;
            gap: 6px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
        }

        .dropdown-menu.show {
            display: flex;
        }

        .dropdown-item {
            padding: 10px 14px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(76, 175, 255, 0.2);
            border-radius: 6px;
            color: #fff;
            font-size: 0.9em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
            white-space: nowrap;
        }

        .dropdown-item:hover {
            background: rgba(76, 175, 255, 0.2);
            border-color: rgba(76, 175, 255, 0.4);
        }

        .dropdown-item.exit {
            background: rgba(255, 68, 68, 0.2);
            border-color: rgba(255, 68, 68, 0.3);
        }

        .dropdown-item.exit:hover {
            background: rgba(255, 68, 68, 0.3);
            border-color: rgba(255, 68, 68, 0.5);
        }
        
        .power-meter {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            text-align: center;
        }
        
        .power-label {
            font-size: 0.9em;
            margin-bottom: 5px;
            color: #aaa;
        }
        
        .power-bar-bg {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid rgba(76, 175, 255, 0.3);
        }
        
        .power-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #FFA500, #ff4444);
            width: 0%;
            transition: width 0.1s linear;
        }
        
        #endGameModal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 20, 0.95);
            border: 3px solid rgba(76, 175, 255, 0.8);
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            min-width: 400px;
            backdrop-filter: blur(15px);
            box-shadow: 0 0 40px rgba(76, 175, 255, 0.5);
            z-index: 100;
        }
        
        .modal-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5em;
            font-weight: 700;
            margin-bottom: 20px;
            color: #4CAF50;
            text-shadow: 0 0 20px rgba(76, 175, 255, 0.8);
        }
        
        .modal-text {
            font-size: 1.2em;
            margin-bottom: 30px;
            color: #e0e0e0;
        }
        
        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div class="hud">
            <div class="player-info" id="player1Info">
                <span class="player-name" id="player1Name">Player 1</span>
                <span class="player-score" id="player1Score">-</span>
            </div>

            <div class="game-info">
                <span class="game-mode" id="gameMode">8-BALL</span>
                <span style="color: #666;">‚Ä¢</span>
                <span class="game-status" id="gameStatus">Break Shot</span>
            </div>

            <div class="player-info" id="player2Info">
                <span class="player-name" id="player2Name">Player 2</span>
                <span class="player-score" id="player2Score">-</span>
            </div>

            <div class="settings-dropdown">
                <button class="settings-btn" id="settingsBtn">‚öôÔ∏è</button>
                <div class="dropdown-menu" id="dropdownMenu">
                    <div class="dropdown-item" id="feltBtn">Felt: Green</div>
                    <div class="dropdown-item" id="styleBtn">Style: Classic</div>
                    <div class="dropdown-item" id="aidsBtn">Aids: On</div>
                    <div class="dropdown-item exit" id="exitBtn">Exit Game</div>
                </div>
            </div>
        </div>

        <canvas id="gameCanvas"></canvas>

        <div class="power-meter" id="powerMeter" style="display: none;">
            <div class="power-label">SHOT POWER</div>
            <div class="power-bar-bg">
                <div class="power-bar-fill" id="powerBarFill"></div>
            </div>
        </div>
        
        <div id="endGameModal">
            <div class="modal-title" id="modalTitle">GAME OVER</div>
            <div class="modal-text" id="modalText">Player 1 Wins!</div>
            <div class="modal-buttons">
                <button class="btn" id="rematchBtn">Rematch</button>
                <button class="btn" id="exitModalBtn">Exit to Lobby</button>
            </div>
        </div>
    </div>
    
    <script type="module">
        import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
        const SUPABASE_URL = "https://pknhslxhpohrzgsfkisr.supabase.co";
        const SUPABASE_ANON_KEY = "sb_publishable_-zZw-pi_3q1sdNGhITKuhQ_ECyDARzc";
        window.supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        window.supabaseClient = window.supabase;
        setTimeout(() => initGame(), 100);
    </script>
    
    <script>
// ============================================
// POOL GAME - MAIN GAME LOGIC
// ============================================

const CANVAS_WIDTH = 1200;
const CANVAS_HEIGHT = 700;
const TABLE_PADDING = 100; // Increased padding for more cue stick room
const TABLE_WIDTH = 1000; // Smaller table width
const TABLE_HEIGHT = 500; // Smaller table height
const BALL_SIZE = 20;
const POCKET_RADIUS = 25;
const FRICTION = 0.985;
const BOUNCE_DAMPING = 0.8;
const MIN_VELOCITY = 0.1;
const CUE_LENGTH = 200;
const MAX_POWER = 100; // Power ranges from 0-100
const POWER_MULTIPLIER = 0.3; // Multiplier to convert power to velocity (30 max velocity at 100 power)

// Aiming aids constants
const TRAJECTORY_SIMULATION_TIME = 90; // ~1.5 seconds at 60fps
const DIAMOND_SIZE = 8;
const GHOST_BALL_OPACITY = 0.25;
const TRAJECTORY_OPACITY = 0.35;

// Pockets
const POCKETS = [
    { x: TABLE_PADDING, y: TABLE_PADDING },
    { x: CANVAS_WIDTH / 2, y: TABLE_PADDING },
    { x: CANVAS_WIDTH - TABLE_PADDING, y: TABLE_PADDING },
    { x: TABLE_PADDING, y: CANVAS_HEIGHT - TABLE_PADDING },
    { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT - TABLE_PADDING },
    { x: CANVAS_WIDTH - TABLE_PADDING, y: CANVAS_HEIGHT - TABLE_PADDING }
];

// Ball colors
const BALL_COLORS = {
    0: '#FFFFFF',  // Cue ball
    1: '#FFD700',  // Yellow
    2: '#4169E1',  // Blue
    3: '#DC143C',  // Red
    4: '#9370DB',  // Purple
    5: '#FF8C00',  // Orange
    6: '#228B22',  // Green
    7: '#8B0000',  // Maroon
    8: '#000000',  // Black (8-ball)
    9: '#FFD700',  // Yellow stripe
    10: '#4169E1', // Blue stripe
    11: '#DC143C', // Red stripe
    12: '#9370DB', // Purple stripe
    13: '#FF8C00', // Orange stripe
    14: '#228B22', // Green stripe
    15: '#8B0000'  // Maroon stripe
};

// Audio context for sound effects
let audioContext = null;

// Initialize audio on first user interaction
function initAudio() {
    if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
}

// Play stick hitting ball sound
function playCueHitSound(velocity) {
    if (!audioContext) return;

    const now = audioContext.currentTime;
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();

    // Higher velocity = lower pitch and louder
    const volume = Math.min(velocity / 30, 1) * 0.3;
    const frequency = 200 - (velocity * 2); // 200Hz down to ~140Hz for hard hits

    oscillator.type = 'sine';
    oscillator.frequency.setValueAtTime(frequency, now);
    oscillator.frequency.exponentialRampToValueAtTime(frequency * 0.5, now + 0.05);

    gainNode.gain.setValueAtTime(volume, now);
    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.08);

    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);

    oscillator.start(now);
    oscillator.stop(now + 0.08);
}

// Play ball hitting ball sound
function playBallCollisionSound(velocity) {
    if (!audioContext) return;

    const now = audioContext.currentTime;
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();

    // Volume based on collision velocity
    const volume = Math.min(velocity / 20, 1) * 0.2;
    const frequency = 300 + (velocity * 5); // Higher pitch for faster collisions

    oscillator.type = 'triangle';
    oscillator.frequency.setValueAtTime(frequency, now);
    oscillator.frequency.exponentialRampToValueAtTime(frequency * 0.7, now + 0.03);

    gainNode.gain.setValueAtTime(volume, now);
    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.05);

    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);

    oscillator.start(now);
    oscillator.stop(now + 0.05);
}

// Play ball in pocket sound
function playPocketSound() {
    if (!audioContext) return;

    const now = audioContext.currentTime;

    // Two-tone dropping sound
    const osc1 = audioContext.createOscillator();
    const osc2 = audioContext.createOscillator();
    const gainNode = audioContext.createGain();

    osc1.type = 'sine';
    osc1.frequency.setValueAtTime(400, now);
    osc1.frequency.exponentialRampToValueAtTime(200, now + 0.15);

    osc2.type = 'sine';
    osc2.frequency.setValueAtTime(600, now);
    osc2.frequency.exponentialRampToValueAtTime(300, now + 0.15);

    gainNode.gain.setValueAtTime(0.15, now);
    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

    osc1.connect(gainNode);
    osc2.connect(gainNode);
    gainNode.connect(audioContext.destination);

    osc1.start(now);
    osc2.start(now);
    osc1.stop(now + 0.15);
    osc2.stop(now + 0.15);
}

let gameState = {
    mode: '8-ball',
    currentPlayer: 1,
    player1: { name: 'Player 1', balls: [], type: null },
    player2: { name: 'Player 2', balls: [], type: null },
    isBreak: true,
    ballInHand: false,
    shooting: false,
    cueAimSet: false,
    dragStart: null,
    power: 0,
    feltColor: 'green',
    visualStyle: 'classic',
    wager: 0,
    tableId: null,
    isBot: false,
    botDifficulty: 'medium',
    foul: false,
    pocketedThisTurn: [],
    lowestBallHit: null,
    shotTaken: false,
    isPlayer1: true,  // Track if current user is player 1
    aimingAids: true  // Toggle for visual aiming aids
};

let balls = [];
let cueBall = null;
let feltImage = null;
let woodImage = null;
let woodPattern = null;
let ballTrails = [];

function setupBalls() {
    balls = [];
    ballTrails = [];

    // Cue ball - start with ball-in-hand for break
    cueBall = {
        id: 0,
        number: 0,
        x: TABLE_PADDING + TABLE_WIDTH / 4,
        y: CANVAS_HEIGHT / 2,
        vx: 0,
        vy: 0,
        pocketed: false,
        type: 'cue'
    };
    balls.push(cueBall);

    // Starting player gets ball-in-hand for break shot
    gameState.ballInHand = true;
    
    const rackX = TABLE_PADDING + (TABLE_WIDTH * 3/4);
    const rackY = CANVAS_HEIGHT / 2;
    const spacing = BALL_SIZE + 2;
    
    if (gameState.mode === '9-ball') {
        // 9-ball diamond rack (viewed from side - diamond orientation)
        // Row positions from left side of table (horizontal diamond)
        const rack = [
            [1],           // Point facing left
            [2, 3],
            [4, 9, 5],     // 9-ball in center
            [6, 7],
            [8]            // Point facing right
        ];

        let xOffset = 0;
        rack.forEach(row => {
            let yOffset = -((row.length - 1) * spacing / 2);
            row.forEach(num => {
                balls.push({
                    id: num,
                    number: num,
                    x: rackX + xOffset,
                    y: rackY + yOffset,
                    vx: 0,
                    vy: 0,
                    pocketed: false,
                    type: 'numbered'
                });
                yOffset += spacing;
            });
            xOffset += spacing * 0.866; // Move right for next column
        });
    } else {
        // 8-ball triangle rack (point facing toward breaking end)
        // 1 ball at front, 8-ball in center, alternating solids/stripes
        const rack = [
            [1],              // 1-ball at point
            [9, 2],           // stripe, solid
            [3, 8, 10],       // solid, 8-ball, stripe
            [11, 4, 5, 12],   // stripe, solid, solid, stripe
            [6, 13, 7, 14, 15] // solid, stripe, solid, stripe, stripe
        ];

        let xOffset = 0;
        rack.forEach(row => {
            let yOffset = -((row.length - 1) * spacing / 2);
            row.forEach(num => {
                balls.push({
                    id: num,
                    number: num,
                    x: rackX + xOffset,
                    y: rackY + yOffset,
                    vx: 0,
                    vy: 0,
                    pocketed: false,
                    type: num === 8 ? '8ball' : (num <= 7 ? 'solid' : 'stripe')
                });
                yOffset += spacing;
            });
            xOffset += spacing * 0.866; // Move right for next row
        });
    }
}

function ballsMoving() {
    return balls.some(b => !b.pocketed && (Math.abs(b.vx) > MIN_VELOCITY || Math.abs(b.vy) > MIN_VELOCITY));
}

function isMyTurn() {
    // For bot games: only my turn if I'm the current player
    if (gameState.isBot) {
        return gameState.currentPlayer === 1;  // Human is always player 1 in bot games
    }

    // For multiplayer: check if current player matches who I am
    return (gameState.isPlayer1 && gameState.currentPlayer === 1) ||
           (!gameState.isPlayer1 && gameState.currentPlayer === 2);
}

function shoot(startX, startY, endX, endY, power) {
    // Calculate angle from cue ball TO the aim point (reverse of cue stick direction)
    const dx = endX - startX;
    const dy = endY - startY;
    const angle = Math.atan2(dy, dx);

    // Normalize power to 0-100 range, then apply multiplier
    const normalizedPower = Math.min(Math.max(power, 0), MAX_POWER);
    const velocity = (normalizedPower / MAX_POWER) * (MAX_POWER * POWER_MULTIPLIER);

    cueBall.vx = Math.cos(angle) * velocity;
    cueBall.vy = Math.sin(angle) * velocity;

    // Play cue hit sound
    playCueHitSound(velocity);

    gameState.pocketedThisTurn = [];
    gameState.lowestBallHit = null;
    gameState.shotTaken = true;

    // Send shot to Supabase if multiplayer
    if (!gameState.isBot && window.supabaseClient) {
        sendShot({ angle, power: normalizedPower, timestamp: Date.now() });
    }
}

async function sendShot(shotData) {
    await window.supabaseClient
        .from('pool_shots')
        .insert({
            table_id: gameState.tableId,
            player_id: window.currentUser.id,
            shot_data: shotData
        });
}

function updatePhysics() {
    // Update ball positions
    balls.forEach(ball => {
        if (ball.pocketed) return;
        
        ball.x += ball.vx;
        ball.y += ball.vy;
        
        // Apply friction
        ball.vx *= FRICTION;
        ball.vy *= FRICTION;
        
        // Stop if too slow
        if (Math.abs(ball.vx) < MIN_VELOCITY) ball.vx = 0;
        if (Math.abs(ball.vy) < MIN_VELOCITY) ball.vy = 0;
        
        // Wall collisions
        const minX = TABLE_PADDING + BALL_SIZE/2;
        const maxX = CANVAS_WIDTH - TABLE_PADDING - BALL_SIZE/2;
        const minY = TABLE_PADDING + BALL_SIZE/2;
        const maxY = CANVAS_HEIGHT - TABLE_PADDING - BALL_SIZE/2;
        
        if (ball.x < minX) {
            ball.x = minX;
            ball.vx = -ball.vx * BOUNCE_DAMPING;
        }
        if (ball.x > maxX) {
            ball.x = maxX;
            ball.vx = -ball.vx * BOUNCE_DAMPING;
        }
        if (ball.y < minY) {
            ball.y = minY;
            ball.vy = -ball.vy * BOUNCE_DAMPING;
        }
        if (ball.y > maxY) {
            ball.y = maxY;
            ball.vy = -ball.vy * BOUNCE_DAMPING;
        }
        
        // Check pockets (square pockets)
        POCKETS.forEach(pocket => {
            const dx = Math.abs(ball.x - pocket.x);
            const dy = Math.abs(ball.y - pocket.y);

            if (dx < POCKET_RADIUS && dy < POCKET_RADIUS) {
                ball.pocketed = true;
                ball.vx = 0;
                ball.vy = 0;
                gameState.pocketedThisTurn.push(ball.number);
                playPocketSound();
                handleBallPocketed(ball);
            }
        });
        
        // Add trail in neon mode
        if (gameState.visualStyle === 'neon' && (Math.abs(ball.vx) > 0.5 || Math.abs(ball.vy) > 0.5)) {
            ballTrails.push({
                x: ball.x,
                y: ball.y,
                color: BALL_COLORS[ball.number],
                life: 30
            });
        }
    });
    
    // Ball-to-ball collisions
    for (let i = 0; i < balls.length; i++) {
        for (let j = i + 1; j < balls.length; j++) {
            const b1 = balls[i];
            const b2 = balls[j];
            
            if (b1.pocketed || b2.pocketed) continue;
            
            const dx = b2.x - b1.x;
            const dy = b2.y - b1.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist < BALL_SIZE) {
                // Track first ball hit by cue ball
                if (b1.number === 0 && gameState.lowestBallHit === null) {
                    gameState.lowestBallHit = b2.number;
                } else if (b2.number === 0 && gameState.lowestBallHit === null) {
                    gameState.lowestBallHit = b1.number;
                }

                // Play collision sound based on relative velocity
                const relativeVelocity = Math.sqrt(
                    Math.pow(b1.vx - b2.vx, 2) + Math.pow(b1.vy - b2.vy, 2)
                );
                playBallCollisionSound(relativeVelocity);

                // Collision response
                const angle = Math.atan2(dy, dx);
                const sin = Math.sin(angle);
                const cos = Math.cos(angle);

                // Rotate velocities
                const vx1 = b1.vx * cos + b1.vy * sin;
                const vy1 = b1.vy * cos - b1.vx * sin;
                const vx2 = b2.vx * cos + b2.vy * sin;
                const vy2 = b2.vy * cos - b2.vx * sin;

                // Swap x velocities
                const temp = vx1;
                const newVx1 = vx2;
                const newVx2 = temp;
                
                // Rotate back
                b1.vx = newVx1 * cos - vy1 * sin;
                b1.vy = vy1 * cos + newVx1 * sin;
                b2.vx = newVx2 * cos - vy2 * sin;
                b2.vy = vy2 * cos + newVx2 * sin;
                
                // Separate balls
                const overlap = BALL_SIZE - dist;
                const separateX = overlap * cos / 2;
                const separateY = overlap * sin / 2;
                b1.x -= separateX;
                b1.y -= separateY;
                b2.x += separateX;
                b2.y += separateY;
            }
        }
    }
    
    // Update trails
    ballTrails = ballTrails.filter(trail => {
        trail.life--;
        return trail.life > 0;
    });
    
    // Check if turn is over (only end once after balls stop)
    if (!ballsMoving() && !gameState.shooting && gameState.shotTaken) {
        gameState.shotTaken = false;
        setTimeout(endTurn, 500);
    }
}

function handleBallPocketed(ball) {
    if (ball.number === 0) {
        // Cue ball pocketed = scratch
        gameState.foul = true;
    } else if (gameState.mode === '8-ball') {
        const currentPlayerData = gameState.currentPlayer === 1 ? gameState.player1 : gameState.player2;
        
        if (ball.number === 8) {
            // 8-ball pocketed
            if (currentPlayerData.type && currentPlayerData.balls.length === 7) {
                // Win!
                endGame(gameState.currentPlayer);
            } else {
                // Loss!
                endGame(gameState.currentPlayer === 1 ? 2 : 1);
            }
        } else {
            // Regular ball
            // Assign type if first ball pocketed (determines groups)
            if (!currentPlayerData.type) {
                currentPlayerData.type = ball.type;
                const otherPlayer = gameState.currentPlayer === 1 ? gameState.player2 : gameState.player1;
                otherPlayer.type = ball.type === 'solid' ? 'stripe' : 'solid';
            }

            // Only add to score if it's the player's own ball type
            if (ball.type === currentPlayerData.type) {
                currentPlayerData.balls.push(ball.number);
            }
        }
    } else if (gameState.mode === '9-ball') {
        if (ball.number === 9) {
            // 9-ball pocketed = win!
            endGame(gameState.currentPlayer);
        }
    }
}

// ============================================
// AIMING AIDS HELPER FUNCTIONS
// ============================================

function simulateTrajectory(startX, startY, vx, vy, maxIterations) {
    // Simulates ball trajectory without affecting game state
    // Returns: { points: [], bounces: [], firstBallHit: null }

    const points = [];
    const bounces = [];
    let x = startX;
    let y = startY;
    let velX = vx;
    let velY = vy;
    let firstBallHit = null;

    const minX = TABLE_PADDING + BALL_SIZE/2;
    const maxX = CANVAS_WIDTH - TABLE_PADDING - BALL_SIZE/2;
    const minY = TABLE_PADDING + BALL_SIZE/2;
    const maxY = CANVAS_HEIGHT - TABLE_PADDING - BALL_SIZE/2;

    for (let i = 0; i < maxIterations; i++) {
        // Apply velocity
        x += velX;
        y += velY;

        // Apply friction
        velX *= FRICTION;
        velY *= FRICTION;

        // Stop if too slow
        if (Math.abs(velX) < MIN_VELOCITY && Math.abs(velY) < MIN_VELOCITY) {
            break;
        }

        // Wall collisions with bounce detection
        if (x < minX) {
            x = minX;
            velX = -velX * BOUNCE_DAMPING;
            bounces.push({ x, y, type: 'left' });
        }
        if (x > maxX) {
            x = maxX;
            velX = -velX * BOUNCE_DAMPING;
            bounces.push({ x, y, type: 'right' });
        }
        if (y < minY) {
            y = minY;
            velY = -velY * BOUNCE_DAMPING;
            bounces.push({ x, y, type: 'top' });
        }
        if (y > maxY) {
            y = maxY;
            velY = -velY * BOUNCE_DAMPING;
            bounces.push({ x, y, type: 'bottom' });
        }

        // Check ball-to-ball collision (first hit only)
        if (!firstBallHit) {
            for (const ball of balls) {
                if (ball.pocketed || ball.number === 0) continue;

                const dx = ball.x - x;
                const dy = ball.y - y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < BALL_SIZE) {
                    firstBallHit = ball;
                    break;
                }
            }
        }

        // Store point every few iterations to reduce data
        if (i % 2 === 0) {
            points.push({ x, y });
        }
    }

    return { points, bounces, firstBallHit };
}

function findFirstBallImpact(angle) {
    // Find the first ball that would be hit along the aim direction
    let nearestBall = null;
    let minDist = Infinity;

    for (const ball of balls) {
        if (ball.pocketed || ball.number === 0) continue;

        // Vector from cue ball to target ball
        const dx = ball.x - cueBall.x;
        const dy = ball.y - cueBall.y;
        const dist = Math.sqrt(dx*dx + dy*dy);

        // Angle to this ball
        const ballAngle = Math.atan2(dy, dx);

        // Check if ball is roughly in the aim direction (within 30 degrees)
        const angleDiff = Math.abs(ballAngle - angle);
        const normalizedDiff = Math.min(angleDiff, Math.PI * 2 - angleDiff);

        if (normalizedDiff < Math.PI / 6 && dist < minDist) {
            minDist = dist;
            nearestBall = ball;
        }
    }

    if (!nearestBall) return null;

    // Calculate exact impact point (ghost ball position)
    const dx = nearestBall.x - cueBall.x;
    const dy = nearestBall.y - cueBall.y;
    const dist = Math.sqrt(dx*dx + dy*dy);

    // Ghost ball is one ball-diameter away from target, on the line from cue to target
    const impactX = nearestBall.x - (dx / dist) * BALL_SIZE;
    const impactY = nearestBall.y - (dy / dist) * BALL_SIZE;

    return { ball: nearestBall, x: impactX, y: impactY };
}

function drawAimingAids(ctx) {
    // Calculate shot angle and velocity
    // Match the shoot() function: ball goes FROM cue ball TO drag point
    const dx = gameState.dragStart.x - cueBall.x;
    const dy = gameState.dragStart.y - cueBall.y;
    const angle = Math.atan2(dy, dx);

    const normalizedPower = Math.min(Math.max(gameState.power, 0), MAX_POWER);
    const velocity = (normalizedPower / MAX_POWER) * (MAX_POWER * POWER_MULTIPLIER);

    const velX = Math.cos(angle) * velocity;
    const velY = Math.sin(angle) * velocity;

    const isNeon = gameState.visualStyle === 'neon';

    // Simulate cue ball trajectory
    const cueBallTraj = simulateTrajectory(cueBall.x, cueBall.y, velX, velY, TRAJECTORY_SIMULATION_TIME);

    // Find ghost ball / impact point
    const impact = findFirstBallImpact(angle);

    ctx.save();

    // Draw cue ball trajectory
    if (cueBallTraj.points.length > 1) {
        ctx.globalAlpha = TRAJECTORY_OPACITY;
        ctx.strokeStyle = isNeon ? '#0FF' : '#4169E1'; // Cyan (neon) or blue (classic)
        ctx.lineWidth = isNeon ? 3 : 2;
        ctx.setLineDash([5, 5]);

        if (isNeon) {
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#0FF';
        }

        ctx.beginPath();
        ctx.moveTo(cueBall.x, cueBall.y);
        for (const point of cueBallTraj.points) {
            ctx.lineTo(point.x, point.y);
        }
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.shadowBlur = 0;
    }

    // Draw rail bounce indicators
    ctx.globalAlpha = 0.5;
    for (const bounce of cueBallTraj.bounces) {
        // Small circle at bounce point
        ctx.fillStyle = isNeon ? '#0FF' : '#FFF';
        if (isNeon) {
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#0FF';
        }
        ctx.beginPath();
        ctx.arc(bounce.x, bounce.y, isNeon ? 5 : 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Angle indicator lines (optional - simple version)
        ctx.strokeStyle = isNeon ? '#0FF' : '#FFF';
        ctx.lineWidth = 1;
        const lineLength = 20;

        // Just draw a small cross at bounce point for simplicity
        ctx.beginPath();
        ctx.moveTo(bounce.x - lineLength/2, bounce.y);
        ctx.lineTo(bounce.x + lineLength/2, bounce.y);
        ctx.moveTo(bounce.x, bounce.y - lineLength/2);
        ctx.lineTo(bounce.x, bounce.y + lineLength/2);
        ctx.stroke();
    }

    // Draw ghost ball at impact point
    if (impact) {
        ctx.globalAlpha = GHOST_BALL_OPACITY;

        // Draw ghost ball matching target ball color
        const targetBall = impact.ball;
        const isStripe = targetBall.number > 8;

        if (isNeon) {
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#0FF';
        }

        if (isStripe) {
            // Stripe ghost ball
            ctx.fillStyle = '#FFF';
            ctx.fillRect(impact.x - BALL_SIZE/2, impact.y - BALL_SIZE/2, BALL_SIZE, BALL_SIZE);

            ctx.fillStyle = BALL_COLORS[targetBall.number];
            ctx.fillRect(impact.x - BALL_SIZE/2, impact.y - BALL_SIZE/4, BALL_SIZE, BALL_SIZE/2);
        } else {
            // Solid ghost ball
            ctx.fillStyle = BALL_COLORS[targetBall.number];
            ctx.fillRect(impact.x - BALL_SIZE/2, impact.y - BALL_SIZE/2, BALL_SIZE, BALL_SIZE);
        }

        // Ghost ball outline
        ctx.globalAlpha = GHOST_BALL_OPACITY * 1.5;
        ctx.strokeStyle = isNeon ? '#0FF' : '#FFF';
        ctx.lineWidth = 2;
        ctx.strokeRect(impact.x - BALL_SIZE/2, impact.y - BALL_SIZE/2, BALL_SIZE, BALL_SIZE);

        ctx.shadowBlur = 0;

        // Draw predicted target ball trajectory after impact
        if (cueBallTraj.firstBallHit) {
            // Calculate target ball velocity after impact (simplified physics)
            const impactVelX = velX * 0.8; // Transfer ~80% momentum
            const impactVelY = velY * 0.8;

            const targetTraj = simulateTrajectory(
                targetBall.x,
                targetBall.y,
                impactVelX,
                impactVelY,
                TRAJECTORY_SIMULATION_TIME
            );

            if (targetTraj.points.length > 1) {
                ctx.globalAlpha = TRAJECTORY_OPACITY * 0.8; // Slightly more transparent
                ctx.strokeStyle = isNeon ? '#F0F' : '#FFA500'; // Magenta (neon) or orange (classic)
                ctx.lineWidth = isNeon ? 3 : 2;
                ctx.setLineDash([5, 5]);

                if (isNeon) {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#F0F';
                }

                ctx.beginPath();
                ctx.moveTo(targetBall.x, targetBall.y);
                for (const point of targetTraj.points) {
                    ctx.lineTo(point.x, point.y);
                }
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.shadowBlur = 0;
            }
        }
    }

    ctx.restore();
}

function endTurn() {
    // Check for fouls
    let keepTurn = false;

    if (gameState.foul) {
        // Foul committed - never keep turn
        gameState.ballInHand = true;
        keepTurn = false; // Explicitly set to false on foul
        if (cueBall.pocketed) {
            cueBall.pocketed = false;
            cueBall.x = TABLE_PADDING + TABLE_WIDTH / 4;
            cueBall.y = CANVAS_HEIGHT / 2;
        }
    } else if (gameState.mode === '9-ball') {
        // Check 9-ball rules
        const lowestOnTable = balls
            .filter(b => !b.pocketed && b.number > 0)
            .reduce((min, b) => b.number < min ? b.number : min, 16);
        
        if (gameState.lowestBallHit !== lowestOnTable) {
            gameState.foul = true;
            gameState.ballInHand = true;
        } else if (gameState.pocketedThisTurn.length > 0) {
            keepTurn = true;
        }
    } else if (gameState.mode === '8-ball') {
        // Check 8-ball rules
        const currentPlayerData = gameState.currentPlayer === 1 ? gameState.player1 : gameState.player2;
        
        if (currentPlayerData.type) {
            // Check if player has cleared all their balls
            const allBallsCleared = currentPlayerData.balls.length === 7;

            // Check if hit own ball first (or 8-ball if all balls are cleared)
            const hitBall = balls.find(b => b.number === gameState.lowestBallHit);
            if (hitBall) {
                if (allBallsCleared) {
                    // Must hit 8-ball when all balls are cleared
                    if (hitBall.number !== 8) {
                        gameState.foul = true;
                        gameState.ballInHand = true;
                    }
                } else {
                    // Must hit own ball type (not 8-ball or opponent's balls)
                    if (hitBall.type !== currentPlayerData.type && hitBall.number !== 8) {
                        gameState.foul = true;
                        gameState.ballInHand = true;
                    } else if (hitBall.number === 8) {
                        // Hit 8-ball too early
                        gameState.foul = true;
                        gameState.ballInHand = true;
                    }
                }
            }

            if (gameState.pocketedThisTurn.length > 0 && !gameState.foul) {
                // Check if pocketed own ball (or 8-ball if all balls cleared)
                const pocketedOwn = gameState.pocketedThisTurn.some(num => {
                    const ball = balls.find(b => b.number === num);
                    return ball && (ball.type === currentPlayerData.type || (allBallsCleared && ball.number === 8));
                });
                if (pocketedOwn) {
                    keepTurn = true;
                }
            }
        } else if (gameState.pocketedThisTurn.length > 0 && !gameState.pocketedThisTurn.includes(8)) {
            keepTurn = true;
        }
    }
    
    gameState.isBreak = false;

    // Switch players if not keeping turn
    if (!keepTurn) {
        gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;
        updatePlayerIndicators();

        // Bot turn
        if (gameState.isBot && gameState.currentPlayer === 2) {
            setTimeout(botTurn, 1500);
        }
    } else {
        // Keeping turn - if it's the bot's turn, trigger another bot shot
        if (gameState.isBot && gameState.currentPlayer === 2) {
            setTimeout(botTurn, 1500);
        }
    }

    gameState.foul = false;
    gameState.pocketedThisTurn = [];
    gameState.lowestBallHit = null;

    updateGameStatus();

    // Save game state for multiplayer sync
    saveGameState();
}

// ============================================
// BOT AI
// ============================================

function botTurn() {
    console.log('ü§ñ Bot turn called', {
        currentPlayer: gameState.currentPlayer,
        ballInHand: gameState.ballInHand,
        ballsMoving: ballsMoving(),
        cueBallPocketed: cueBall?.pocketed
    });

    // Only proceed if it's actually player 2's turn
    if (gameState.currentPlayer !== 2) {
        console.log('‚ùå Not bot\'s turn!');
        return;
    }

    if (ballsMoving()) {
        console.log('‚è≥ Balls still moving, waiting...');
        setTimeout(botTurn, 100);
        return;
    }

    if (gameState.ballInHand) {
        console.log('üìç Bot placing cue ball at break position');
        // Place cue ball
        const safeX = TABLE_PADDING + TABLE_WIDTH / 4;
        const safeY = CANVAS_HEIGHT / 2;
        cueBall.x = safeX;
        cueBall.y = safeY;
        cueBall.pocketed = false;
        gameState.ballInHand = false;
        console.log('‚úÖ Bot placed ball, scheduling next turn in 500ms');
        updateGameStatus();
        setTimeout(botTurn, 500);
        return;
    }

    // Find target ball
    let targetBall = null;
    
    if (gameState.mode === '9-ball') {
        // Target lowest numbered ball
        targetBall = balls
            .filter(b => !b.pocketed && b.number > 0)
            .reduce((lowest, b) => (!lowest || b.number < lowest.number) ? b : lowest, null);
    } else if (gameState.mode === '8-ball') {
        const playerType = gameState.player2.type;
        if (playerType) {
            // Check if all own balls are pocketed
            if (gameState.player2.balls.length === 7) {
                // Target the 8-ball!
                targetBall = balls.find(b => !b.pocketed && b.number === 8);
            } else {
                // Target own balls
                targetBall = balls
                    .filter(b => !b.pocketed && b.type === playerType)
                    .sort(() => Math.random() - 0.5)[0];
            }
        } else {
            // First shot, target any ball
            targetBall = balls
                .filter(b => !b.pocketed && b.number > 0 && b.number !== 8)
                .sort(() => Math.random() - 0.5)[0];
        }
    }
    
    if (!targetBall) return;
    
    // Calculate shot
    const dx = targetBall.x - cueBall.x;
    const dy = targetBall.y - cueBall.y;
    let angle = Math.atan2(dy, dx);
    
    // Add randomness based on difficulty
    let angleError = 0;
    let powerMult = 1;
    
    if (gameState.botDifficulty === 'easy') {
        angleError = (Math.random() - 0.5) * 0.5; // ¬±30 degrees
        powerMult = 0.6 + Math.random() * 0.4; // 60-100%
    } else if (gameState.botDifficulty === 'medium') {
        angleError = (Math.random() - 0.5) * 0.2; // ¬±12 degrees  
        powerMult = 0.7 + Math.random() * 0.3; // 70-100%
    } else {
        angleError = (Math.random() - 0.5) * 0.1; // ¬±6 degrees
        powerMult = 0.8 + Math.random() * 0.2; // 80-100%
    }
    
    angle += angleError;

    const distance = Math.sqrt(dx*dx + dy*dy);
    // Bot calculates power based on distance (closer = less power)
    const basePower = Math.min((distance / TABLE_WIDTH) * 100, 80); // Max 80% power for bot
    const power = basePower * powerMult;

    // Execute shot using same system as player
    const normalizedPower = Math.min(Math.max(power, 0), MAX_POWER);
    const velocity = (normalizedPower / MAX_POWER) * (MAX_POWER * POWER_MULTIPLIER);

    console.log(`üé± Bot shooting! Power: ${normalizedPower.toFixed(1)}, Velocity: ${velocity.toFixed(1)}`);

    cueBall.vx = Math.cos(angle) * velocity;
    cueBall.vy = Math.sin(angle) * velocity;

    // Play cue hit sound
    playCueHitSound(velocity);

    gameState.pocketedThisTurn = [];
    gameState.lowestBallHit = null;
    gameState.shotTaken = true;
}

// ============================================
// RENDERING
// ============================================

function render(ctx) {
    // Clear canvas
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    // Draw table
    drawTable(ctx);
    
    // Draw trails (neon mode)
    if (gameState.visualStyle === 'neon') {
        ballTrails.forEach(trail => {
            const alpha = trail.life / 30;
            ctx.fillStyle = trail.color + Math.floor(alpha * 128).toString(16).padStart(2, '0');
            ctx.fillRect(trail.x - 2, trail.y - 2, 4, 4);
        });
    }
    
    // Draw aiming aids (before cue stick)
    if (gameState.aimingAids && gameState.shooting && gameState.dragStart && !cueBall.pocketed) {
        drawAimingAids(ctx);
    }

    // Draw cue stick (during shooting)
    if (gameState.shooting && gameState.dragStart && !cueBall.pocketed) {
        drawCueStick(ctx);
    }
    
    // Draw balls
    balls.forEach(ball => {
        if (!ball.pocketed) {
            drawBall(ctx, ball);
        }
    });
    
    // Ball in hand indicator
    if (gameState.ballInHand && isMyTurn()) {
        ctx.save();
        ctx.globalAlpha = 0.5;
        ctx.strokeStyle = gameState.visualStyle === 'neon' ? '#0FF' : '#FFF';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.strokeRect(cueBall.x - BALL_SIZE/2, cueBall.y - BALL_SIZE/2, BALL_SIZE, BALL_SIZE);
        ctx.restore();
    }
}

function drawTable(ctx) {
    // Wood border/frame with tileable pattern
    if (woodPattern) {
        // Use tileable wood pattern
        ctx.fillStyle = woodPattern;
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    } else {
        // Fallback solid wood color
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    }

    // Felt
    if (feltImage && feltImage.complete) {
        ctx.drawImage(feltImage, TABLE_PADDING, TABLE_PADDING, TABLE_WIDTH, TABLE_HEIGHT);
    } else {
        // Fallback colors
        const feltColors = { green: '#1a4d2e', blue: '#1a3d5c', red: '#4d1a1a' };
        ctx.fillStyle = feltColors[gameState.feltColor] || feltColors.green;
        ctx.fillRect(TABLE_PADDING, TABLE_PADDING, TABLE_WIDTH, TABLE_HEIGHT);
    }
    
    // Table border/rails
    if (gameState.visualStyle === 'neon') {
        ctx.strokeStyle = '#0FF';
        ctx.lineWidth = 4;
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#0FF';
    } else {
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 2;
    }
    ctx.strokeRect(TABLE_PADDING, TABLE_PADDING, TABLE_WIDTH, TABLE_HEIGHT);
    ctx.shadowBlur = 0;

    // Diamond markers (rail sights)
    const isNeon = gameState.visualStyle === 'neon';
    const diamondColor = isNeon ? '#0FF' : '#FFF';
    const diamondOffset = 15; // Distance from felt edge

    ctx.save();
    ctx.fillStyle = diamondColor;
    if (isNeon) {
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#0FF';
    }

    // Top rail diamonds (3 diamonds at 25%, 50%, 75%)
    for (let i = 1; i <= 3; i++) {
        const x = TABLE_PADDING + (TABLE_WIDTH * i / 4);
        const y = TABLE_PADDING - diamondOffset;
        drawDiamond(ctx, x, y, DIAMOND_SIZE);
    }

    // Bottom rail diamonds (3 diamonds at 25%, 50%, 75%)
    for (let i = 1; i <= 3; i++) {
        const x = TABLE_PADDING + (TABLE_WIDTH * i / 4);
        const y = TABLE_PADDING + TABLE_HEIGHT + diamondOffset;
        drawDiamond(ctx, x, y, DIAMOND_SIZE);
    }

    // Left rail diamonds (2 diamonds at 33%, 67%)
    for (let i = 1; i <= 2; i++) {
        const x = TABLE_PADDING - diamondOffset;
        const y = TABLE_PADDING + (TABLE_HEIGHT * i / 3);
        drawDiamond(ctx, x, y, DIAMOND_SIZE);
    }

    // Right rail diamonds (2 diamonds at 33%, 67%)
    for (let i = 1; i <= 2; i++) {
        const x = TABLE_PADDING + TABLE_WIDTH + diamondOffset;
        const y = TABLE_PADDING + (TABLE_HEIGHT * i / 3);
        drawDiamond(ctx, x, y, DIAMOND_SIZE);
    }

    ctx.restore();

    // Pockets (square)
    POCKETS.forEach(pocket => {
        const pocketSize = POCKET_RADIUS * 2;
        const px = pocket.x - POCKET_RADIUS;
        const py = pocket.y - POCKET_RADIUS;

        if (gameState.visualStyle === 'neon') {
            ctx.fillStyle = '#000';
            ctx.shadowBlur = 30;
            ctx.shadowColor = '#F0F';
            ctx.fillRect(px, py, pocketSize, pocketSize);

            ctx.strokeStyle = '#F0F';
            ctx.lineWidth = 2;
            ctx.strokeRect(px, py, pocketSize, pocketSize);
            ctx.shadowBlur = 0;
        } else {
            ctx.fillStyle = '#000';
            ctx.fillRect(px, py, pocketSize, pocketSize);

            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.strokeRect(px, py, pocketSize, pocketSize);
        }
    });
}

function drawDiamond(ctx, x, y, size) {
    // Draw a diamond shape (rotated square)
    ctx.beginPath();
    ctx.moveTo(x, y - size/2);           // Top point
    ctx.lineTo(x + size/2, y);           // Right point
    ctx.lineTo(x, y + size/2);           // Bottom point
    ctx.lineTo(x - size/2, y);           // Left point
    ctx.closePath();
    ctx.fill();
}

function drawBall(ctx, ball) {
    const isNeon = gameState.visualStyle === 'neon';
    
    ctx.save();
    
    if (isNeon) {
        ctx.shadowBlur = 20;
        ctx.shadowColor = BALL_COLORS[ball.number];
    }
    
    // Draw square ball
    if (ball.number === 0) {
        // Cue ball (white)
        ctx.fillStyle = isNeon ? '#FFF' : '#F5F5F5';
        ctx.fillRect(ball.x - BALL_SIZE/2, ball.y - BALL_SIZE/2, BALL_SIZE, BALL_SIZE);
        
        if (isNeon) {
            ctx.strokeStyle = '#0FF';
            ctx.lineWidth = 2;
        } else {
            ctx.strokeStyle = '#DDD';
            ctx.lineWidth = 1;
        }
        ctx.strokeRect(ball.x - BALL_SIZE/2, ball.y - BALL_SIZE/2, BALL_SIZE, BALL_SIZE);
    } else {
        // Numbered ball
        const isStripe = ball.number > 8;
        
        if (isStripe) {
            // Stripe ball
            ctx.fillStyle = '#FFF';
            ctx.fillRect(ball.x - BALL_SIZE/2, ball.y - BALL_SIZE/2, BALL_SIZE, BALL_SIZE);
            
            ctx.fillStyle = BALL_COLORS[ball.number];
            ctx.fillRect(ball.x - BALL_SIZE/2, ball.y - BALL_SIZE/4, BALL_SIZE, BALL_SIZE/2);
        } else {
            // Solid ball
            ctx.fillStyle = BALL_COLORS[ball.number];
            ctx.fillRect(ball.x - BALL_SIZE/2, ball.y - BALL_SIZE/2, BALL_SIZE, BALL_SIZE);
        }
        
        if (isNeon) {
            ctx.strokeStyle = BALL_COLORS[ball.number];
            ctx.lineWidth = 2;
        } else {
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
        }
        ctx.strokeRect(ball.x - BALL_SIZE/2, ball.y - BALL_SIZE/2, BALL_SIZE, BALL_SIZE);
        
        // Number
        ctx.fillStyle = isStripe ? '#000' : '#FFF';
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(ball.number, ball.x, ball.y);
    }
    
    ctx.restore();
}

function drawCueStick(ctx) {
    const dx = gameState.dragStart.x - cueBall.x;
    const dy = gameState.dragStart.y - cueBall.y;
    const angle = Math.atan2(dy, dx);

    // Calculate cue stick position
    let pullback = 10; // Default gap from ball
    if (gameState.shooting && gameState.cueAimSet) {
        // During power phase, pull back based on power
        pullback = 10 + (gameState.power * 1.5);
    }

    const cueStartX = cueBall.x + Math.cos(angle) * (BALL_SIZE/2 + pullback);
    const cueStartY = cueBall.y + Math.sin(angle) * (BALL_SIZE/2 + pullback);
    const cueEndX = cueStartX + Math.cos(angle) * CUE_LENGTH;
    const cueEndY = cueStartY + Math.sin(angle) * CUE_LENGTH;

    // Draw cue stick
    if (gameState.visualStyle === 'neon') {
        // Neon style cue
        ctx.strokeStyle = '#0FF';
        ctx.lineWidth = 5;
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#0FF';
    } else {
        // Realistic wood cue
        const gradient = ctx.createLinearGradient(cueStartX, cueStartY, cueEndX, cueEndY);
        gradient.addColorStop(0, '#D2691E'); // Lighter brown at tip
        gradient.addColorStop(0.3, '#8B4513'); // Dark brown
        gradient.addColorStop(0.7, '#A0522D'); // Medium brown
        gradient.addColorStop(1, '#654321'); // Dark at handle

        ctx.strokeStyle = gradient;
        ctx.lineWidth = 8;
        ctx.lineCap = 'round';
    }

    ctx.beginPath();
    ctx.moveTo(cueStartX, cueStartY);
    ctx.lineTo(cueEndX, cueEndY);
    ctx.stroke();
    ctx.shadowBlur = 0;

    // Draw cue tip (darker)
    ctx.fillStyle = gameState.visualStyle === 'neon' ? '#0FF' : '#654321';
    ctx.beginPath();
    ctx.arc(cueStartX, cueStartY, 4, 0, Math.PI * 2);
    ctx.fill();

    // Aiming line from cue ball
    if (gameState.visualStyle === 'neon') {
        ctx.strokeStyle = '#0FF6';
    } else {
        ctx.strokeStyle = '#FFF5';
    }
    ctx.lineWidth = 2;
    ctx.setLineDash([10, 10]);

    const aimLength = 400;
    const aimStartX = cueBall.x - Math.cos(angle) * (BALL_SIZE/2);
    const aimStartY = cueBall.y - Math.sin(angle) * (BALL_SIZE/2);
    const aimEndX = aimStartX - Math.cos(angle) * aimLength;
    const aimEndY = aimStartY - Math.sin(angle) * aimLength;

    ctx.beginPath();
    ctx.moveTo(aimStartX, aimStartY);
    ctx.lineTo(aimEndX, aimEndY);
    ctx.stroke();
    ctx.setLineDash([]);
}


// ============================================
// UI FUNCTIONS
// ============================================

function updateGameStatus() {
    const statusEl = document.getElementById('gameStatus');
    if (gameState.ballInHand) {
        statusEl.textContent = 'Ball in Hand - Click to Place';
    } else if (gameState.isBreak) {
        statusEl.textContent = 'Break Shot';
    } else {
        statusEl.textContent = isMyTurn() ? 'Your Turn' : 'Opponent\'s Turn';
    }
}

function updatePlayerIndicators() {
    document.getElementById('player1Info').classList.toggle('active', gameState.currentPlayer === 1);
    document.getElementById('player2Info').classList.toggle('active', gameState.currentPlayer === 2);

    // Update scores
    if (gameState.mode === '8-ball') {
        const p1Type = gameState.player1.type;
        const p2Type = gameState.player2.type;

        if (p1Type === 'solid') {
            document.getElementById('player1Score').textContent = `‚óèSOLIDS: ${gameState.player1.balls.length}/7`;
        } else if (p1Type === 'stripe') {
            document.getElementById('player1Score').textContent = `‚óêSTRIPES: ${gameState.player1.balls.length}/7`;
        } else {
            document.getElementById('player1Score').textContent = '?: 0/7';
        }

        if (p2Type === 'solid') {
            document.getElementById('player2Score').textContent = `‚óèSOLIDS: ${gameState.player2.balls.length}/7`;
        } else if (p2Type === 'stripe') {
            document.getElementById('player2Score').textContent = `‚óêSTRIPES: ${gameState.player2.balls.length}/7`;
        } else {
            document.getElementById('player2Score').textContent = '?: 0/7';
        }
    } else {
        const remaining = 9 - balls.filter(b => b.pocketed && b.number > 0).length;
        document.getElementById('player1Score').textContent = `${remaining} left`;
        document.getElementById('player2Score').textContent = `${remaining} left`;
    }
}

function toggleDropdown(e) {
    e.stopPropagation();
    document.getElementById('dropdownMenu').classList.toggle('show');
}

function cycleFelt() {
    const felts = ['green', 'blue', 'red'];
    const currentIndex = felts.indexOf(gameState.feltColor);
    gameState.feltColor = felts[(currentIndex + 1) % felts.length];
    document.getElementById('feltBtn').textContent =
        `Felt: ${gameState.feltColor.charAt(0).toUpperCase() + gameState.feltColor.slice(1)}`;
    loadFeltImage();
}

function cycleStyle() {
    gameState.visualStyle = gameState.visualStyle === 'classic' ? 'neon' : 'classic';
    document.getElementById('styleBtn').textContent =
        `Style: ${gameState.visualStyle.charAt(0).toUpperCase() + gameState.visualStyle.slice(1)}`;
}

function toggleAimingAids() {
    gameState.aimingAids = !gameState.aimingAids;
    document.getElementById('aidsBtn').textContent =
        `Aids: ${gameState.aimingAids ? 'On' : 'Off'}`;
}

function loadFeltImage() {
    feltImage = new Image();
    feltImage.src = `/games/assets/pool/${gameState.feltColor}top.png`;
}

function loadWoodImage() {
    woodImage = new Image();
    woodImage.src = `/games/assets/pool/wood.png`;

    // Create pattern once image loads
    woodImage.onload = function() {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        woodPattern = tempCtx.createPattern(woodImage, 'repeat');
    };
}

async function endGame(winner) {
    const winnerName = winner === 1 ? gameState.player1.name : gameState.player2.name;
    document.getElementById('modalTitle').textContent = winnerName + ' WINS!';

    let modalText = '';
    if (gameState.wager > 0) {
        const pot = gameState.wager * 2;
        modalText = `Winnings: ${pot} GunnerCoins`;

        // Award coins if you won
        if ((winner === 1 && !gameState.isBot) || (winner === 2 && gameState.isBot)) {
            awardCoins(pot);
        }
    }
    document.getElementById('modalText').textContent = modalText;
    document.getElementById('endGameModal').style.display = 'block';

    // Clean up table in database
    if (window.supabaseClient && gameState.tableId) {
        await window.supabaseClient
            .from('pool_tables')
            .update({
                player1_id: null,
                player1_name: null,
                player1_ready: false,
                player1_paid: false,
                player2_id: null,
                player2_name: null,
                player2_ready: false,
                player2_paid: false,
                status: 'waiting',
                wager: 0,
                game_state: {}
            })
            .eq('id', gameState.tableId);
    }
}

async function awardCoins(amount) {
    if (!window.supabaseClient || !window.currentUser) return;
    
    const { data: profile } = await window.supabaseClient
        .from('profiles')
        .select('gunnercoins')
        .eq('id', window.currentUser.id)
        .single();
    
    if (profile) {
        await window.supabaseClient
            .from('profiles')
            .update({ gunnercoins: (profile.gunnercoins || 0) + amount })
            .eq('id', window.currentUser.id);
    }
}

function rematch() {
    document.getElementById('endGameModal').style.display = 'none';
    setupBalls();
    gameState.isBreak = true;
    gameState.currentPlayer = 1;
    gameState.player1.balls = [];
    gameState.player2.balls = [];
    gameState.player1.type = null;
    gameState.player2.type = null;
    updatePlayerIndicators();
    updateGameStatus();
}

async function exitGame() {
    // Clean up the table in the database
    if (window.supabaseClient && gameState.tableId) {
        try {
            await window.supabaseClient
                .from('pool_tables')
                .update({
                    player1_id: null,
                    player1_name: null,
                    player1_ready: false,
                    player1_paid: false,
                    player2_id: null,
                    player2_name: null,
                    player2_ready: false,
                    player2_paid: false,
                    status: 'waiting',
                    wager: 0,
                    game_state: {}
                })
                .eq('id', gameState.tableId);

            console.log('Table cleaned up successfully');
        } catch (error) {
            console.error('Error cleaning up table:', error);
        }
    }

    window.location.href = '/pool-hall.html';
}

// ============================================
// EVENT HANDLERS
// ============================================

function onMouseDown(e) {
    // Initialize audio on first user interaction
    initAudio();

    if (ballsMoving()) return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (gameState.ballInHand) {
        // Only allow player to place ball on their own turn
        if (isMyTurn() && canPlaceCueBall(x, y)) {
            cueBall.x = x;
            cueBall.y = y;
            cueBall.pocketed = false;
            gameState.ballInHand = false;
            updateGameStatus();
        }
    } else if (!gameState.shooting && isMyTurn()) {
        // First click: enter aiming mode
        gameState.shooting = true;
        gameState.cueAimSet = true;
        gameState.dragStart = { x, y }; // This will update as mouse moves
        document.getElementById('powerMeter').style.display = 'block';
    } else if (gameState.shooting && gameState.cueAimSet && isMyTurn()) {
        // Second click: execute shot with current power
        shoot(gameState.dragStart.x, gameState.dragStart.y, cueBall.x, cueBall.y, gameState.power);

        gameState.shooting = false;
        gameState.cueAimSet = false;
        gameState.dragStart = null;
        gameState.power = 0;
        document.getElementById('powerMeter').style.display = 'none';
        document.getElementById('powerBarFill').style.width = '0%';
    }
}

function onMouseMove(e) {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (gameState.shooting && gameState.cueAimSet) {
        // Update aim direction - mouse position sets where the cue stick points
        gameState.dragStart.x = x;
        gameState.dragStart.y = y;

        // Calculate power based on mouse distance from cue ball
        // The further the mouse is from the cue ball, the more power
        const dx = x - cueBall.x;
        const dy = y - cueBall.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Scale distance to 0-100 range (200 pixels = max power)
        gameState.power = Math.min((distance / 200) * MAX_POWER, MAX_POWER);
        document.getElementById('powerBarFill').style.width = gameState.power + '%';
    }
}

function onMouseUp(e) {
    // No longer needed - all click handling is in onMouseDown
}

function onRightClick(e) {
    e.preventDefault(); // Prevent context menu from appearing

    // Right-click cancels aiming/shooting and lets you reposition
    if (gameState.shooting && gameState.cueAimSet) {
        gameState.shooting = false;
        gameState.cueAimSet = false;
        gameState.dragStart = null;
        gameState.power = 0;
        document.getElementById('powerMeter').style.display = 'none';
        document.getElementById('powerBarFill').style.width = '0%';
    }
}

function canPlaceCueBall(x, y) {
    const minX = TABLE_PADDING + BALL_SIZE/2;
    const minY = TABLE_PADDING + BALL_SIZE/2;
    const maxY = CANVAS_HEIGHT - TABLE_PADDING - BALL_SIZE/2;

    // Limit to break side (left quarter of table)
    const maxX = TABLE_PADDING + (TABLE_WIDTH / 4);

    if (x < minX || x > maxX || y < minY || y > maxY) return false;

    // Check if overlapping with other balls
    for (const ball of balls) {
        if (ball.pocketed || ball.number === 0) continue;
        const dx = x - ball.x;
        const dy = y - ball.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < BALL_SIZE) return false;
    }

    return true;
}

// ============================================
// SHOT SYNC (Multiplayer)
// ============================================

function subscribeToShots() {
    if (!window.supabaseClient || gameState.isBot) return;

    shotSubscription = window.supabaseClient
        .channel('pool_shots')
        .on('postgres_changes',
            { event: 'INSERT', schema: 'public', table: 'pool_shots', filter: `table_id=eq.${gameState.tableId}` },
            (payload) => {
                const shotData = payload.new.shot_data;
                if (payload.new.player_id !== window.currentUser.id) {
                    // Opponent's shot - use same power calculation
                    const normalizedPower = Math.min(Math.max(shotData.power, 0), MAX_POWER);
                    const velocity = (normalizedPower / MAX_POWER) * (MAX_POWER * POWER_MULTIPLIER);

                    cueBall.vx = Math.cos(shotData.angle) * velocity;
                    cueBall.vy = Math.sin(shotData.angle) * velocity;
                    gameState.pocketedThisTurn = [];
                    gameState.lowestBallHit = null;
                    gameState.shotTaken = true;
                }
            }
        )
        .subscribe();
}

function subscribeToGameState() {
    if (!window.supabaseClient || gameState.isBot) return;

    // Subscribe to game_state changes on the pool_tables table
    const gameStateChannel = window.supabaseClient
        .channel('game_state_changes')
        .on('postgres_changes',
            { event: 'UPDATE', schema: 'public', table: 'pool_tables', filter: `id=eq.${gameState.tableId}` },
            async (payload) => {
                // Only load if we're not currently in the middle of a shot
                if (!gameState.shooting && !ballsMoving() && payload.new.game_state) {
                    console.log('üì• Received game state update from opponent');
                    loadGameState(payload.new.game_state);
                    updatePlayerIndicators();
                    updateGameStatus();
                }
            }
        )
        .subscribe();
}

function loadGameState(state) {
    // Load game state from database (for rejoining games)
    if (state.balls) {
        balls.forEach((ball, i) => {
            if (state.balls[i]) {
                ball.x = state.balls[i].x;
                ball.y = state.balls[i].y;
                ball.pocketed = state.balls[i].pocketed;
            }
        });
    }
    if (state.currentPlayer) gameState.currentPlayer = state.currentPlayer;
    if (state.player1) Object.assign(gameState.player1, state.player1);
    if (state.player2) Object.assign(gameState.player2, state.player2);
}

async function saveGameState() {
    // Save current game state to database for multiplayer sync
    if (gameState.isBot) return; // Don't save bot games

    const state = {
        balls: balls.map(b => ({ x: b.x, y: b.y, pocketed: b.pocketed })),
        currentPlayer: gameState.currentPlayer,
        player1: {
            type: gameState.player1.type,
            balls: gameState.player1.balls
        },
        player2: {
            type: gameState.player2.type,
            balls: gameState.player2.balls
        }
    };

    const { error } = await window.supabase
        .from('pool_tables')
        .update({ game_state: state })
        .eq('id', gameState.tableId);

    if (error) {
        console.error('Failed to save game state:', error);
    }
}

// ============================================
// GAME LOOP
// ============================================

let canvas, ctx;

async function initGame() {
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d');
    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;
    
    const urlParams = new URLSearchParams(window.location.search);
    gameState.tableId = parseInt(urlParams.get('table'));
    
    if (!gameState.tableId) {
        alert('No table ID provided!');
        window.location.href = '/pool-hall.html';
        return;
    }
    
    if (!window.supabase) {
        console.error('Supabase not loaded');
        return;
    }
    
    const { data: { user } } = await window.supabase.auth.getUser();
    if (!user) {
        alert('Please log in!');
        window.location.href = '/login.html';
        return;
    }
    window.currentUser = user;

    const { hasState, savedState } = await loadTableData();

    // Always setup balls to create the ball objects
    setupBalls();

    // If existing state exists, load positions after balls are created
    if (hasState && savedState) {
        loadGameState(savedState);
        console.log('‚úÖ Loaded existing game state');
    } else {
        // New game - save initial ball positions for multiplayer sync
        await saveGameState();
        console.log('‚úÖ Created new game state');
    }

    loadFeltImage();
    loadWoodImage();
    
    canvas.addEventListener('mousedown', onMouseDown);
    canvas.addEventListener('mousemove', onMouseMove);
    canvas.addEventListener('mouseup', onMouseUp);
    canvas.addEventListener('contextmenu', onRightClick);

    // Settings dropdown
    document.getElementById('settingsBtn').addEventListener('click', toggleDropdown);
    document.getElementById('feltBtn').addEventListener('click', cycleFelt);
    document.getElementById('styleBtn').addEventListener('click', cycleStyle);
    document.getElementById('aidsBtn').addEventListener('click', toggleAimingAids);
    document.getElementById('exitBtn').addEventListener('click', exitGame);
    document.getElementById('rematchBtn').addEventListener('click', rematch);
    document.getElementById('exitModalBtn').addEventListener('click', exitGame);

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
        if (!e.target.closest('.settings-dropdown')) {
            document.getElementById('dropdownMenu').classList.remove('show');
        }
    });
    
    subscribeToShots();
    subscribeToGameState();
    updatePlayerIndicators();
    updateGameStatus();

    gameLoop();

    // Debug log
    console.log('üéÆ Game initialized', {
        isBot: gameState.isBot,
        currentPlayer: gameState.currentPlayer,
        ballInHand: gameState.ballInHand,
        willTriggerBot: gameState.isBot && gameState.currentPlayer === 2
    });

    // Trigger bot turn after everything is initialized
    if (gameState.isBot && gameState.currentPlayer === 2) {
        console.log('‚è∞ Scheduling bot turn in 2 seconds...');
        setTimeout(botTurn, 2000);
    } else if (gameState.isBot) {
        console.log('üë§ Human player breaks first (Player 1)');
    }
}

async function loadTableData() {
    const { data: table, error } = await window.supabase
        .from('pool_tables')
        .select('*')
        .eq('id', gameState.tableId)
        .single();

    if (error || !table) {
        alert('Failed to load table data');
        window.location.href = '/pool-hall.html';
        return { hasState: false, savedState: null };
    }

    gameState.mode = table.game_type;
    document.getElementById('gameMode').textContent =
        table.game_type === '8-ball' ? '8-BALL' : '9-BALL';

    gameState.player1.name = table.player1_name || 'Player 1';
    gameState.player2.name = table.player2_name || 'Player 2';
    document.getElementById('player1Name').textContent = gameState.player1.name;
    document.getElementById('player2Name').textContent = gameState.player2.name;

    if (table.player2_name && table.player2_name.includes('(Bot)')) {
        gameState.isBot = true;
        const diffMatch = table.player2_name.match(/\((.*?)\)/);
        gameState.botDifficulty = diffMatch ? diffMatch[1].toLowerCase() : 'medium';
    }

    gameState.wager = table.wager || 0;

    const isPlayer1 = table.player1_id === window.currentUser.id;
    gameState.isPlayer1 = isPlayer1;

    // Coin flip to determine who goes first (use table ID for deterministic result across clients)
    const coinFlip = (gameState.tableId % 2) + 1; // tableId mod 2 gives 0 or 1, add 1 to get 1 or 2
    gameState.currentPlayer = coinFlip;

    console.log(`ü™ô Coin flip: Player ${coinFlip} breaks first!`);

    // Return the saved state to be applied AFTER balls are created
    if (table.game_state && Object.keys(table.game_state).length > 0) {
        return { hasState: true, savedState: table.game_state };
    }

    return { hasState: false, savedState: null };
}

function gameLoop() {
    updatePhysics();
    render(ctx);
    requestAnimationFrame(gameLoop);
}

    </script>
</body>
</html>