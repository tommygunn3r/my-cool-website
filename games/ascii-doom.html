<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASCII DOOM</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: #0f0;
            font-family: monospace;
            overflow: hidden;
            cursor: crosshair;
        }
        #game-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
        }
        #game-screen {
            background-color: #000;
            color: #0f0;
            font-size: 14px;
            line-height: 14px;
            white-space: pre;
            margin: 0;
            padding: 0;
            user-select: none;
            overflow: hidden;
        }
        
        /* Color classes for different elements */
        .enemy-color { color: #ff0000; } /* BRIGHT RED for easy visibility */
        .wall-color { color: #00ff00; }
        .item-color { color: #ffff00; }
        .weapon-color { color: #00ffff; }
        #hud {
            position: fixed;
            bottom: 20px;
            left: 20px;
            font-size: 18px;
            color: #f00;
            user-select: none;
            text-shadow: 0 0 5px #000;
        }
        #enemy-radar {
            position: fixed;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            width: 150px;
            height: 150px;
            background-color: rgba(0, 50, 0, 0.7);
            border: 2px solid #0f0;
            border-radius: 50%;
            z-index: 1000;
        }
        
        .radar-blip {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: #f00;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        
        .radar-player {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #0f0;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .radar-direction {
            position: absolute;
            width: 2px;
            height: 40px;
            background-color: rgba(0, 255, 0, 0.7);
            top: 50%;
            left: 50%;
            transform-origin: center bottom;
        }
        #start-screen, #game-over-screen, #level-complete-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            color: #0f0;
            font-size: 24px;
            text-align: center;
            z-index: 100;
        }
        .button {
            margin-top: 20px;
            padding: 10px 20px;
            background-color: #333;
            color: #0f0;
            border: 2px solid #0f0;
            cursor: pointer;
            font-family: monospace;
            font-size: 18px;
        }
        .button:hover {
            background-color: #0f0;
            color: #000;
        }
        #weapon-display {
            position: fixed;
            bottom: 20px;
            right: 20px;
            font-size: 18px;
            color: #f00;
            user-select: none;
            text-shadow: 0 0 5px #000;
        }
        #message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #f00;
            font-size: 24px;
            text-align: center;
            text-shadow: 0 0 5px #000;
            opacity: 0;
            transition: opacity 0.5s;
        }
        #minimap {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 1px solid #0f0;
            padding: 5px;
            font-size: 10px;
            line-height: 10px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <pre id="game-screen"></pre>
        <div id="hud">Health: 100 | Ammo: 50 | Enemies: 0 | Level: 1</div>
        <div id="weapon-display">Weapon: Pistol</div>
        <div id="crosshair">⊕</div>
        <div id="message"></div>
        <pre id="minimap"></pre>
        <div id="enemy-radar" style="display: none;">
            <div class="radar-player"></div>
            <div class="radar-direction"></div>
        </div>
    </div>

    <div id="start-screen">
        <pre>
    _    ____   ____ ___ ___    ____   ___   ___  __  __ 
   / \  / ___| / ___|_ _|_ _|  |  _ \ / _ \ / _ \|  \/  |
  / _ \ \___ \| |    | | | |   | | | | | | | | | | |\/| |
 / ___ \ ___) | |___ | | | |   | |_| | |_| | |_| | |  | |
/_/   \_\____/ \____|___|___|  |____/ \___/ \___/|_|  |_|
        </pre>
        <p>WASD to move, Mouse to look, Click to shoot</p>
        <div class="button" id="start-easy">EASY</div>
        <div class="button" id="start-medium">MEDIUM</div>
        <div class="button" id="start-hard">HARD</div>
    </div>

    <div id="game-over-screen" style="display: none;">
        <pre>
  ____    _    __  __ _____    _____     _______ ____  
 / ___|  / \  |  \/  | ____|  / _ \ \   / / ____|  _ \ 
| |  _  / _ \ | |\/| |  _|   | | | \ \ / /|  _| | |_) |
| |_| |/ ___ \| |  | | |___  | |_| |\ V / | |___|  _ < 
 \____/_/   \_\_|  |_|_____|  \___/  \_/  |_____|_| \_\
        </pre>
        <div class="button" id="restart">RESTART</div>
    </div>

    <div id="level-complete-screen" style="display: none;">
        <pre>
 _     _______     _______ _       ____  ___  _   _ _____ 
| |   | ____\ \   / / ____| |     |  _ \/ _ \| \ | | ____|
| |   |  _|  \ \ / /|  _| | |     | | | | | | |  \| |  _|  
| |___| |___  \ V / | |___| |___  | |_| | |_| | |\  | |___ 
|_____|_____|  \_/  |_____|_____| |____/ \___/|_| \_|_____|
        </pre>
        <div class="button" id="next-level">NEXT LEVEL</div>
    </div>
    
    <audio id="sound-start" src="game_start.mp3" preload="auto"></audio>
    <audio id="sound-fire" src="laser_shot.mp3" preload="auto"></audio>
    <audio id="sound-die" src="player_die.mp3" preload="auto"></audio>
    <script>
        // Game configuration
        const config = {
            screenWidth: 80,
            screenHeight: 30,
            fov: Math.PI / 3,
            depth: 16,
            moveSpeed: 3.0,
            rotateSpeed: 1.5,
            difficulty: 'medium'
        };

        // Game state
        let gameState = {
            isRunning: false,
            player: {
                x: 2,
                y: 2,
                angle: 0,
                health: 100,
                ammo: 50,
                weapon: 'pistol',
                weapons: {
                    'pistol': { damage: 20, ammoPerShot: 1, fireRate: 500 },
                    'shotgun': { damage: 40, ammoPerShot: 2, fireRate: 800 },
                    'plasma': { damage: 60, ammoPerShot: 3, fireRate: 300 }
                },
                lastShot: 0
            },
            currentLevel: 1,
            enemies: [],
            items: [],
            projectiles: [],
            keys: {
                w: false,
                a: false,
                s: false,
                d: false,
                space: false
            },
            map: [],
            enemiesKilled: 0,
            totalEnemies: 0,
            zBuffer: [], // Initialize zBuffer
            lastUpdate: performance.now(),
            lastMinimapUpdate: 0 // New property for minimap update
        };

        // DOM elements
        const gameScreen = document.getElementById('game-screen');
        const hud = document.getElementById('hud');
        const weaponDisplay = document.getElementById('weapon-display');
        const message = document.getElementById('message');
        const minimap = document.getElementById('minimap');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const levelCompleteScreen = document.getElementById('level-complete-screen');
        const startEasyButton = document.getElementById('start-easy');
        const startMediumButton = document.getElementById('start-medium');
        const startHardButton = document.getElementById('start-hard');
        const restartButton = document.getElementById('restart');
        const nextLevelButton = document.getElementById('next-level');

        // Character sets for rendering
        const chars = {
            wall: ['#', '█', '▓', '▒', '░'],
            floor: ['.', '·', ' ', ' ', ' '],
            enemy: ['X', 'X', 'X', 'X', 'X'],  // Use 'X' for enemies at all distances for visibility
            item: ['*', '+', '!', '?', '×'],
            weapon: ['⌐', '¬', '∟', '↑', '↓']
        };

        // Map layouts
        const levels = [
            // Level 1
            [
                "####################",
                "#        #       ##",
                "# ## ### # ##### ##",
                "# #  #   # #     ##",
                "# # ## ### # #####",
                "# # #       #     #",
                "# # ########### # #",
                "# #           # # #",
                "# ############# # #",
                "#               # #",
                "################# #",
                "#                 #",
                "####################"
            ],
            // Level 2
            [
                "####################",
                "#   #    #        #",
                "# # # ## # ###### #",
                "# #    # # #    # #",
                "# ###### # # ## # #",
                "#      # # # #  # #",
                "###### # # # # ## #",
                "#    # # # # #  # #",
                "# ## # # # # ## # #",
                "# #  # # # #    # #",
                "# # ## # # ###### #",
                "#                 #",
                "####################"
            ],
            // Level 3
            [
                "####################",
                "#                 #",
                "# ############### #",
                "# #     #       # #",
                "# # ### # ##### # #",
                "# # #   # #   # # #",
                "# # # ### # # # # #",
                "# # #     # # # # #",
                "# # ####### # # # #",
                "# #         # #   #",
                "# ########### #####",
                "#                 #",
                "####################"
            ]
        ];

        // Initialize the screen buffer
        let screenBuffer = Array(config.screenHeight).fill().map(() => Array(config.screenWidth).fill(' '));

        // Utility functions
        function degToRad(deg) {
            return deg * Math.PI / 180;
        }

        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }

        function showMessage(text, duration = 2000) {
            message.textContent = text;
            message.style.opacity = 1;
            setTimeout(() => {
                message.style.opacity = 0;
            }, duration);
        }

        // Sound control function
        function playSound(id) {
            const audio = document.getElementById(id);
            if (audio) {
                // Stop and rewind to play again immediately
                audio.pause();
                audio.currentTime = 0;
                audio.play().catch(e => console.log("Sound play failed:", e)); // Add catch for potential promise error
            }
        }

        // Game initialization
        function initGame(difficulty) {
            try {
                config.difficulty = difficulty;
                
                // Reset game state
                gameState = {
                    isRunning: true,
                    player: {
                        x: 2,
                        y: 2,
                        angle: 0,
                        health: difficulty === 'easy' ? 150 : difficulty === 'medium' ? 100 : 75,
                        ammo: difficulty === 'easy' ? 75 : difficulty === 'medium' ? 50 : 30,
                        weapon: 'pistol',
                        weapons: {
                            'pistol': { damage: 20, ammoPerShot: 1, fireRate: 500 },
                            'shotgun': { damage: 40, ammoPerShot: 2, fireRate: 800 },
                            'plasma': { damage: 60, ammoPerShot: 3, fireRate: 300 }
                        },
                        lastShot: 0
                    },
                    currentLevel: 1,
                    enemies: [],
                    items: [],
                    projectiles: [],
                    keys: {
                        w: false,
                        a: false,
                        s: false,
                        d: false,
                        space: false
                    },
                    map: [],
                    enemiesKilled: 0,
                    totalEnemies: 0,
                    zBuffer: [], // Initialize zBuffer
                    lastUpdate: performance.now(),
                    lastMinimapUpdate: 0
                };

                // Initialize screen buffer
                screenBuffer = Array(config.screenHeight).fill().map(() => Array(config.screenWidth).fill(' '));
                
                loadLevel(gameState.currentLevel);
                updateHUD();
                
                // Play game start sound
                playSound('sound-start'); 

                // Start game loop
                requestAnimationFrame(gameLoop);
                console.log("Game initialized with difficulty:", difficulty);
            } catch (error) {
                console.error("Error initializing game:", error);
                showMessage("Error starting game. Check console for details.");
            }
        }

        // Load a level
        function loadLevel(levelNum) {
            try {
                const level = levels[levelNum - 1];
                if (!level) {
                    console.error("Invalid level number:", levelNum);
                    return;
                }
                
                gameState.map = level.map(row => row.split(''));
                
                // Reset player position
                gameState.player.x = 2;
                gameState.player.y = 2;
                
                // Clear existing enemies and items
                gameState.enemies = [];
                gameState.items = [];
                gameState.projectiles = [];
                
                // Spawn enemies
                const enemyCount = config.difficulty === 'easy' ? 5 : config.difficulty === 'medium' ? 8 : 12;
                gameState.totalEnemies = enemyCount;
                
                for (let i = 0; i < enemyCount; i++) {
                    let x, y;
                    let attempts = 0;
                    do {
                        x = Math.floor(Math.random() * (gameState.map[0].length - 2)) + 1;
                        y = Math.floor(Math.random() * (gameState.map.length - 2)) + 1;
                        attempts++;
                        if (attempts > 100) break; // Prevent infinite loop
                    } while (
                        gameState.map[y] && gameState.map[y][x] !== ' ' || 
                        (Math.abs(x - gameState.player.x) < 3 && Math.abs(y - gameState.player.y) < 3) ||
                        gameState.enemies.some(e => Math.abs(e.x - x) < 2 && Math.abs(e.y - y) < 2)
                    );
                    
                    if (attempts <= 100) {
                        const health = config.difficulty === 'easy' ? 40 : config.difficulty === 'medium' ? 60 : 100;
                        const speed = config.difficulty === 'easy' ? 0.5 : config.difficulty === 'medium' ? 0.8 : 1.2;
                        const damage = config.difficulty === 'easy' ? 5 : config.difficulty === 'medium' ? 10 : 15;
                        
                        gameState.enemies.push({
                            x, 
                            y, 
                            health,
                            speed,
                            damage,
                            lastMove: 0,
                            moveDelay: 300
                        });
                    }
                }
                
                // Spawn items
                const itemCount = config.difficulty === 'easy' ? 8 : config.difficulty === 'medium' ? 6 : 4;
                for (let i = 0; i < itemCount; i++) {
                    let x, y;
                    let attempts = 0;
                    do {
                        x = Math.floor(Math.random() * (gameState.map[0].length - 2)) + 1;
                        y = Math.floor(Math.random() * (gameState.map.length - 2)) + 1;
                        attempts++;
                        if (attempts > 100) break; // Prevent infinite loop
                    } while (
                        gameState.map[y] && gameState.map[y][x] !== ' ' || 
                        (Math.abs(x - gameState.player.x) < 3 && Math.abs(y - gameState.player.y) < 3) ||
                        gameState.enemies.some(e => Math.abs(e.x - x) < 2 && Math.abs(e.y - y) < 2) ||
                        gameState.items.some(item => Math.abs(item.x - x) < 2 && Math.abs(item.y - y) < 2)
                    );
                    
                    if (attempts <= 100) {
                        const type = Math.random() < 0.7 ? 'ammo' : 'health';
                        const value = type === 'ammo' ? 
                            (config.difficulty === 'easy' ? 20 : config.difficulty === 'medium' ? 15 : 10) : 
                            (config.difficulty === 'easy' ? 30 : config.difficulty === 'medium' ? 20 : 15);
                        
                        gameState.items.push({ x, y, type, value });
                    }
                }
                
                // Spawn weapon upgrades
                const weaponTypes = ['shotgun', 'plasma'];
                for (let i = 0; i < Math.min(levelNum, weaponTypes.length); i++) {
                    let x, y;
                    let attempts = 0;
                    do {
                        x = Math.floor(Math.random() * (gameState.map[0].length - 2)) + 1;
                        y = Math.floor(Math.random() * (gameState.map.length - 2)) + 1;
                        attempts++;
                        if (attempts > 100) break; // Prevent infinite loop
                    } while (
                        gameState.map[y] && gameState.map[y][x] !== ' ' || 
                        (Math.abs(x - gameState.player.x) < 3 && Math.abs(y - gameState.player.y) < 3) ||
                        gameState.enemies.some(e => Math.abs(e.x - x) < 2 && Math.abs(e.y - y) < 2) ||
                        gameState.items.some(item => Math.abs(item.x - x) < 2 && Math.abs(item.y - y) < 2)
                    );
                    
                    if (attempts <= 100) {
                        gameState.items.push({ 
                            x, 
                            y, 
                            type: 'weapon', 
                            weaponType: weaponTypes[i] 
                        });
                    }
                }
                
                updateHUD();
                renderMinimap();
                showMessage(`Level ${levelNum} Started`, 3000);
                console.log("Level loaded:", levelNum);
            } catch (error) {
                console.error("Error loading level:", error);
                showMessage("Error loading level. Check console for details.");
            }
        }

        // Main game loop
        function gameLoop(timestamp) {
            if (!gameState.isRunning) return;
            
            try {
                // Clear screen buffer
                screenBuffer = Array(config.screenHeight).fill().map(() => Array(config.screenWidth).fill(' '));
                gameState.zBuffer = Array(config.screenWidth).fill(Infinity); // Reset zBuffer for this frame
                
                // Update player position based on keys
                updatePlayer(timestamp);
                
                // Update enemies
                updateEnemies(timestamp);
                
                // Update projectiles
                updateProjectiles(timestamp);
                
                // Check collisions with items
                checkItemCollisions();
                
                // Render the scene
                render();
                
                // Update the screen
                updateScreen();
                
                // Update radar
                updateRadar();

                // Update minimap periodically (every 500ms)
                if (timestamp - (gameState.lastMinimapUpdate || 0) > 500) {
                    renderMinimap();
                    gameState.lastMinimapUpdate = timestamp;
                }
                
                // Check win/lose conditions
                checkGameStatus();
                
                // Continue the game loop
                requestAnimationFrame(gameLoop);
            } catch (error) {
                console.error("Error in game loop:", error);
                showMessage("Game error. Check console for details.");
                gameState.isRunning = false;
            }
        }

        // Update player position and orientation
        function updatePlayer(timestamp) {
            const moveSpeed = config.moveSpeed * (timestamp - gameState.lastUpdate) / 1000;
            const rotateSpeed = config.rotateSpeed * (timestamp - gameState.lastUpdate) / 1000;
            
            // Movement
            let dx = 0;
            let dy = 0;
            
            // Forward/backward movement
            if (gameState.keys.w) {
                dx += Math.cos(gameState.player.angle) * moveSpeed;
                dy += Math.sin(gameState.player.angle) * moveSpeed;
            }
            if (gameState.keys.s) {
                dx += -Math.cos(gameState.player.angle) * moveSpeed;
                dy += -Math.sin(gameState.player.angle) * moveSpeed;
            }
            
            // Strafe left/right movement (perpendicular to view direction)
            if (gameState.keys.a) {
                dx += Math.cos(gameState.player.angle + Math.PI/2) * moveSpeed; // Reversed direction
                dy += Math.sin(gameState.player.angle + Math.PI/2) * moveSpeed; // Reversed direction
            }
            if (gameState.keys.d) {
                dx += Math.cos(gameState.player.angle - Math.PI/2) * moveSpeed; // Reversed direction
                dy += Math.sin(gameState.player.angle - Math.PI/2) * moveSpeed; // Reversed direction
            }
            
            // Collision detection with walls
            const newX = gameState.player.x + dx;
            const newY = gameState.player.y + dy;
            
            const cellX = Math.floor(newX);
            const cellY = Math.floor(newY);
            
            // Make sure we check within bounds of the map
            if (cellY >= 0 && cellY < gameState.map.length && 
                cellX >= 0 && cellX < gameState.map[cellY].length) {
                
                if (gameState.map[cellY][cellX] !== '#') {
                    gameState.player.x = newX;
                    gameState.player.y = newY;
                } else {
                    // Try to slide along walls
                    const currentCellY = Math.floor(gameState.player.y);
                    const currentCellX = Math.floor(gameState.player.x);
                    
                    if (currentCellY >= 0 && currentCellY < gameState.map.length &&
                        cellX >= 0 && cellX < gameState.map[currentCellY].length &&
                        gameState.map[currentCellY][cellX] !== '#') {
                        gameState.player.x = newX;
                    } else if (cellY >= 0 && cellY < gameState.map.length &&
                              currentCellX >= 0 && currentCellX < gameState.map[cellY].length &&
                              gameState.map[cellY][currentCellX] !== '#') {
                        gameState.player.y = newY;
                    }
                }
            }
            
            gameState.lastUpdate = timestamp;
        }

        // Update enemy positions and behavior
        function updateEnemies(timestamp) {
            for (let i = 0; i < gameState.enemies.length; i++) {
                const enemy = gameState.enemies[i];
                
                // Skip if enemy is dead
                if (enemy.health <= 0) continue;
                
                // Only move periodically
                if (timestamp - enemy.lastMove < enemy.moveDelay) continue;
                
                // Move towards player if within sight
                const distToPlayer = distance(enemy.x, enemy.y, gameState.player.x, gameState.player.y);
                
                if (distToPlayer < 8) {
                    // Calculate direction to player
                    const dx = gameState.player.x - enemy.x;
                    const dy = gameState.player.y - enemy.y;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    
                    // Normalize and scale by speed
                    const dirX = (dx / length) * enemy.speed;
                    const dirY = (dy / length) * enemy.speed;
                    
                    // Check if new position would be in a wall
                    const newX = enemy.x + dirX;
                    const newY = enemy.y + dirY;
                    const cellX = Math.floor(newX);
                    const cellY = Math.floor(newY);
                    
                    // Check bounds
                    if (cellY >= 0 && cellY < gameState.map.length && 
                        cellX >= 0 && cellX < gameState.map[cellY].length &&
                        gameState.map[cellY][cellX] !== '#') {
                        
                        enemy.x = newX;
                        enemy.y = newY;
                    } else {
                        // Try to slide along walls
                        const currentCellY = Math.floor(enemy.y);
                        const currentCellX = Math.floor(enemy.x);
                        
                        if (currentCellY >= 0 && currentCellY < gameState.map.length &&
                            cellX >= 0 && cellX < gameState.map[currentCellY].length &&
                            gameState.map[currentCellY][cellX] !== '#') {
                            enemy.x = newX;
                        } else if (cellY >= 0 && cellY < gameState.map.length &&
                                  currentCellX >= 0 && currentCellX < gameState.map[cellY].length &&
                                  gameState.map[cellY][currentCellX] !== '#') {
                            enemy.y = newY;
                        }
                    }
                    
                    // Attack player if very close
                    if (distToPlayer < 1.5) {
                        gameState.player.health -= enemy.damage;
                        showMessage(`Enemy attack! -${enemy.damage} health`);
                        updateHUD();
                    }
                } else {
                    // Random movement if player not in sight
                    if (Math.random() < 0.7) continue; // 70% chance to not move
                    
                    const directions = [
                        { x: 1, y: 0 },
                        { x: -1, y: 0 },
                        { x: 0, y: 1 },
                        { x: 0, y: -1 }
                    ];
                    
                    const dir = directions[Math.floor(Math.random() * directions.length)];
                    const newX = enemy.x + dir.x * enemy.speed;
                    const newY = enemy.y + dir.y * enemy.speed;
                    const cellX = Math.floor(newX);
                    const cellY = Math.floor(newY);
                    
                    if (cellY >= 0 && cellY < gameState.map.length && 
                        cellX >= 0 && cellX < gameState.map[cellY].length &&
                        gameState.map[cellY][cellX] !== '#') {
                        
                        enemy.x = newX;
                        enemy.y = newY;
                    }
                }
                
                enemy.lastMove = timestamp;
            }
            
            // Remove dead enemies
            const deadEnemies = gameState.enemies.filter(enemy => enemy.health <= 0).length;
            gameState.enemiesKilled += deadEnemies;
            gameState.enemies = gameState.enemies.filter(enemy => enemy.health > 0);
            
            if (deadEnemies > 0) {
                updateHUD();
            }
        }

        // Update projectiles
        function updateProjectiles(timestamp) {
            for (let i = 0; i < gameState.projectiles.length; i++) {
                const proj = gameState.projectiles[i];
                
                // Move projectile
                proj.x += proj.dx;
                proj.y += proj.dy;
                
                // Check wall collision
                const cellX = Math.floor(proj.x);
                const cellY = Math.floor(proj.y);
                
                if (cellY >= 0 && cellY < gameState.map.length && 
                    cellX >= 0 && cellX < gameState.map[cellY].length &&
                    gameState.map[cellY][cellX] === '#') {
                    
                    proj.toRemove = true;
                    continue;
                }
                
                // Check enemy collision
                for (let j = 0; j < gameState.enemies.length; j++) {
                    const enemy = gameState.enemies[j];
                    if (enemy.health <= 0) continue;
                    
                    const dist = distance(proj.x, proj.y, enemy.x, enemy.y);
                    if (dist < 0.5) {
                        enemy.health -= proj.damage;
                        proj.toRemove = true;
                        
                        if (enemy.health <= 0) {
                            gameState.enemiesKilled++;
                            updateHUD();
                            showMessage("+1 Kill");
                        }
                        break;
                    }
                }
            }
            
            // Remove expired projectiles
            gameState.projectiles = gameState.projectiles.filter(proj => !proj.toRemove);
        }

        // Check for collisions with items
        function checkItemCollisions() {
            for (let i = 0; i < gameState.items.length; i++) {
                const item = gameState.items[i];
                const dist = distance(gameState.player.x, gameState.player.y, item.x, item.y);
                
                if (dist < 0.7) {
                    // Apply item effect
                    if (item.type === 'health') {
                        gameState.player.health = Math.min(gameState.player.health + item.value, 200);
                        showMessage(`+${item.value} Health`);
                    } else if (item.type === 'ammo') {
                        gameState.player.ammo += item.value;
                        showMessage(`+${item.value} Ammo`);
                    } else if (item.type === 'weapon') {
                        gameState.player.weapon = item.weaponType;
                        showMessage(`Weapon upgrade: ${item.weaponType.toUpperCase()}`);
                    }
                    
                    // Remove collected item
                    gameState.items.splice(i, 1);
                    i--;
                    
                    updateHUD();
                }
            }
        }

        // Check game status (win/lose conditions)
        function checkGameStatus() {
            // Check if player is dead
            if (gameState.player.health <= 0) {
                gameOver();
                return;
            }
            
            // Check if level is complete (all enemies killed)
            if (gameState.enemiesKilled >= gameState.totalEnemies) {
                levelComplete();
            }
        }

        // Game over
        function gameOver() {
            gameState.isRunning = false;
            gameOverScreen.style.display = 'flex';
            document.getElementById('enemy-radar').style.display = 'none';
            playSound('sound-die'); // Play player death sound
        }

        // Level complete
        function levelComplete() {
            gameState.isRunning = false;
            
            if (gameState.currentLevel >= levels.length) {
                // Game completed
                showMessage("Congratulations! You've completed all levels!");
                setTimeout(() => {
                    gameOver();
                }, 3000);
            } else {
                levelCompleteScreen.style.display = 'flex';
                document.getElementById('enemy-radar').style.display = 'none';
            }
        }

        // Next level
        function nextLevel() {
            levelCompleteScreen.style.display = 'none';
            gameState.currentLevel++;
            gameState.enemiesKilled = 0;
            
            // Give bonus health and ammo
            gameState.player.health = Math.min(gameState.player.health + 50, 200);
            gameState.player.ammo += 30;
            
            loadLevel(gameState.currentLevel);
            document.getElementById('enemy-radar').style.display = 'block';
            gameState.isRunning = true;
            requestAnimationFrame(gameLoop);
        }

        // Render the scene
        function render() {
            try {
                const player = gameState.player;
                
                // Raycasting loop
                for (let x = 0; x < config.screenWidth; x++) {
                    // Calculate ray position and direction
                    const cameraX = 2 * x / config.screenWidth - 1;
                    const rayDirX = Math.cos(player.angle) + Math.sin(player.angle) * cameraX;
                    const rayDirY = Math.sin(player.angle) - Math.cos(player.angle) * cameraX;
                    
                    // Which map cell the player is in
                    let mapX = Math.floor(player.x);
                    let mapY = Math.floor(player.y);
                    
                    // Length of ray from current position to next x or y-side
                    let sideDistX, sideDistY;
                    
                    // Length of ray from one x or y-side to next x or y-side
                    const deltaDistX = Math.abs(1 / (rayDirX === 0 ? 0.00001 : rayDirX)); // Avoid division by zero
                    const deltaDistY = Math.abs(1 / (rayDirY === 0 ? 0.00001 : rayDirY)); // Avoid division by zero
                    
                    // Direction to step in x or y direction (either +1 or -1)
                    let stepX, stepY;
                    
                    // Was a wall hit?
                    let hit = false;
                    let side = 0; // 0 for NS wall, 1 for EW wall
                    
                    // Calculate step and initial sideDist
                    if (rayDirX < 0) {
                        stepX = -1;
                        sideDistX = (player.x - mapX) * deltaDistX;
                    } else {
                        stepX = 1;
                        sideDistX = (mapX + 1.0 - player.x) * deltaDistX;
                    }
                    
                    if (rayDirY < 0) {
                        stepY = -1;
                        sideDistY = (player.y - mapY) * deltaDistY;
                    } else {
                        stepY = 1;
                        sideDistY = (mapY + 1.0 - player.y) * deltaDistY;
                    }
                    
                    // Perform DDA
                    let maxSteps = 20; // Maximum steps to prevent infinite loops
                    let steps = 0;
                    
                    while (!hit && steps < maxSteps) {
                        steps++;
                        
                        // Jump to next map square
                        if (sideDistX < sideDistY) {
                            sideDistX += deltaDistX;
                            mapX += stepX;
                            side = 0;
                        } else {
                            sideDistY += deltaDistY;
                            mapY += stepY;
                            side = 1;
                        }
                        
                        // Check if ray has hit a wall
                        if (mapY >= 0 && mapY < gameState.map.length && 
                            mapX >= 0 && mapX < gameState.map[mapY].length &&
                            gameState.map[mapY][mapX] === '#') {
                            hit = true;
                        }
                    }
                    
                    // Calculate distance projected on camera direction
                    let perpWallDist;
                    if (side === 0) {
                        perpWallDist = (mapX - player.x + (1 - stepX) / 2) / rayDirX;
                    } else {
                        perpWallDist = (mapY - player.y + (1 - stepY) / 2) / rayDirY;
                    }
                    
                    // Prevent negative or zero distance
                    perpWallDist = Math.max(0.1, perpWallDist);
                    
                    // Calculate height of wall slice to draw
                    const lineHeight = Math.floor(config.screenHeight / perpWallDist);
                    
                    // Calculate where to draw and what to draw
                    let drawStart = Math.floor(-lineHeight / 2 + config.screenHeight / 2);
                    if (drawStart < 0) drawStart = 0;
                    let drawEnd = Math.floor(lineHeight / 2 + config.screenHeight / 2);
                    if (drawEnd >= config.screenHeight) drawEnd = config.screenHeight - 1;
                    
                    // Choose wall character based on distance
                    const charIndex = Math.min(Math.floor(perpWallDist / 3), chars.wall.length - 1);
                    const wallChar = chars.wall[charIndex];
                    
                    // Draw the wall slice
                    for (let y = 0; y < config.screenHeight; y++) {
                        if (y < drawStart) {
                            // Draw ceiling
                            screenBuffer[y][x] = ' ';
                        } else if (y >= drawStart && y <= drawEnd) {
                            // Draw wall
                            screenBuffer[y][x] = side === 0 ? wallChar : wallChar;
                        } else {
                            // Draw floor
                            const floorCharIndex = Math.min(Math.floor((y - drawEnd) / (config.screenHeight - drawEnd) * chars.floor.length), chars.floor.length - 1);
                            screenBuffer[y][x] = chars.floor[floorCharIndex];
                        }
                    }
                    
                    // Store wall distance for sprite rendering
                    gameState.zBuffer[x] = perpWallDist;
                }
                
                // Render sprites (enemies and items)
                renderSprites();
            } catch (error) {
                console.error("Error rendering scene:", error);
            }
        }

        // Render sprites (enemies and items)
        function renderSprites() {
            try {
                const player = gameState.player;
                
                // Combine enemies and items into a single sprite array
                const sprites = [];
                
                // Add enemies
                for (const enemy of gameState.enemies) {
                    if (enemy.health <= 0) continue;
                    sprites.push({
                        x: enemy.x,
                        y: enemy.y,
                        type: 'enemy',
                        distance: distance(player.x, player.y, enemy.x, enemy.y)
                    });
                }
                
                // Add items
                for (const item of gameState.items) {
                    sprites.push({
                        x: item.x,
                        y: item.y,
                        type: item.type === 'weapon' ? 'weapon' : 'item',
                        distance: distance(player.x, player.y, item.x, item.y)
                    });
                }
                
                // Sort sprites by distance (far to close)
                sprites.sort((a, b) => b.distance - a.distance);
                
                // Render each sprite
                for (const sprite of sprites) {
                    // Skip sprites that are too far
                    if (sprite.distance > 16) continue;
                    
                    // Translate sprite position relative to player
                    const spriteX = sprite.x - player.x;
                    const spriteY = sprite.y - player.y;
                    
                    // Transform sprite with the inverse camera matrix
                    // Using a simplified approach for ASCII rendering
                    const invDet = 1.0 / (Math.cos(player.angle) * Math.sin(player.angle + Math.PI/2) - 
                                        Math.sin(player.angle) * Math.cos(player.angle + Math.PI/2));
                    
                    let transformX, transformY;
                    
                    // Prevent division by zero
                    if (Math.abs(invDet) < 0.0001) {
                        transformX = spriteX;
                        transformY = spriteY;
                    } else {
                        transformX = invDet * (Math.sin(player.angle + Math.PI/2) * spriteX - Math.cos(player.angle + Math.PI/2) * spriteY);
                        transformY = invDet * (-Math.sin(player.angle) * spriteX + Math.cos(player.angle) * spriteY);
                    }
                    
                    // Prevent zero or negative transformY
                    if (transformY <= 0) continue;
                    
                    // Calculate sprite screen position
                    const spriteScreenX = Math.floor((config.screenWidth / 2) * (1 + transformX / transformY));
                    
                    // Calculate sprite height
                    const spriteHeight = Math.abs(Math.floor(config.screenHeight / transformY));
                    
                    // Calculate drawing boundaries
                    let drawStartY = Math.floor(-spriteHeight / 2 + config.screenHeight / 2);
                    if (drawStartY < 0) drawStartY = 0;
                    let drawEndY = Math.floor(spriteHeight / 2 + config.screenHeight / 2);
                    if (drawEndY >= config.screenHeight) drawEndY = config.screenHeight - 1;
                    
                    // Calculate sprite width
                    const spriteWidth = Math.abs(Math.floor(config.screenHeight / transformY));
                    let drawStartX = Math.floor(-spriteWidth / 2 + spriteScreenX);
                    if (drawStartX < 0) drawStartX = 0;
                    let drawEndX = Math.floor(spriteWidth / 2 + spriteScreenX);
                    if (drawEndX >= config.screenWidth) drawEndX = config.screenWidth - 1;
                    
                    // Calculate size of the sprite square
                    const spriteSize = Math.max(1, Math.min(drawEndX - drawStartX, drawEndY - drawStartY));
                    
                    // Get character based on sprite type and distance
                    let char;
                    const distanceIndex = Math.min(Math.floor(sprite.distance), 4);
                    
                    if (sprite.type === 'enemy') {
                        char = chars.enemy[distanceIndex];
                    } else if (sprite.type === 'item') {
                        char = chars.item[distanceIndex];
                    } else if (sprite.type === 'weapon') {
                        char = chars.weapon[distanceIndex];
                    }
                    
                    // Draw enemies as large blocks of 'X' characters (now red via CSS)
                    if (sprite.type === 'enemy') {
                        // Size depends on distance
                        const size = sprite.distance < 3 ? 3 : 
                                    sprite.distance < 6 ? 2 : 1;
                        
                        for (let sy = -size; sy <= size; sy++) {
                            for (let sx = -size; sx <= size; sx++) {
                                const x = Math.floor((drawStartX + drawEndX) / 2) + sx;
                                const y = Math.floor((drawStartY + drawEndY) / 2) + sy;
                                
                                if (y >= 0 && y < config.screenHeight && 
                                    x >= 0 && x < config.screenWidth && 
                                    transformY < gameState.zBuffer[x]) {
                                    // Use X for all enemy characters 
                                    screenBuffer[y][x] = 'X'; 
                                }
                            }
                        }
                    } else {
                        // For items and weapons, just draw a single character
                        const centerX = Math.floor((drawStartX + drawEndX) / 2);
                        const centerY = Math.floor((drawStartY + drawEndY) / 2);
                        
                        if (centerY >= 0 && centerY < config.screenHeight && 
                            centerX >= 0 && centerX < config.screenWidth && 
                            transformY < gameState.zBuffer[centerX]) {
                            screenBuffer[centerY][centerX] = char;
                        }
                    }
                }
            } catch (error) {
                console.error("Error rendering sprites:", error);
            }
        }

        // Update the screen with the current buffer (Modified to apply CSS classes)
        function updateScreen() {
            try {
                let screenContent = '';
                for (let y = 0; y < config.screenHeight; y++) {
                    for (let x = 0; x < config.screenWidth; x++) {
                        const char = screenBuffer[y][x];
                        let coloredChar = char;
                        
                        // Apply CSS color classes based on the character
                        if (char === 'X') { 
                            coloredChar = `<span class="enemy-color">${char}</span>`;
                        } else if (chars.wall.includes(char)) {
                            coloredChar = `<span class="wall-color">${char}</span>`;
                        } else if (chars.item.includes(char)) {
                            coloredChar = `<span class="item-color">${char}</span>`;
                        } else if (chars.weapon.includes(char)) {
                            coloredChar = `<span class="weapon-color">${char}</span>`;
                        } else if (chars.floor.includes(char)) {
                             // Floor is default color, but wrap to ensure no rogue closing span tags
                             coloredChar = `<span>${char}</span>`; 
                        } else {
                            coloredChar = `<span>${char}</span>`; 
                        }
                        
                        screenContent += coloredChar;
                    }
                    screenContent += '\n';
                }
                gameScreen.innerHTML = screenContent; // Use innerHTML to render the span tags
            } catch (error) {
                console.error("Error updating screen:", error);
            }
        }

        // Update HUD information
        function updateHUD() {
            hud.textContent = `Health: ${Math.floor(gameState.player.health)} | Ammo: ${gameState.player.ammo} | Kills: ${gameState.enemiesKilled}/${gameState.totalEnemies} | Level: ${gameState.currentLevel}`;
            weaponDisplay.textContent = `Weapon: ${gameState.player.weapon.charAt(0).toUpperCase() + gameState.player.weapon.slice(1)}`;
        }

        // Render minimap
        function renderMinimap() {
            try {
                if (!gameState.map || !gameState.map.length) return;
                
                const mapWidth = gameState.map[0].length;
                const mapHeight = gameState.map.length;
                let minimapContent = '';
                
                for (let y = 0; y < mapHeight; y++) {
                    for (let x = 0; x < mapWidth; x++) {
                        if (Math.floor(gameState.player.x) === x && Math.floor(gameState.player.y) === y) {
                            minimapContent += 'P';
                        } else if (gameState.enemies.some(e => Math.floor(e.x) === x && Math.floor(e.y) === y)) {
                            minimapContent += 'M'; // Use M for enemies on minimap too
                        } else if (gameState.items.some(i => Math.floor(i.x) === x && Math.floor(i.y) === y)) {
                            minimapContent += '+';
                        } else {
                            minimapContent += gameState.map[y][x];
                        }
                    }
                    minimapContent += '\n';
                }
                
                minimap.textContent = minimapContent;
            } catch (error) {
                console.error("Error rendering minimap:", error);
            }
        }

        // Fire weapon
        function fireWeapon() {
            try {
                const now = Date.now();
                const weapon = gameState.player.weapons[gameState.player.weapon];
                
                // Check if can fire (enough ammo and cooldown)
                if (gameState.player.ammo < weapon.ammoPerShot || now - gameState.player.lastShot < weapon.fireRate) {
                    if (gameState.player.ammo < weapon.ammoPerShot) {
                        showMessage("Out of ammo!");
                    }
                    return;
                }
                
                // Consume ammo
                gameState.player.ammo -= weapon.ammoPerShot;
                gameState.player.lastShot = now;

                // Play fire sound
                playSound('sound-fire'); 
                
                // Create projectile
                const dirX = Math.cos(gameState.player.angle);
                const dirY = Math.sin(gameState.player.angle);
                
                // For shotgun, create multiple projectiles with slight spread
                if (gameState.player.weapon === 'shotgun') {
                    for (let i = -1; i <= 1; i++) {
                        const angle = gameState.player.angle + i * 0.1;
                        const spreadX = Math.cos(angle);
                        const spreadY = Math.sin(angle);
                        
                        gameState.projectiles.push({
                            x: gameState.player.x,
                            y: gameState.player.y,
                            dx: spreadX * 0.2,
                            dy: spreadY * 0.2,
                            damage: weapon.damage / 3
                        });
                    }
                } else {
                    gameState.projectiles.push({
                        x: gameState.player.x,
                        y: gameState.player.y,
                        dx: dirX * 0.2,
                        dy: dirY * 0.2,
                        damage: weapon.damage
                    });
                }
                
                updateHUD();
            } catch (error) {
                console.error("Error firing weapon:", error);
            }
        }

        // --------------------------------
        // Event listeners
        // --------------------------------
        
        // Keyboard controls
        document.addEventListener('keydown', function(event) {
            switch(event.key.toLowerCase()) {
                case 'w': gameState.keys.w = true; break;
                case 'a': gameState.keys.a = true; break;
                case 's': gameState.keys.s = true; break;
                case 'd': gameState.keys.d = true; break;
                case ' ': gameState.keys.space = true; break;
            }
        });
        
        document.addEventListener('keyup', function(event) {
            switch(event.key.toLowerCase()) {
                case 'w': gameState.keys.w = false; break;
                case 'a': gameState.keys.a = false; break;
                case 's': gameState.keys.s = false; break;
                case 'd': gameState.keys.d = false; break;
                case ' ': gameState.keys.space = false; break;
            }
        });
        
        // We'll rely on pointer lock for mouse controls instead
        document.addEventListener('mousemove', function(event) {
            // This handler is only for fallback if pointer lock isn't active
            if (!gameState.isRunning || 
                document.pointerLockElement === gameScreen || 
                document.mozPointerLockElement === gameScreen || 
                document.webkitPointerLockElement === gameScreen) {
                return;
            }
            
            // Basic fallback rotation if pointer lock isn't supported
            const centerX = window.innerWidth / 2;
            const delta = (event.clientX - centerX) * 0.002;
            gameState.player.angle -= delta;
        });
        
        document.addEventListener('click', function(event) {
            if (!gameState.isRunning) return;
            fireWeapon();
        });
        
        // Prevent context menu on right click
        document.addEventListener('contextmenu', function(event) {
            event.preventDefault();
        });
        
        // Button event listeners
        startEasyButton.addEventListener('click', function() {
            startScreen.style.display = 'none';
            initGame('easy');
            requestPointerLock(); // Request pointer lock immediately
        });
        
        startMediumButton.addEventListener('click', function() {
            startScreen.style.display = 'none';
            initGame('medium');
            requestPointerLock(); // Request pointer lock immediately
        });
        
        startHardButton.addEventListener('click', function() {
            startScreen.style.display = 'none';
            initGame('hard');
            requestPointerLock(); // Request pointer lock immediately
        });
        
        // Helper function for requesting pointer lock
        function requestPointerLock() {
            if (document.pointerLockElement !== gameScreen && 
                document.mozPointerLockElement !== gameScreen && 
                document.webkitPointerLockElement !== gameScreen) {
                
                gameScreen.requestPointerLock = gameScreen.requestPointerLock || 
                                             gameScreen.mozRequestPointerLock || 
                                             gameScreen.webkitRequestPointerLock;
                
                if (typeof gameScreen.requestPointerLock === 'function') {
                    setTimeout(() => {
                        gameScreen.requestPointerLock();
                        showMessage("Click game to capture mouse", 3000);
                    }, 100);
                }
            }
        }
        
        restartButton.addEventListener('click', function() {
            gameOverScreen.style.display = 'none';
            initGame(config.difficulty);
        });
        
        nextLevelButton.addEventListener('click', function() {
            nextLevel();
        });
        
        // Update enemy radar
        function updateRadar() {
            try {
                const radar = document.getElementById('enemy-radar');
                const radarSize = 150; // Radar diameter in pixels
                const radarRange = 10; // Game units
                
                // Clear existing blips
                const existingBlips = document.querySelectorAll('.radar-blip');
                existingBlips.forEach(blip => blip.remove());
                
                // Update direction indicator
                const directionIndicator = document.querySelector('.radar-direction');
                if (directionIndicator) {
                    // Angle is relative to the top of the radar circle (0 rad is up)
                    const indicatorAngle = gameState.player.angle + Math.PI / 2; 
                    directionIndicator.style.transform = `rotate(${indicatorAngle}rad) translate(-50%, 0)`;
                }
                
                // Add new blips for each enemy
                for (const enemy of gameState.enemies) {
                    if (enemy.health <= 0) continue;
                    
                    // Calculate position relative to player
                    const dx = enemy.x - gameState.player.x;
                    const dy = enemy.y - gameState.player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Skip if out of radar range
                    if (dist > radarRange) continue;
                    
                    // Calculate radar coordinates (relative to the top of the radar circle)
                    const angleToEnemy = Math.atan2(dy, dx);
                    // Adjust by player angle and add Math.PI/2 to orient the blip correctly on the radar display
                    const angleDifference = angleToEnemy - gameState.player.angle - (Math.PI / 2); 
                    
                    const blipX = 50 + Math.sin(angleDifference) * (dist / radarRange) * 50;
                    const blipY = 50 + Math.cos(angleDifference) * (dist / radarRange) * 50;
                    
                    // Create blip element
                    const blip = document.createElement('div');
                    blip.className = 'radar-blip';
                    blip.style.left = blipX + '%';
                    blip.style.top = blipY + '%';
                    
                    // Size and opacity based on distance
                    const blipSize = Math.max(4, 10 - dist * 0.5);
                    blip.style.width = blipSize + 'px';
                    blip.style.height = blipSize + 'px';
                    blip.style.opacity = Math.max(0.4, 1 - dist / radarRange);
                    
                    // Add pulsing animation for nearby enemies
                    if (dist < 2) {
                        blip.style.animation = 'pulse 0.5s infinite alternate';
                    }
                    
                    radar.appendChild(blip);
                }
            } catch (error) {
                console.error("Error updating radar:", error);
            }
        }
        
        // Add pulse animation when the game starts
        function setupAnimations() {
            const style = document.createElement('style');
            style.textContent = `
                @keyframes pulse {
                    from { transform: translate(-50%, -50%) scale(1); }
                    to { transform: translate(-50%, -50%) scale(1.5); }
                }
            `;
            document.head.appendChild(style);
        }
        
        // Call setup on window load
        window.addEventListener('load', setupAnimations);
        
        // Pointer lock for mouse control
        gameScreen.addEventListener('click', function() {
            if (document.pointerLockElement !== gameScreen && 
                document.mozPointerLockElement !== gameScreen && 
                document.webkitPointerLockElement !== gameScreen) {
                
                gameScreen.requestPointerLock = gameScreen.requestPointerLock || 
                                                gameScreen.mozRequestPointerLock || 
                                                gameScreen.webkitRequestPointerLock;
                
                if (typeof gameScreen.requestPointerLock === 'function') {
                    gameScreen.requestPointerLock();
                }
            }
        });
        
        // Handle pointer lock change
        document.addEventListener('pointerlockchange', lockChangeHandler, false);
        document.addEventListener('mozpointerlockchange', lockChangeHandler, false);
        document.addEventListener('webkitpointerlockchange', lockChangeHandler, false);
        
        function lockChangeHandler() {
            if (document.pointerLockElement === gameScreen || 
                document.mozPointerLockElement === gameScreen || 
                document.webkitPointerLockElement === gameScreen) {
                document.addEventListener('mousemove', updateRotation, false);
            } else {
                document.removeEventListener('mousemove', updateRotation, false);
            }
        }
        
        function updateRotation(e) {
            if (!gameState.isRunning) return;
            
            // Get mouse movement and update player rotation
            const movementX = e.movementX || 
                             e.mozMovementX || 
                             e.webkitMovementX || 0;
            
            // Use a sensitivity multiplier - higher value = more sensitive
            const sensitivity = 0.003;
            gameState.player.angle -= movementX * sensitivity;
            
            // Wrap angle to keep it within 0-2π range
            if (gameState.player.angle < 0) {
                gameState.player.angle += Math.PI * 2;
            } else if (gameState.player.angle >= Math.PI * 2) {
                gameState.player.angle -= Math.PI * 2;
            }
        }

        console.log("Game is ready to start");
    </script>
</body>
</html>