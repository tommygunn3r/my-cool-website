<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Who Wrote It Better? - Multiplayer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Cinzel:wght@400;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg: #050509;
            --bg-alt: #131321;
            --card-bg: #171728;
            --gold: #f5c25c;
            --gold-soft: #fbe1a5;
            --accent: #36c2ff;
            --accent-soft: rgba(54, 194, 255, 0.12);
            --danger: #ff4d4d;
            --success: #4dff8a;
            --text-main: #f5f5f5;
            --text-soft: #b0b0c0;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            background: radial-gradient(circle at top, #202040 0%, #050509 60%);
            color: var(--text-main);
            font-family: "Roboto", sans-serif;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.2rem 1.8rem;
            background: linear-gradient(to right, #0b0b14, #17172a);
            border-bottom: 1px solid rgba(245, 194, 92, 0.3);
            box-shadow: 0 4px 18px rgba(0,0,0,0.5);
        }

        .logo {
            font-family: "Cinzel", serif;
            font-size: 1.5rem;
            letter-spacing: 0.18em;
            color: var(--gold);
        }

        .header-right {
            display: flex;
            gap: 1.2rem;
            align-items: center;
        }

        .room-pill {
            padding: 0.4rem 0.9rem;
            border-radius: 999px;
            background: rgba(0,0,0,0.4);
            border: 1px solid rgba(255,255,255,0.2);
            font-size: 0.85rem;
        }

        .host-tag {
            padding: 0.2rem 0.6rem;
            border-radius: 999px;
            border: 1px solid var(--gold);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
        }

        .main {
            max-width: 1100px;
            margin: 1.8rem auto 3rem;
            padding: 0 1rem;
            display: grid;
            grid-template-columns: minmax(0, 2fr) minmax(0, 1.2fr);
            gap: 1.5rem;
        }

        @media (max-width: 900px) {
            .main {
                grid-template-columns: 1fr;
            }
        }

        /* Left Panel (Game Area) */
        .game-card {
            background: linear-gradient(145deg, #15152a, #1c1c38);
            border-radius: 14px;
            padding: 1.4rem 1.6rem;
            box-shadow: 0 6px 24px rgba(0,0,0,0.75);
            border: 1px solid rgba(255,255,255,0.08);
            min-height: 420px;
        }

        .game-title {
            font-family: "Cinzel", serif;
            font-size: 1.8rem;
            letter-spacing: 0.12em;
            margin-bottom: 0.2rem;
        }

        .game-subtitle {
            font-size: 0.95rem;
            color: var(--text-soft);
            margin-bottom: 1.2rem;
        }

        .phase-tag {
            display: inline-block;
            padding: 0.25rem 0.6rem;
            border-radius: 999px;
            border: 1px solid rgba(255,255,255,0.25);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            margin-bottom: 0.7rem;
        }

        .phase-submit { border-color: var(--accent); color: var(--accent); }
        .phase-vote { border-color: var(--gold); color: var(--gold-soft); }
        .phase-results { border-color: var(--success); color: var(--success); }
        .phase-lobby { border-color: var(--text-soft); color: var(--text-soft); }

        .prompt-box {
            background: rgba(4,4,12,0.92);
            border-radius: 10px;
            padding: 1.1rem 1rem;
            border: 1px solid rgba(255,255,255,0.1);
            margin-bottom: 1rem;
        }

        .prompt-source {
            font-size: 0.8rem;
            color: var(--text-soft);
            margin-bottom: 0.4rem;
        }

        .prompt-text {
            font-size: 1.1rem;
            line-height: 1.4;
        }

        .round-label {
            font-size: 0.9rem;
            color: var(--text-soft);
            margin-bottom: 0.5rem;
        }

        .row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.8rem;
            margin-bottom: 0.7rem;
        }

        .timer {
            padding: 0.25rem 0.6rem;
            border-radius: 999px;
            background: rgba(0,0,0,0.4);
            border: 1px solid rgba(255,255,255,0.25);
            font-size: 0.8rem;
        }

        .status-msg {
            font-size: 0.85rem;
            color: var(--text-soft);
        }

        /* Answer input */
        .answer-input-area {
            margin-top: 1.0rem;
        }

        .answer-input {
            width: 100%;
            min-height: 70px;
            padding: 0.7rem;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.25);
            background: rgba(5,5,15,0.95);
            color: var(--text-main);
            resize: vertical;
            font-family: inherit;
        }

        .answer-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 1px rgba(54, 194, 255, 0.5);
        }

        .answer-buttons {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 0.6rem;
            gap: 0.6rem;
            flex-wrap: wrap;
        }

        .btn {
            border-radius: 999px;
            padding: 0.55rem 1.2rem;
            border: none;
            font-size: 0.9rem;
            cursor: pointer;
            font-weight: 500;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            transition: transform 0.12s ease, box-shadow 0.12s ease, opacity 0.12s ease;
        }

        .btn-primary {
            background: radial-gradient(circle at top, var(--gold-soft), var(--gold));
            color: #2b1c08;
            box-shadow: 0 4px 14px rgba(245, 194, 92, 0.5);
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 18px rgba(245, 194, 92, 0.6);
        }

        .btn-accent {
            background: radial-gradient(circle at top, var(--accent), #0477b3);
            color: #021218;
            box-shadow: 0 4px 14px rgba(54, 194, 255, 0.4);
        }

        .btn-accent:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 18px rgba(54, 194, 255, 0.5);
        }

        .btn-ghost {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.35);
            color: var(--text-soft);
        }

        .btn[disabled] {
            opacity: 0.55;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        /* Answer list / voting */
        .answers-list {
            margin-top: 1rem;
        }

        .answer-card {
            background: rgba(5,5,15,0.95);
            border-radius: 10px;
            padding: 0.8rem 0.9rem;
            border: 1px solid rgba(255,255,255,0.13);
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: border-color 0.12s ease, background 0.12s ease, transform 0.12s ease;
        }

        .answer-card:hover {
            border-color: var(--accent);
            background: rgba(10, 18, 30, 0.9);
            transform: translateY(-1px);
        }

        .answer-card.selected {
            border-color: var(--gold);
            box-shadow: 0 0 10px rgba(245, 194, 92, 0.5);
        }

        .answer-card.disabled {
            cursor: default;
            opacity: 0.7;
        }

        .answer-author {
            font-size: 0.75rem;
            color: var(--text-soft);
            margin-top: 0.3rem;
        }

        .results-line {
            font-size: 0.9rem;
            margin: 0.2rem 0;
        }

        .winner-tag {
            color: var(--gold-soft);
            font-weight: 600;
        }

        /* Right Panel (Players / Scores / Log) */
        .side-card {
            background: rgba(12,12,24,0.95);
            border-radius: 14px;
            padding: 1rem 1.2rem;
            border: 1px solid rgba(255,255,255,0.12);
            box-shadow: 0 6px 24px rgba(0,0,0,0.7);
            margin-bottom: 1rem;
        }

        .side-title {
            font-size: 1rem;
            font-weight: 500;
            margin-bottom: 0.6rem;
        }

        .player-list {
            font-size: 0.88rem;
        }

        .player-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.35rem;
        }

        .player-name {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .player-badge {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #4dff8a;
        }

        .player-host-label {
            font-size: 0.7rem;
            padding: 0.1rem 0.4rem;
            border-radius: 999px;
            border: 1px solid var(--gold);
        }

        .score-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.35rem;
            font-size: 0.88rem;
        }

        .log-box {
            max-height: 150px;
            overflow-y: auto;
            font-size: 0.8rem;
            color: var(--text-soft);
        }

        .log-line {
            margin-bottom: 0.3rem;
        }

        #connectionStatus {
            font-size: 0.8rem;
            color: var(--text-soft);
            margin-top: 0.4rem;
        }
    </style>
</head>
<body>

    <div class="header">
        <div class="logo">WHO WROTE IT BETTER?</div>
        <div class="header-right">
            <div class="room-pill" id="roomInfo">Room: ?</div>
            <div class="host-tag" id="hostTag">PLAYER</div>
        </div>
    </div>

    <div class="main">
        <!-- LEFT: GAME AREA -->
        <div class="game-card">
            <div class="game-title">ROUND <span id="roundNumber">0</span></div>
            <div class="game-subtitle" id="phaseDescription">Waiting for game to start...</div>

            <div id="phaseTag" class="phase-tag phase-lobby">LOBBY</div>

            <div class="prompt-box">
                <div class="prompt-source" id="promptSource">Prompt source will appear here.</div>
                <div class="prompt-text" id="promptText">Waiting for host to start the game.</div>
            </div>

            <div class="row">
                <div class="round-label" id="roundLabel">Phase: Lobby</div>
                <div class="timer" id="timerDisplay">‚è± 0s</div>
            </div>

            <div class="status-msg" id="statusMessage">
                Waiting for host to start the first round.
            </div>

            <!-- SUBMIT PHASE UI -->
            <div id="submitArea" class="answer-input-area" style="display:none;">
                <textarea id="answerInput" class="answer-input" placeholder="Rewrite the lyric / quote..."></textarea>
                <div class="answer-buttons">
                    <button id="randomAnswerBtn" class="btn btn-ghost" type="button">
                        üé≤ Random Answer
                    </button>
                    <button id="submitAnswerBtn" class="btn btn-primary" type="button">
                        SUBMIT ANSWER
                    </button>
                </div>
            </div>

            <!-- VOTE / RESULTS PHASE UI -->
            <div id="answersArea" class="answers-list" style="display:none;"></div>

            <!-- HOST CONTROLS -->
            <div style="margin-top: 1.2rem;">
                <button id="hostStartBtn" class="btn btn-accent" type="button" style="display:none;">
                    START GAME / NEXT ROUND
                </button>
            </div>
        </div>

        <!-- RIGHT: PLAYERS / SCORES / LOG -->
        <div>
            <div class="side-card">
                <div class="side-title">Players</div>
                <div id="playersList" class="player-list">No players yet.</div>
            </div>

            <div class="side-card">
                <div class="side-title">Scores</div>
                <div id="scoresList">
                    No scores yet.
                </div>
            </div>

            <div class="side-card">
                <div class="side-title">Game Log</div>
                <div id="logBox" class="log-box"></div>
                <div id="connectionStatus">Connecting...</div>
            </div>
        </div>
    </div>

    <script src="../../multiplayer/multiplayer-core.js"></script>
    <script>
        // === CONFIG ===
        const BACKEND = "https://gunnersgames-backend.onrender.com";

        const SUBMIT_SECONDS = 40;   // time to write answers
        const VOTE_SECONDS   = 25;   // time to vote
        const RESULTS_SECONDS = 8;   // show results, then auto next

        // === State ===
        let game = null;
        let roomId = null;
        let playerId = null;
        let playerName = null;
        let isHost = false;

        let prompts = [];
        let answers = [];
        let oneWordAnswers = [];

        let currentState = {
            phase: "lobby",   // lobby | submit | vote | results
            round: 0,
            prompt: null,
            submissions: {},  // { playerId: { text, name } }
            votes: {},        // { voterId: targetPlayerId }
            scores: {},       // { playerId: score }
            lastResults: null,
            timerEnd: null,
            voteOrder: []     // array of { playerId, name, text }
        };

        let hasSubmitted = false;
        let hasVoted = false;
        let countdownInterval = null;

        // === Helpers ===
        function getQueryParam(name) {
            const params = new URLSearchParams(window.location.search);
            return params.get(name);
        }

        function log(message) {
            const box = document.getElementById("logBox");
            const line = document.createElement("div");
            line.className = "log-line";
            line.textContent = "[" + new Date().toLocaleTimeString() + "] " + message;
            box.appendChild(line);
            box.scrollTop = box.scrollHeight;
        }

        function setConnectionStatus(msg) {
            document.getElementById("connectionStatus").innerText = msg;
        }

        function setPhaseUI(phase) {
            const tag = document.getElementById("phaseTag");
            tag.className = "phase-tag phase-" + phase;
            tag.innerText = phase.toUpperCase();

            const submitArea = document.getElementById("submitArea");
            const answersArea = document.getElementById("answersArea");
            const hostStartBtn = document.getElementById("hostStartBtn");

            submitArea.style.display = "none";
            answersArea.style.display = "none";
            hostStartBtn.style.display = "none";

            const phaseDescription = document.getElementById("phaseDescription");
            const roundLabel = document.getElementById("roundLabel");
            const statusMessage = document.getElementById("statusMessage");

            if (phase === "lobby") {
                phaseDescription.innerText = "Waiting for the host to start the game.";
                roundLabel.innerText = "Phase: Lobby";
                statusMessage.innerText = isHost
                    ? "You are the host. Click START GAME to begin."
                    : "Waiting for host to start...";
                if (isHost) hostStartBtn.style.display = "inline-block";
            } else if (phase === "submit") {
                phaseDescription.innerText = "Rewrite the lyric, quote, or line.";
                roundLabel.innerText = "Phase: Answer Submission";
                statusMessage.innerText = "Type your answer and hit SUBMIT. Timer is running.";
                submitArea.style.display = "block";
            } else if (phase === "vote") {
                phaseDescription.innerText = "Vote for your favorite answer.";
                roundLabel.innerText = "Phase: Voting";
                statusMessage.innerText = "Pick the best answer. You can't vote for yourself.";
            } else if (phase === "results") {
                phaseDescription.innerText = "Round results.";
                roundLabel.innerText = "Phase: Results";
                statusMessage.innerText = "Scores updated. Next round will begin automatically.";
                if (isHost) {
                    hostStartBtn.style.display = "inline-block";
                    hostStartBtn.innerText = "START NEXT ROUND NOW";
                }
            }
        }

        function updateTimerDisplay() {
            const el = document.getElementById("timerDisplay");
            if (!currentState.timerEnd) {
                el.innerText = "‚è± 0s";
                return;
            }
            const now = Date.now();
            const remaining = Math.max(0, Math.round((currentState.timerEnd - now) / 1000));
            el.innerText = "‚è± " + remaining + "s";
        }

        function startCountdown(phase) {
            if (countdownInterval) clearInterval(countdownInterval);
            updateTimerDisplay();
            countdownInterval = setInterval(() => {
                const before = currentState.timerEnd;
                updateTimerDisplay();
                if (!currentState.timerEnd) return;
                const now = Date.now();
                if (now >= currentState.timerEnd) {
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                    // Host drives phase transitions
                    if (isHost) {
                        handlePhaseTimeout(phase);
                    }
                }
            }, 1000);
        }

        function handlePhaseTimeout(phase) {
            if (!isHost) return;

            if (phase === "submit") {
                // Move to voting or results depending on submissions
                const submissions = currentState.submissions || {};
                const submitters = Object.keys(submissions);

                if (submitters.length === 0) {
                    // No answers: show "no submissions" and move to results
                    currentState.lastResults = {
                        message: "No submissions this round.",
                        details: []
                    };
                    currentState.phase = "results";
                    currentState.timerEnd = Date.now() + RESULTS_SECONDS * 1000;
                    log("No submissions. Moving to results.");
                    game.setState(currentState);
                } else if (submitters.length === 1) {
                    // Only one answer: declare them winner by default
                    const pid = submitters[0];
                    const scores = currentState.scores || {};
                    scores[pid] = (scores[pid] || 0) + 1;
                    currentState.scores = scores;

                    currentState.lastResults = {
                        message: "Only one submission. Auto-win!",
                        details: [
                            {
                                playerId: pid,
                                name: submissions[pid].name,
                                text: submissions[pid].text,
                                votes: 1
                            }
                        ]
                    };
                    currentState.phase = "results";
                    currentState.timerEnd = Date.now() + RESULTS_SECONDS * 1000;
                    log("Single submission. Auto-win for " + submissions[pid].name);
                    game.setState(currentState);
                } else {
                    // Enough answers: build voteOrder and go to voting
                    const voteOrder = submitters.map(pid => ({
                        playerId: pid,
                        name: submissions[pid].name,
                        text: submissions[pid].text
                    }));
                    // Shuffle order
                    for (let i = voteOrder.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [voteOrder[i], voteOrder[j]] = [voteOrder[j], voteOrder[i]];
                    }
                    currentState.voteOrder = voteOrder;
                    currentState.votes = {};
                    currentState.phase = "vote";
                    currentState.timerEnd = Date.now() + VOTE_SECONDS * 1000;
                    log("Submissions in. Moving to voting.");
                    game.setState(currentState);
                }
            } else if (phase === "vote") {
                // Tally votes and move to results
                const votes = currentState.votes || {};
                const submissions = currentState.submissions || {};
                const scores = currentState.scores || {};

                const voteCount = {};
                Object.values(votes).forEach(targetId => {
                    if (!targetId) return;
                    voteCount[targetId] = (voteCount[targetId] || 0) + 1;
                });

                const details = [];
                let maxVotes = 0;
                for (const [pid, sub] of Object.entries(submissions)) {
                    const count = voteCount[pid] || 0;
                    details.push({
                        playerId: pid,
                        name: sub.name,
                        text: sub.text,
                        votes: count
                    });
                    if (count > maxVotes) maxVotes = count;
                }

                // Update scores: 1 point per vote here
                for (const [pid, count] of Object.entries(voteCount)) {
                    scores[pid] = (scores[pid] || 0) + count;
                }

                currentState.scores = scores;
                currentState.lastResults = {
                    message: Object.keys(votes).length === 0
                        ? "No votes cast this round."
                        : "Round complete.",
                    details: details
                };
                currentState.phase = "results";
                currentState.timerEnd = Date.now() + RESULTS_SECONDS * 1000;
                log("Votes tallied. Moving to results.");
                game.setState(currentState);
            } else if (phase === "results") {
                // Auto-start next round
                log("Results phase done. Auto-starting next round.");
                hostStartNewRound();
            }
        }

        // === Prompt & Answer selection ===
        function pickRandomPrompt() {
            if (!prompts.length) return null;
            const idx = Math.floor(Math.random() * prompts.length);
            return prompts[idx];
        }

        function pickRandomAnswerText() {
            const pool = [];
            if (answers && answers.length) {
                pool.push(...answers.map(a => a.text));
            }
            if (oneWordAnswers && oneWordAnswers.length) {
                pool.push(...oneWordAnswers.map(a => a.text));
            }
            if (!pool.length) return "";
            const idx = Math.floor(Math.random() * pool.length);
            return pool[idx];
        }

        // === UI render functions ===
        function renderPrompt() {
            const pEl = document.getElementById("promptText");
            const sEl = document.getElementById("promptSource");
            if (!currentState.prompt) {
                pEl.innerText = "Waiting for host to start the game.";
                sEl.innerText = "";
                return;
            }
            const p = currentState.prompt;
            pEl.innerText = p.text || "[blank prompt]";
            let source = "";
            if (p.category) source += p.category.toUpperCase();
            if (p.source) source += (source ? " ‚Ä¢ " : "") + p.source;
            if (p.pack) source += (source ? " ‚Ä¢ " : "") + p.pack;
            if (p.rating) source += (source ? " ‚Ä¢ " : "") + "Rated " + p.rating;
            sEl.innerText = source || "Prompt";
        }

        function renderPlayers(roomData) {
            const listEl = document.getElementById("playersList");
            if (!roomData || !roomData.players || !roomData.players.length) {
                listEl.innerText = "No players yet.";
                return;
            }
            listEl.innerHTML = "";
            roomData.players.forEach(p => {
                const row = document.createElement("div");
                row.className = "player-row";

                const left = document.createElement("div");
                left.className = "player-name";

                const badge = document.createElement("div");
                badge.className = "player-badge";
                left.appendChild(badge);

                const nameSpan = document.createElement("span");
                nameSpan.innerText = p.player_name || "Unknown";
                left.appendChild(nameSpan);

                if (roomData.room && roomData.room.host_id === p.player_id) {
                    const hostLabel = document.createElement("span");
                    hostLabel.className = "player-host-label";
                    hostLabel.innerText = "HOST";
                    left.appendChild(hostLabel);
                }

                const right = document.createElement("div");
                right.innerText = "";

                row.appendChild(left);
                row.appendChild(right);

                listEl.appendChild(row);
            });
        }

        function renderScores() {
            const scoresEl = document.getElementById("scoresList");
            const scores = currentState.scores || {};
            const entries = Object.entries(scores);
            if (!entries.length) {
                scoresEl.innerText = "No scores yet.";
                return;
            }
            scoresEl.innerHTML = "";
            entries.sort((a, b) => b[1] - a[1]);
            entries.forEach(([pid, score]) => {
                const row = document.createElement("div");
                row.className = "score-row";
                const name = pid === playerId ? (playerName + " (You)") : pid;
                row.innerHTML = `<span>${name}</span><span>${score}</span>`;
                scoresEl.appendChild(row);
            });
        }

        function renderVotingAnswers() {
            const container = document.getElementById("answersArea");
            container.innerHTML = "";
            const phase = currentState.phase;
            if (phase !== "vote" && phase !== "results") {
                container.style.display = "none";
                return;
            }

            const voteOrder = currentState.voteOrder || [];
            if (!voteOrder.length) {
                container.innerHTML = "<div style='font-size:0.9rem; color:var(--text-soft);'>No answers to show.</div>";
                container.style.display = "block";
                return;
            }

            container.style.display = "block";

            const votes = currentState.votes || {};
            const myVote = votes[playerId] || null;
            hasVoted = !!myVote;

            const last = currentState.lastResults;

            voteOrder.forEach(entry => {
                const card = document.createElement("div");
                card.className = "answer-card";

                const main = document.createElement("div");
                main.innerText = entry.text;
                card.appendChild(main);

                const author = document.createElement("div");
                author.className = "answer-author";
                let label = entry.name || "Player";
                if (entry.playerId === playerId) label += " (You)";
                author.innerText = label;
                card.appendChild(author);

                const isMe = entry.playerId === playerId;

                if (phase === "vote") {
                    if (isMe) {
                        card.classList.add("disabled");
                        card.style.opacity = "0.6";
                    } else {
                        card.addEventListener("click", () => {
                            handleVote(entry.playerId, card);
                        });
                    }
                    if (myVote === entry.playerId) {
                        card.classList.add("selected");
                    }
                }

                if (phase === "results" && last && last.details) {
                    const detail = last.details.find(d => d.playerId === entry.playerId);
                    if (detail) {
                        const rLine = document.createElement("div");
                        rLine.className = "results-line";
                        rLine.innerText = `Votes: ${detail.votes}`;
                        if (detail.votes === Math.max(...last.details.map(d => d.votes))) {
                            rLine.classList.add("winner-tag");
                            rLine.innerText += "  ‚Üê Winner";
                        }
                        card.appendChild(rLine);
                    }
                    card.classList.add("disabled");
                }

                container.appendChild(card);
            });
        }

        // === Actions ===
        function handleSubmit() {
            if (hasSubmitted) {
                alert("You already submitted this round.");
                return;
            }
            if (currentState.phase !== "submit") {
                alert("It's not submission time right now.");
                return;
            }
            const input = document.getElementById("answerInput");
            const text = input.value.trim();
            if (!text) {
                alert("Type an answer first.");
                return;
            }

            hasSubmitted = true;
            document.getElementById("submitAnswerBtn").disabled = true;
            input.disabled = true;

            game.sendAction("submitAnswer", { text });
            log("You submitted an answer.");
        }

        function handleVote(targetPlayerId, cardElem) {
            if (hasVoted) {
                alert("You already voted this round.");
                return;
            }
            if (currentState.phase !== "vote") {
                alert("It's not voting time right now.");
                return;
            }
            if (!targetPlayerId) return;

            hasVoted = true;
            game.sendAction("voteAnswer", { targetPlayerId });
            log("You cast your vote.");

            // Highlight selection locally
            const all = document.querySelectorAll(".answer-card");
            all.forEach(c => c.classList.remove("selected"));
            cardElem.classList.add("selected");
        }

        function hostStartNewRound() {
            if (!isHost) return;

            const nextRound = (currentState.round || 0) + 1;
            const prompt = pickRandomPrompt();
            if (!prompt) {
                alert("No prompts loaded yet.");
                return;
            }

            const now = Date.now();
            currentState = {
                phase: "submit",
                round: nextRound,
                prompt: prompt,
                submissions: {},
                votes: {},
                scores: currentState.scores || {},
                lastResults: null,
                timerEnd: now + SUBMIT_SECONDS * 1000,
                voteOrder: []
            };

            game.setRoomStatus("playing").catch(() => {});
            log("Starting round " + nextRound + " as host.");
            game.setState(currentState);
        }

        // === Apply state from backend ===
        function applyState(state) {
            if (!state || !state.phase) {
                currentState.phase = "lobby";
                currentState.round = 0;
                currentState.prompt = null;
                currentState.submissions = {};
                currentState.votes = {};
                currentState.scores = {};
                currentState.lastResults = null;
                currentState.timerEnd = null;
                currentState.voteOrder = [];
            } else {
                currentState = state;
            }

            document.getElementById("roundNumber").innerText = currentState.round || 0;

            setPhaseUI(currentState.phase);
            renderPrompt();
            renderScores();
            renderVotingAnswers();

            // Reset local flags each round
            if (currentState.phase === "submit") {
                hasSubmitted = !!(currentState.submissions && currentState.submissions[playerId]);
                const input = document.getElementById("answerInput");
                const submitBtn = document.getElementById("submitAnswerBtn");
                if (hasSubmitted) {
                    input.disabled = true;
                    submitBtn.disabled = true;
                } else {
                    input.disabled = false;
                    submitBtn.disabled = false;
                    input.value = "";
                }
            }

            if (currentState.phase === "vote") {
                const myVote = (currentState.votes && currentState.votes[playerId]) || null;
                hasVoted = !!myVote;
            }

            if (currentState.phase === "results" && currentState.lastResults) {
                const msg = currentState.lastResults.message || "Round complete.";
                document.getElementById("statusMessage").innerText = msg;
            }

            if (currentState.phase === "lobby" || !currentState.timerEnd) {
                if (countdownInterval) clearInterval(countdownInterval);
                document.getElementById("timerDisplay").innerText = "‚è± 0s";
            } else {
                startCountdown(currentState.phase);
            }
        }

        // === Init ===
        async function init() {
            // Room / player info from lobby
            roomId = getQueryParam("room") || sessionStorage.getItem("currentRoom") || "room1";
            playerId = sessionStorage.getItem("currentPlayerId") || localStorage.getItem("gg_playerId");
            playerName = sessionStorage.getItem("currentPlayerName") || localStorage.getItem("gg_playerName") || "Player";

            if (!playerId) {
                playerId = "p_" + Math.random().toString(36).substr(2, 9);
                localStorage.setItem("gg_playerId", playerId);
            }

            document.getElementById("roomInfo").innerText = "Room: " + roomId;
            log("Joining " + roomId + " as " + playerName);

            // Load data
            try {
                const [p, a, o] = await Promise.all([
                    fetch("data/prompts.json").then(r => r.json()),
                    fetch("data/answers.json").then(r => r.json()),
                    fetch("data/one_word_answers.json")
                        .then(r => r.json())
                        .catch(() => ({ oneWordAnswers: [] }))
                ]);
                prompts = p.prompts || [];
                answers = a.answers || [];
                oneWordAnswers = o.oneWordAnswers || [];
                log(`Loaded ${prompts.length} prompts, ${answers.length} answers, ${oneWordAnswers.length} one-word answers.`);
            } catch (err) {
                console.error(err);
                log("Error loading prompt/answer data.");
            }

            // Setup multiplayer game
            game = new MultiplayerGame({
                roomId,
                playerId,
                playerName,
                onLog: (msg, extra) => {
                    if (extra) log(msg + " " + JSON.stringify(extra));
                    else log(msg);
                },
                onError: (err) => {
                    console.error(err);
                    log("Error: " + err.message);
                    setConnectionStatus("Error: " + err.message);
                },
                onConnected: () => {
                    log("WebSocket connected.");
                    setConnectionStatus("Connected.");
                },
                onDisconnected: (info) => {
                    log("Disconnected: " + JSON.stringify(info));
                    setConnectionStatus("Disconnected. Trying to reconnect...");
                },
                onRoomUpdate: (roomData) => {
                    if (!roomData || !roomData.room) return;
                    const r = roomData.room;
                    const hostId = r.host_id;
                    isHost = (hostId === playerId);
                    document.getElementById("hostTag").innerText = isHost ? "HOST" : "PLAYER";
                    renderPlayers(roomData);

                    // If backend sends state as part of room data
                    if (roomData.state) {
                        applyState(roomData.state);
                    }
                },
                onStateUpdate: (state) => {
                    applyState(state);
                },
                onAction: ({ playerId: fromId, action }) => {
                    if (!action) return;
                    if (action.actionType === "submitAnswer") {
                        const text = (action.payload && action.payload.text) || "";
                        if (!text) return;
                        // We don't know the name here; host gets it from room players or store last
                        // For simplicity, non-host just logs it; host updates canonical state.
                        if (isHost && currentState.phase === "submit") {
                            // Find player name from last room players snapshot? We'll approximate:
                            const name = (fromId === playerId) ? playerName : ("Player " + fromId.substr(0, 4));
                            currentState.submissions[fromId] = {
                                text,
                                name
                            };
                            game.setState(currentState);
                        }
                    } else if (action.actionType === "voteAnswer") {
                        const target = (action.payload && action.payload.targetPlayerId) || null;
                        if (isHost && currentState.phase === "vote" && target) {
                            currentState.votes[fromId] = target;
                            game.setState(currentState);
                        }
                    }
                }
            });

            document.getElementById("hostStartBtn").addEventListener("click", () => {
                if (!isHost) {
                    alert("Only the host can start rounds.");
                    return;
                }
                hostStartNewRound();
            });

            document.getElementById("submitAnswerBtn").addEventListener("click", handleSubmit);
            document.getElementById("randomAnswerBtn").addEventListener("click", () => {
                const input = document.getElementById("answerInput");
                input.value = pickRandomAnswerText();
            });

            await game.connect();

            // Get latest state on join
            try {
                const state = await game.fetchState();
                applyState(state);
            } catch (err) {
                log("No existing game state. Waiting for host.");
            }
        }

        window.addEventListener("load", init);
    </script>
</body>
</html>
