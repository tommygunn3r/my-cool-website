<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Who Said It Better? - GunnersGames</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Cinzel:wght@400;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg: #1a1a1a;
            --bg-alt: #2a2a2a;
            --card-bg: #333;
            --gold: #FFD700;
            --gold-soft: #fbe1a5;
            --accent: #4CAF50;
            --accent-soft: rgba(76, 175, 80, 0.2);
            --danger: #ff4444;
            --success: #4CAF50;
            --text-main: #f5f5f5;
            --text-soft: #b0b0c0;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding-top: 60px;
            background: #1a1a1a;
            color: var(--text-main);
            font-family: "Roboto", sans-serif;
            min-height: 100vh;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem 1.8rem;
            background: #2a2a2a;
            border-bottom: 2px solid #333;
            box-shadow: 0 4px 18px rgba(0,0,0,0.5);
        }

        .logo {
            display: flex;
            align-items: center;
            flex: 1;
        }
        
        .logo img {
            height: 100px;
            max-width: 100%;
            width: fit-content;
            display: block;
        }
        
        @media (max-width: 900px) {
            .logo img {
                height: 80px;
            }
        }
        
        @media (max-width: 600px) {
            .logo img {
                height: 60px;
            }
        }

        .header-right {
            display: flex;
            gap: 1.2rem;
            align-items: center;
        }

        .room-pill {
            padding: 0.4rem 0.9rem;
            border-radius: 999px;
            background: rgba(0,0,0,0.4);
            border: 1px solid rgba(255,255,255,0.2);
            font-size: 0.85rem;
        }

        .host-tag {
            display: none; /* Removed per user request */
        }

        .main {
            max-width: 1400px;
            margin: 1.8rem auto 3rem;
            padding: 0 1rem;
            display: grid;
            grid-template-columns: minmax(0, 2.5fr) minmax(0, 1fr);
            gap: 1.5rem;
        }

        @media (max-width: 900px) {
            .main {
                grid-template-columns: 1fr;
            }
        }

        .game-area {
            background: var(--bg-alt);
            border-radius: 12px;
            padding: 1.8rem;
            box-shadow: 0 4px 24px rgba(0,0,0,0.6);
        }

        .round-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .round-label {
            font-size: 1.1rem;
            font-weight: 500;
            color: var(--gold);
        }

        .phase-tag {
            padding: 0.3rem 0.8rem;
            border-radius: 6px;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-weight: bold;
        }

        .phase-lobby { background: rgba(255,255,255,0.1); }
        .phase-submit { background: rgba(76, 175, 80, 0.3); border: 1px solid var(--accent); }
        .phase-vote { background: rgba(255, 193, 7, 0.3); border: 1px solid #FFC107; }
        .phase-results { background: rgba(33, 150, 243, 0.3); border: 1px solid #2196F3; }

        .prompt-box {
            background: #000000;
            border: 2px solid #FFD700;
            border-radius: 12px;
            padding: 1.8rem;
            margin-bottom: 1.5rem;
            text-align: center;
            box-shadow: 0 4px 12px rgba(255, 215, 0, 0.3);
        }

        .prompt-source {
            font-size: 0.85rem;
            color: var(--gold);
            margin-bottom: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .prompt-text {
            font-size: 1.4rem;
            line-height: 1.6;
            color: var(--text-main);
            font-weight: 500;
        }

        .blank {
            color: var(--gold);
            font-weight: bold;
            text-decoration: underline;
        }

        /* CARD SELECTION UI */
        .hand-area {
            margin: 1.5rem 0;
        }

        .hand-title {
            font-size: 0.9rem;
            color: var(--text-soft);
            margin-bottom: 1rem;
            text-align: center;
        }

        .cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .answer-card {
            background: white;
            color: #000;
            border-radius: 8px;
            padding: 1.2rem;
            min-height: 140px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 0.95rem;
            line-height: 1.4;
            cursor: pointer;
            transition: all 0.2s;
            border: 3px solid transparent;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .answer-card:hover {
            transform: translateY(-4px) rotate(-2deg);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.4);
            border-color: var(--gold);
        }

        .answer-card.selected {
            border-color: var(--accent);
            background: #e8f5e9;
            transform: translateY(-4px) rotate(2deg);
        }

        .answer-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .answer-card.disabled:hover {
            transform: none;
        }

        /* VOTING UI */
        .voting-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .vote-card {
            background: white;
            color: #000;
            border: 3px solid transparent;
            border-radius: 8px;
            padding: 1.2rem;
            min-height: 160px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            position: relative;
        }

        .vote-card:hover {
            border-color: var(--gold);
            transform: translateY(-4px) rotate(-1.5deg);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.4);
        }

        .vote-card.voted {
            border-color: var(--accent);
            background: #e8f5e9;
            transform: translateY(-4px) rotate(1.5deg);
        }

        .vote-card.own-answer {
            opacity: 0.6;
            cursor: not-allowed;
            border-color: transparent;
        }
        
        .vote-card.own-answer:hover {
            transform: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .vote-card-text {
            font-size: 1rem;
            margin-bottom: 0.8rem;
            line-height: 1.4;
            flex: 1;
            display: flex;
            align-items: center;
        }

        .vote-card-player {
            font-size: 0.75rem;
            color: #666;
            font-style: italic;
        }

        .vote-count {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: var(--gold);
            color: #000;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: bold;
        }

        /* RESULTS */
        .results-area {
            margin-top: 1.5rem;
        }

        .winner-card {
            background: linear-gradient(135deg, var(--gold) 0%, #f0c420 100%);
            color: #000;
            border-radius: 12px;
            padding: 1.8rem;
            text-align: center;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 20px rgba(255, 215, 0, 0.4);
        }

        .winner-title {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
        }

        .winner-name {
            font-size: 1.8rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .winner-answer {
            font-size: 1.1rem;
            font-style: italic;
        }

        /* BUTTONS */
        .btn {
            padding: 0.8rem 1.8rem;
            border: none;
            border-radius: 6px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .btn-primary {
            background: var(--accent);
            color: white;
        }

        .btn-primary:hover {
            background: #45a049;
            transform: translateY(-2px);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-danger:hover {
            background: #e63939;
        }

        /* SETTINGS MODAL */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--bg-alt);
            border-radius: 12px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 8px 32px rgba(0,0,0,0.8);
        }

        .modal-title {
            font-size: 1.5rem;
            margin-bottom: 1.5rem;
            color: var(--gold);
        }

        .setting-group {
            margin-bottom: 1.5rem;
        }

        .setting-label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.95rem;
            color: var(--text-soft);
        }

        .setting-input {
            width: 100%;
            padding: 0.8rem;
            background: var(--card-bg);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            color: var(--text-main);
            font-size: 1rem;
        }

        .modal-buttons {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            margin-top: 2rem;
        }

        /* SIDE PANELS */
        .side-card {
            background: var(--bg-alt);
            border-radius: 12px;
            padding: 1.2rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 18px rgba(0,0,0,0.5);
        }

        .side-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--gold);
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .player-list {
            display: flex;
            flex-direction: column;
            gap: 0.6rem;
        }

        .player-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.6rem 0.8rem;
            background: var(--card-bg);
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .player-ready {
            color: var(--accent);
            font-size: 0.8rem;
        }

        .scores-list {
            display: flex;
            flex-direction: column;
            gap: 0.6rem;
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            padding: 0.6rem 0.8rem;
            background: var(--card-bg);
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .score-value {
            color: var(--gold);
            font-weight: bold;
        }

        .log-box {
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.8rem;
            color: var(--text-soft);
            background: var(--card-bg);
            padding: 0.8rem;
            border-radius: 6px;
            /* Hidden by default, shown only for host */
            display: none;
        }
        
        .log-box.host-only {
            display: block;
        }

        .log-entry {
            margin-bottom: 0.4rem;
            line-height: 1.4;
        }

        .connection-status {
            margin-top: 0.8rem;
            text-align: center;
            font-size: 0.75rem;
            padding: 0.4rem;
            border-radius: 6px;
        }

        .connection-status.connected {
            background: var(--accent-soft);
            color: var(--accent);
        }

        .connection-status.normal {
            background: rgba(255,255,255,0.05);
            color: var(--text-soft);
        }

        .status-msg {
            text-align: center;
            padding: 1rem;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            margin: 1rem 0;
            color: var(--text-soft);
        }

        /* FINAL RESULTS OVERLAY */
        .final-results-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }

        .final-results-overlay.active {
            display: flex;
        }

        .final-results-content {
            background: linear-gradient(135deg, var(--bg-alt) 0%, var(--bg) 100%);
            border: 3px solid var(--gold);
            border-radius: 20px;
            padding: 3rem;
            max-width: 800px;
            width: 100%;
            text-align: center;
            box-shadow: 0 10px 50px rgba(255, 215, 0, 0.3);
        }

        .final-results-title {
            font-size: 3rem;
            font-weight: bold;
            color: var(--gold);
            margin-bottom: 2rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .final-results-podium {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin: 2rem 0;
            flex-wrap: wrap;
        }

        .podium-place {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 2rem 1.5rem;
            min-width: 200px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .podium-place.first {
            border-color: var(--gold);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1) 0%, var(--card-bg) 100%);
            transform: scale(1.1);
        }

        .podium-place.second {
            border-color: #C0C0C0;
        }

        .podium-place.third {
            border-color: #CD7F32;
        }

        .podium-rank {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .podium-rank.first { color: var(--gold); }
        .podium-rank.second { color: #C0C0C0; }
        .podium-rank.third { color: #CD7F32; }

        .podium-name {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
            color: var(--text-main);
        }

        .podium-score {
            font-size: 2rem;
            font-weight: bold;
            color: var(--gold);
        }

        .final-results-button {
            margin-top: 2rem;
            padding: 1rem 3rem;
            font-size: 1.2rem;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            text-transform: uppercase;
            font-weight: bold;
            letter-spacing: 0.1em;
            transition: all 0.3s;
        }

        .final-results-button:hover {
            background: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }
    </style>
</head>
<body>
    <!-- FINAL RESULTS OVERLAY -->
    <div id="finalResultsOverlay" class="final-results-overlay">
        <div class="final-results-content">
            <div class="final-results-title" id="finalResultsTitle">üéâ GAME OVER! üéâ</div>
            <div class="final-results-podium" id="finalResultsPodium"></div>
            <button class="final-results-button" onclick="returnToLobby()">RETURN TO LOBBY</button>
        </div>
    </div>
    <!-- HEADER -->
    <div class="header">
        <div class="logo">
            <img src="wsib.png" alt="Who Said It Better?">
        </div>
        <div class="header-right">
            <div class="room-pill" id="roomInfo">Room: Loading...</div>
            <div class="host-tag" id="hostTag">PLAYER</div>
        </div>
    </div>

    <!-- GAME SETTINGS MODAL -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <div class="modal-title">Game Settings</div>
            <div class="setting-group">
                <label class="setting-label">Number of Rounds</label>
                <select id="roundsInput" class="setting-input">
                    <option value="3">3 Rounds</option>
                    <option value="5" selected>5 Rounds</option>
                    <option value="7">7 Rounds</option>
                    <option value="10">10 Rounds</option>
                </select>
            </div>
            <div class="setting-group">
                <label class="setting-label">Hand Size (cards per player)</label>
                <select id="handSizeInput" class="setting-input">
                    <option value="5">5 Cards</option>
                    <option value="7" selected>7 Cards</option>
                    <option value="10">10 Cards</option>
                </select>
            </div>
            <div class="setting-group">
                <label class="setting-label">Content Rating</label>
                <select id="ratingInput" class="setting-input">
                    <option value="all" selected>All Ratings</option>
                    <option value="G">G - Family Friendly</option>
                    <option value="PG-13">PG-13 - Teens+</option>
                    <option value="R">R - Mature</option>
                    <option value="NSFW">NSFW - Adults Only</option>
                </select>
            </div>
            <div class="setting-group">
                <label class="setting-label">Prompt Theme/Pack</label>
                <select id="packInput" class="setting-input">
                    <option value="all" selected>All Themes</option>
                    <optgroup label="Music - Pop">
                        <option value="pop-hits">Pop Hits</option>
                        <option value="pop-70s">Pop 70s</option>
                        <option value="pop-80s">Pop 80s</option>
                        <option value="pop-90s">Pop 90s</option>
                        <option value="pop-00s">Pop 00s</option>
                        <option value="80s-pop">80s Pop</option>
                    </optgroup>
                    <optgroup label="Music - Rock">
                        <option value="classic-rock">Classic Rock</option>
                        <option value="rock-70s">Rock 70s</option>
                        <option value="rock-80s">Rock 80s</option>
                        <option value="rock-90s">Rock 90s</option>
                        <option value="alt-90s">Alternative 90s</option>
                        <option value="grunge-90s">Grunge 90s</option>
                    </optgroup>
                    <optgroup label="Music - Other">
                        <option value="hip-hop">Hip Hop</option>
                        <option value="country">Country</option>
                        <option value="country-crossover">Country Crossover</option>
                        <option value="disco">Disco</option>
                        <option value="r&b">R&B</option>
                        <option value="one-hit-wonder">One Hit Wonders</option>
                    </optgroup>
                    <optgroup label="Movies">
                        <option value="movie-80s">Movies - 80s</option>
                        <option value="movie-90s">Movies - 90s</option>
                        <option value="movie-00s">Movies - 00s</option>
                        <option value="movie-cult">Cult Movies</option>
                    </optgroup>
                    <optgroup label="TV Shows">
                        <option value="tv-sitcom">TV Sitcoms</option>
                        <option value="tv-drama">TV Dramas</option>
                    </optgroup>
                    <optgroup label="Other">
                        <option value="political">Political Quotes</option>
                        <option value="historical">Historical Quotes</option>
                        <option value="science">Science</option>
                        <option value="modern-meme">Modern Memes</option>
                    </optgroup>
                </select>
            </div>
            <div class="modal-buttons">
                <button class="btn btn-primary" onclick="saveSettings()">Save & Start Game</button>
                <button class="btn btn-danger" onclick="closeSettings()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- MAIN GAME AREA -->
    <div class="main">
        <!-- LEFT: GAME AREA -->
        <div class="game-area">
            <div class="round-info">
                <div class="round-label" id="roundLabel">Round <span id="roundNumber">0</span> of <span id="totalRounds">5</span></div>
                <div class="phase-tag phase-lobby" id="phaseTag">LOBBY</div>
            </div>

            <!-- PROMPT DISPLAY -->
            <div class="prompt-box" id="promptBox" style="display:none;">
                <div class="prompt-source" id="promptSource">Source</div>
                <div class="prompt-text" id="promptText">Prompt text here</div>
            </div>

            <div class="status-msg" id="statusMessage">
                Waiting for host to start the game.
            </div>

            <!-- HAND OF CARDS (SUBMIT PHASE) -->
            <div id="handArea" class="hand-area" style="display:none;">
                <div class="hand-title">Select your answer card:</div>
                <div class="cards-grid" id="cardsGrid"></div>
                <div style="text-align: center;">
                    <button id="confirmCardBtn" class="btn btn-primary" style="display:none;" onclick="submitCard()">
                        CONFIRM SELECTION
                    </button>
                </div>
            </div>

            <!-- VOTING AREA -->
            <div id="votingArea" style="display:none;">
                <div class="hand-title">Vote for the best answer:</div>
                <div class="voting-grid" id="votingGrid"></div>
            </div>

            <!-- RESULTS AREA -->
            <div id="resultsArea" style="display:none;"></div>

            <!-- HOST CONTROLS -->
            <div style="margin-top: 1.2rem; text-align: center;">
                <button id="hostSettingsBtn" class="btn btn-primary" type="button" style="display:none;" onclick="openSettings()">
                    ‚öôÔ∏è GAME SETTINGS
                </button>
                <button id="hostStartBtn" class="btn btn-primary" type="button" style="display:none;">
                    START NEXT ROUND
                </button>
                <button id="endGameBtn" class="btn btn-danger" type="button" style="display:none;">
                    END GAME
                </button>
            </div>
        </div>

        <!-- RIGHT: PLAYERS / SCORES / LOG -->
        <div>
            <div class="side-card">
                <div class="side-title">Players</div>
                <div id="playersList" class="player-list">Loading...</div>
            </div>

            <div class="side-card">
                <div class="side-title">Scores</div>
                <div id="scoresList" class="scores-list">
                    No scores yet.
                </div>
            </div>

            <div class="side-card">
                <div class="side-title">Game Log</div>
                <div id="logBox" class="log-box"></div>
                <div class="connection-status" id="connectionStatus">Connecting...</div>
            </div>
        </div>
    </div>

    <script>
        // === SUPABASE CONFIG ===
        const SUPABASE_URL = 'https://pknhslxhpohrzgsfkisr.supabase.co';
        const SUPABASE_ANON_KEY = 'sb_publishable_-zZw-pi_3q1sdNGhITKuhQ_ECyDARzc';
        const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // === STATE ===
        let roomId = null;
        let currentUser = null;
        let myPlayerId = null;
        let myPlayerName = null;
        let isHost = false;

        let prompts = [];
        let answers = [];

        let currentState = {
            phase: "lobby",
            round: 0,
            totalRounds: 5,
            handSize: 7,
            rating: 'all',
            pack: 'all',
            prompt: null,
            playerHands: {}, // { playerId: [card indices] }
            submissions: {}, // { playerId: answerIndex }
            votes: {}, // { playerId: targetPlayerId }
            scores: {}, // { playerId: score }
            roundWinner: null
        };

        let myHand = [];
        let selectedCardIndex = null;
        let hasSubmitted = false;
        let hasVoted = false;
        let isCleaningUp = false; // Flag to prevent saves during cleanup

        let gameStateChannel = null;
        let playersChannel = null;

        // === HELPERS ===
        function getQueryParam(name) {
            const params = new URLSearchParams(window.location.search);
            return params.get(name);
        }

        function log(msg) {
            const logBox = document.getElementById('logBox');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            const time = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
            entry.textContent = `[${time}] ${msg}`;
            logBox.appendChild(entry);
            logBox.scrollTop = logBox.scrollHeight;
        }

        function setConnectionStatus(msg, status = 'normal') {
            const el = document.getElementById('connectionStatus');
            el.textContent = msg;
            el.className = 'connection-status ' + status;
        }

        // === SETTINGS MODAL ===
        function openSettings() {
            document.getElementById('settingsModal').classList.add('active');
        }

        function closeSettings() {
            document.getElementById('settingsModal').classList.remove('active');
        }

        function saveSettings() {
            const totalRounds = parseInt(document.getElementById('roundsInput').value);
            const handSize = parseInt(document.getElementById('handSizeInput').value);
            const rating = document.getElementById('ratingInput').value;
            const pack = document.getElementById('packInput').value;
            
            currentState.totalRounds = totalRounds;
            currentState.handSize = handSize;
            currentState.rating = rating;
            currentState.pack = pack;
            
            log(`Settings: ${totalRounds} rounds, ${handSize} cards, ${rating} rating, ${pack} pack`);
            
            closeSettings();
            hostStartNewRound();
        }

        // === LOAD DATA ===
        async function loadGameData() {
            try {
                const [promptsRes, answersRes] = await Promise.all([
                    fetch('prompts.json'),
                    fetch('answers.json')
                ]);
                
                if (!promptsRes.ok || !answersRes.ok) {
                    throw new Error('Failed to load JSON files');
                }
                
                const promptsData = await promptsRes.json();
                const answersData = await answersRes.json();
                
                prompts = promptsData.prompts || [];
                answers = answersData.answers || [];
                
                log(`Loaded ${prompts.length} prompts, ${answers.length} answers.`);
            } catch (error) {
                console.error('Error loading game data:', error);
                alert('Failed to load game data. Please make sure prompts.json and answers.json are in the same folder as this game.');
            }
        }

        // Store loaded players for name lookup
        let loadedPlayers = {};

        // === PLAYER MANAGEMENT ===
        async function loadPlayers() {
            const { data, error } = await supabaseClient
                .from('room_players')
                .select('*')
                .eq('room_id', roomId)
                .order('joined_at', { ascending: true });

            if (error) {
                console.error('Error loading players:', error);
                return;
            }

            // Store for name lookups
            loadedPlayers = {};
            data.forEach(p => {
                loadedPlayers[p.user_id] = p.player_name;
            });

            const playersList = document.getElementById('playersList');
            playersList.innerHTML = '';

            data.forEach(p => {
                const div = document.createElement('div');
                div.className = 'player-item';
                div.dataset.playerId = p.user_id;
                
                const name = document.createElement('span');
                name.textContent = p.player_name;
                
                const status = document.createElement('span');
                status.className = 'player-ready';
                
                // Show if player has submitted/voted
                if (currentState.phase === 'submit' && currentState.submissions[p.user_id]) {
                    status.textContent = '‚úì Submitted';
                } else if (currentState.phase === 'vote' && currentState.votes[p.user_id]) {
                    status.textContent = '‚úì Voted';
                } else {
                    status.textContent = '';
                }
                
                div.appendChild(name);
                div.appendChild(status);
                playersList.appendChild(div);
            });
        }

        function renderScores() {
            const scoresList = document.getElementById('scoresList');
            const scores = currentState.scores || {};
            
            if (Object.keys(scores).length === 0) {
                scoresList.innerHTML = 'No scores yet.';
                return;
            }

            // Sort by score descending
            const sorted = Object.entries(scores).sort((a, b) => b[1] - a[1]);
            
            scoresList.innerHTML = '';
            sorted.forEach(([playerId, score]) => {
                const div = document.createElement('div');
                div.className = 'score-item';
                
                // Get player name
                const playerName = getPlayerName(playerId);
                
                const name = document.createElement('span');
                name.textContent = playerName;
                
                const scoreVal = document.createElement('span');
                scoreVal.className = 'score-value';
                scoreVal.textContent = score;
                
                div.appendChild(name);
                div.appendChild(scoreVal);
                scoresList.appendChild(div);
            });
        }

        function getPlayerName(playerId) {
            // Try stored players first
            if (loadedPlayers[playerId]) {
                return loadedPlayers[playerId];
            }
            
            // Try to get from DOM
            const playerEl = Array.from(document.querySelectorAll('.player-item'))
                .find(el => el.dataset.playerId === playerId);
            if (playerEl) return playerEl.querySelector('span').textContent;
            
            // Fallback to shortened ID
            return playerId.substring(0, 9);
        }

        // === CARD DEALING ===
        // How it works:
        // 1. Each player gets a persistent hand of cards (default 7)
        // 2. Cards are dealt randomly from answers.json
        // 3. No two players can have the same card at the same time
        // 4. When a player submits a card, it's removed from their hand
        // 5. At the start of next round, their hand is refilled with new random cards
        // 6. This ensures players always have fresh cards while maintaining uniqueness
        function dealCards() {
            const handSize = currentState.handSize || 7;
            const usedIndices = new Set();
            
            // Collect all currently dealt cards across all players
            Object.values(currentState.playerHands).forEach(hand => {
                hand.forEach(idx => usedIndices.add(idx));
            });

            // For each player, ensure they have a full hand
            const players = Object.keys(currentState.scores || {});
            players.forEach(playerId => {
                if (!currentState.playerHands[playerId]) {
                    currentState.playerHands[playerId] = [];
                }
                
                const hand = currentState.playerHands[playerId];
                
                // Remove any invalid card indices
                const validHand = hand.filter(idx => answers[idx]);
                currentState.playerHands[playerId] = validHand;
                
                // Deal new random cards to fill hand up to handSize
                while (validHand.length < handSize) {
                    let newIdx;
                    let attempts = 0;
                    do {
                        newIdx = Math.floor(Math.random() * answers.length);
                        attempts++;
                    } while (usedIndices.has(newIdx) && attempts < 100);
                    
                    if (attempts < 100) {
                        validHand.push(newIdx);
                        usedIndices.add(newIdx);
                    } else {
                        break; // Safety: avoid infinite loop if running out of cards

                    }
                }
            });
        }

        // === GAME PHASES ===
        function setPhaseUI(phase) {
            const tag = document.getElementById("phaseTag");
            tag.className = "phase-tag phase-" + phase;
            tag.innerText = phase.toUpperCase().replace('_', ' ');

            const promptBox = document.getElementById("promptBox");
            const handArea = document.getElementById("handArea");
            const votingArea = document.getElementById("votingArea");
            const resultsArea = document.getElementById("resultsArea");
            const statusMessage = document.getElementById("statusMessage");
            const hostStartBtn = document.getElementById("hostStartBtn");
            const hostSettingsBtn = document.getElementById("hostSettingsBtn");
            const endGameBtn = document.getElementById("endGameBtn");

            // Hide everything
            promptBox.style.display = "none";
            handArea.style.display = "none";
            votingArea.style.display = "none";
            resultsArea.style.display = "none";
            hostStartBtn.style.display = "none";
            hostSettingsBtn.style.display = "none";
            endGameBtn.style.display = "none";
            statusMessage.style.display = "block";

            if (phase === "lobby") {
                statusMessage.innerText = isHost
                    ? "You are the host. Configure settings and start the game."
                    : "Waiting for host to start the game...";
                if (isHost) {
                    hostSettingsBtn.style.display = "inline-block";
                }
            } else if (phase === "submit") {
                promptBox.style.display = "block";
                handArea.style.display = "block";
                statusMessage.style.display = "none";
                renderMyHand();
                if (isHost) endGameBtn.style.display = "inline-block";
            } else if (phase === "vote") {
                promptBox.style.display = "block";
                votingArea.style.display = "block";
                statusMessage.innerText = "Vote for the best answer! (Can't vote for your own)";
                renderVoting();
                if (isHost) endGameBtn.style.display = "inline-block";
            } else if (phase === "results") {
                promptBox.style.display = "block";
                resultsArea.style.display = "block";
                statusMessage.style.display = "none";
                renderResults();
                if (isHost) {
                    hostStartBtn.style.display = "inline-block";
                    hostStartBtn.innerText = currentState.round >= currentState.totalRounds 
                        ? "VIEW FINAL RESULTS" 
                        : "START NEXT ROUND";
                    endGameBtn.style.display = "inline-block";
                }
            } else if (phase === "final_results") {
                // Hide main game UI, show final results overlay
                statusMessage.style.display = "none";
                displayFinalResults();
            }
        }

        function updatePromptDisplay() {
            const prompt = currentState.prompt;
            if (!prompt) {
                document.getElementById('promptBox').style.display = 'none';
                return;
            }

            document.getElementById('promptSource').textContent = prompt.source || 'Unknown Source';
            
            let text = prompt.text || '';
            text = text.replace(/\[blank\]/gi, '<span class="blank">[_____]</span>');
            document.getElementById('promptText').innerHTML = text;
        }

        // === RENDER HAND ===
        function renderMyHand() {
            const grid = document.getElementById('cardsGrid');
            grid.innerHTML = '';
            
            myHand = currentState.playerHands[myPlayerId] || [];
            
            if (myHand.length === 0) {
                grid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: var(--text-soft);">No cards in hand</div>';
                return;
            }

            myHand.forEach((answerIdx, i) => {
                const answer = answers[answerIdx];
                if (!answer) return;
                
                const card = document.createElement('div');
                card.className = 'answer-card';
                card.textContent = answer.text;
                card.dataset.index = i;
                card.dataset.answerIdx = answerIdx;
                
                if (hasSubmitted) {
                    card.classList.add('disabled');
                } else {
                    card.onclick = () => selectCard(i);
                }
                
                grid.appendChild(card);
            });

            // Update confirm button
            const confirmBtn = document.getElementById('confirmCardBtn');
            confirmBtn.style.display = selectedCardIndex !== null && !hasSubmitted ? 'inline-block' : 'none';
        }

        function selectCard(index) {
            if (hasSubmitted) return;
            
            // Deselect all
            document.querySelectorAll('.answer-card').forEach(c => c.classList.remove('selected'));
            
            // Select this one
            const cards = document.querySelectorAll('.answer-card');
            if (cards[index]) {
                cards[index].classList.add('selected');
                selectedCardIndex = parseInt(cards[index].dataset.answerIdx);
            }
            
            document.getElementById('confirmCardBtn').style.display = 'inline-block';
        }

        async function submitCard() {
            if (selectedCardIndex === null || hasSubmitted) return;
            
            hasSubmitted = true;
            
            console.log('Submitting card:', { playerId: myPlayerId, cardIndex: selectedCardIndex });
            
            // Update state
            currentState.submissions[myPlayerId] = selectedCardIndex;
            
            // Remove card from hand
            const handIdx = myHand.indexOf(selectedCardIndex);
            if (handIdx > -1) {
                myHand.splice(handIdx, 1);
                currentState.playerHands[myPlayerId] = myHand;
            }
            
            await saveGameState();
            
            log('You submitted your answer!');
            renderMyHand();
            
            // Check if all players submitted
            if (isHost) {
                checkAllSubmitted();
            }
        }

        async function checkAllSubmitted() {
            const { data: players } = await supabaseClient
                .from('room_players')
                .select('user_id')
                .eq('room_id', roomId);
                
            if (!players) return;
            
            console.log('Checking submissions:', {
                players: players.map(p => p.user_id),
                submissions: Object.keys(currentState.submissions),
                allSubmitted: players.every(p => currentState.submissions[p.user_id])
            });
            
            const allSubmitted = players.every(p => currentState.submissions[p.user_id]);
            
            if (allSubmitted) {
                log('All players submitted! Moving to voting...');
                setTimeout(() => moveToVoting(), 2000);
            }
        }

        async function moveToVoting() {
            if (!isHost) return;
            
            currentState.phase = 'vote';
            currentState.votes = {};
            
            await saveGameState();
        }

        // === RENDER VOTING ===
        function renderVoting() {
            const grid = document.getElementById('votingGrid');
            grid.innerHTML = '';
            
            const submissions = currentState.submissions || {};
            
            if (Object.keys(submissions).length === 0) {
                grid.innerHTML = '<div style="text-align: center; color: var(--text-soft);">No submissions yet</div>';
                return;
            }

            Object.entries(submissions).forEach(([playerId, answerIdx]) => {
                const answer = answers[answerIdx];
                if (!answer) return;
                
                const card = document.createElement('div');
                card.className = 'vote-card';
                
                const isOwn = playerId === myPlayerId;
                if (isOwn) {
                    card.classList.add('own-answer');
                }
                
                if (hasVoted && currentState.votes[myPlayerId] === playerId) {
                    card.classList.add('voted');
                }
                
                const text = document.createElement('div');
                text.className = 'vote-card-text';
                text.textContent = answer.text;
                
                card.appendChild(text);
                
                if (!isOwn && !hasVoted) {
                    card.onclick = () => voteFor(playerId);
                }
                
                grid.appendChild(card);
            });
        }

        async function voteFor(targetPlayerId) {
            if (hasVoted || targetPlayerId === myPlayerId) return;
            
            hasVoted = true;
            currentState.votes[myPlayerId] = targetPlayerId;
            
            await saveGameState();
            
            log('You voted!');
            renderVoting();
            
            // Check if all voted
            if (isHost) {
                checkAllVoted();
            }
        }

        async function checkAllVoted() {
            const { data: players } = await supabaseClient
                .from('room_players')
                .select('user_id')
                .eq('room_id', roomId);
                
            if (!players) return;
            
            console.log('Checking votes:', {
                players: players.map(p => p.user_id),
                votes: Object.keys(currentState.votes),
                voteData: currentState.votes,
                allVoted: players.every(p => currentState.votes[p.user_id])
            });
            
            const allVoted = players.every(p => currentState.votes[p.user_id]);
            
            if (allVoted) {
                log('All players voted! Calculating results...');
                setTimeout(() => calculateResults(), 2000);
            }
        }

        async function calculateResults() {
            if (!isHost) return;
            
            console.log('Calculating results with votes:', currentState.votes);
            
            // Count votes
            const voteCounts = {};
            Object.values(currentState.votes).forEach(targetId => {
                voteCounts[targetId] = (voteCounts[targetId] || 0) + 1;
            });
            
            console.log('Vote counts:', voteCounts);
            
            // Find max votes
            let maxVotes = 0;
            Object.values(voteCounts).forEach(votes => {
                if (votes > maxVotes) maxVotes = votes;
            });
            
            // Find all players with max votes (handles ties)
            const winners = Object.entries(voteCounts)
                .filter(([playerId, votes]) => votes === maxVotes)
                .map(([playerId]) => playerId);
            
            console.log('Winners:', winners, 'with', maxVotes, 'votes');
            
            // Award points to all winners (in case of tie)
            if (winners.length > 0) {
                winners.forEach(winnerId => {
                    currentState.scores[winnerId] = (currentState.scores[winnerId] || 0) + 1;
                });
                // For display, just use first winner
                currentState.roundWinner = winners[0];
                currentState.roundWinners = winners; // Store all winners for tie display
            }
            
            currentState.phase = 'results';
            await saveGameState();
        }

        // === RENDER RESULTS ===
        function renderResults() {
            const area = document.getElementById('resultsArea');
            area.innerHTML = '';
            
            const winners = currentState.roundWinners || [currentState.roundWinner];
            if (!winners || winners.length === 0 || !winners[0]) {
                area.innerHTML = '<div class="status-msg">No winner this round</div>';
                return;
            }
            
            const isTie = winners.length > 1;
            
            const winnerCard = document.createElement('div');
            winnerCard.className = 'winner-card';
            
            const title = document.createElement('div');
            title.className = 'winner-title';
            title.textContent = isTie ? 'ü§ù TIE! ü§ù' : 'üèÜ Round Winner üèÜ';
            
            if (isTie) {
                // Show all tied winners
                winners.forEach(winnerId => {
                    const name = document.createElement('div');
                    name.className = 'winner-name';
                    name.textContent = getPlayerName(winnerId);
                    
                    const answerIdx = currentState.submissions[winnerId];
                    const answer = answers[answerIdx];
                    
                    const answerText = document.createElement('div');
                    answerText.className = 'winner-answer';
                    answerText.style.marginBottom = '1rem';
                    answerText.textContent = `"${answer ? answer.text : 'Unknown'}"`;
                    
                    winnerCard.appendChild(title);
                    winnerCard.appendChild(name);
                    winnerCard.appendChild(answerText);
                    
                    // Clear title after first winner
                    title.remove();
                });
                
                const tieNote = document.createElement('div');
                tieNote.style.marginTop = '1rem';
                tieNote.style.fontSize = '1rem';
                tieNote.textContent = 'Both players get a point!';
                winnerCard.appendChild(tieNote);
            } else {
                // Single winner
                const winnerId = winners[0];
                
                const name = document.createElement('div');
                name.className = 'winner-name';
                name.textContent = getPlayerName(winnerId);
                
                const answerIdx = currentState.submissions[winnerId];
                const answer = answers[answerIdx];
                
                const answerText = document.createElement('div');
                answerText.className = 'winner-answer';
                answerText.textContent = `"${answer ? answer.text : 'Unknown'}"`;
                
                const votes = document.createElement('div');
                votes.style.marginTop = '1rem';
                votes.style.fontSize = '1.1rem';
                const voteCount = Object.values(currentState.votes).filter(v => v === winnerId).length;
                votes.textContent = `${voteCount} vote${voteCount !== 1 ? 's' : ''}`;
                
                winnerCard.appendChild(title);
                winnerCard.appendChild(name);
                winnerCard.appendChild(answerText);
                winnerCard.appendChild(votes);
            }
            
            area.appendChild(winnerCard);
        }

        // === HOST ACTIONS ===
        async function hostStartNewRound() {
            if (!isHost) return;
            
            // Check if game ended
            if (currentState.phase === 'results' && currentState.round >= currentState.totalRounds) {
                await showFinalResults();
                return;
            }
            
            // Initialize scores for all players
            const { data: players } = await supabaseClient
                .from('room_players')
                .select('user_id')
                .eq('room_id', roomId);
                
            if (players) {
                players.forEach(p => {
                    if (!(p.user_id in currentState.scores)) {
                        currentState.scores[p.user_id] = 0;
                    }
                });
            }
            
            // Start new round
            currentState.round = (currentState.round || 0) + 1;
            currentState.phase = 'submit';
            currentState.submissions = {};
            currentState.votes = {};
            currentState.roundWinner = null;
            
            // Pick random prompt based on filters
            let filteredPrompts = prompts;
            
            // Filter by rating
            if (currentState.rating && currentState.rating !== 'all') {
                const ratingOrder = ['G', 'PG-13', 'R', 'NSFW'];
                const maxRatingIndex = ratingOrder.indexOf(currentState.rating);
                filteredPrompts = filteredPrompts.filter(p => {
                    const promptRatingIndex = ratingOrder.indexOf(p.rating);
                    return promptRatingIndex >= 0 && promptRatingIndex <= maxRatingIndex;
                });
                log(`Filtered to ${currentState.rating} and below: ${filteredPrompts.length} prompts`);
            }
            
            // Filter by pack
            if (currentState.pack && currentState.pack !== 'all') {
                filteredPrompts = filteredPrompts.filter(p => p.pack === currentState.pack);
                log(`Filtered to pack '${currentState.pack}': ${filteredPrompts.length} prompts`);
            }
            
            // Fallback to all prompts if filters are too restrictive
            if (filteredPrompts.length === 0) {
                log('No prompts match filters, using all prompts');
                filteredPrompts = prompts;
            }
            
            const prompt = filteredPrompts[Math.floor(Math.random() * filteredPrompts.length)];
            currentState.prompt = prompt;
            
            // Deal cards
            dealCards();
            
            await saveGameState();
            
            log(`Round ${currentState.round} started!`);
        }

        async function showFinalResults() {
            if (!isHost) return;
            
            const scores = currentState.scores || {};
            const sorted = Object.entries(scores).sort((a, b) => b[1] - a[1]);
            
            // Set state to show final results and SAVE IT so non-host players see it
            currentState.phase = 'final_results';
            currentState.finalScores = sorted;
            
            // Save the final_results state so all players can see it
            // This needs to happen BEFORE we set isCleaningUp flag
            await saveGameState();
            
            console.log('Final results state saved, waiting for sync...');
            
            // Wait a few seconds so players can see the results sync
            await new Promise(resolve => setTimeout(resolve, 3000));
            
            // Now clean up the room (this sets isCleaningUp flag)
            await cleanupRoom();
        }

        function displayFinalResults() {
            const sorted = currentState.finalScores || Object.entries(currentState.scores || {}).sort((a, b) => b[1] - a[1]);
            
            if (sorted.length === 0) {
                return;
            }
            
            // Check for tie at top
            const topScore = sorted[0][1];
            const winners = sorted.filter(([id, score]) => score === topScore);
            
            // Update title
            const titleEl = document.getElementById('finalResultsTitle');
            if (winners.length > 1) {
                titleEl.textContent = 'ü§ù TIE GAME! ü§ù';
            } else {
                titleEl.textContent = 'üéâ GAME OVER! üéâ';
            }
            
            // Build podium
            const podium = document.getElementById('finalResultsPodium');
            podium.innerHTML = '';
            
            const places = ['first', 'second', 'third'];
            const emojis = ['ü•á', 'ü•à', 'ü•â'];
            
            sorted.slice(0, 3).forEach(([playerId, score], index) => {
                const place = document.createElement('div');
                place.className = `podium-place ${places[index] || ''}`;
                
                const rank = document.createElement('div');
                rank.className = `podium-rank ${places[index] || ''}`;
                rank.textContent = emojis[index] || `#${index + 1}`;
                
                const name = document.createElement('div');
                name.className = 'podium-name';
                name.textContent = getPlayerName(playerId);
                
                const scoreEl = document.createElement('div');
                scoreEl.className = 'podium-score';
                scoreEl.textContent = `${score} point${score !== 1 ? 's' : ''}`;
                
                place.appendChild(rank);
                place.appendChild(name);
                place.appendChild(scoreEl);
                podium.appendChild(place);
            });
            
            // Show overlay
            document.getElementById('finalResultsOverlay').classList.add('active');
        }

        function returnToLobby() {
            window.location.href = '/multiplayer.html';
        }

        function resetGame() {
            currentState = {
                phase: "lobby",
                round: 0,
                totalRounds: 5,
                handSize: 7,
                rating: 'all',
                pack: 'all',
                prompt: null,
                playerHands: {},
                submissions: {},
                votes: {},
                scores: {},
                roundWinner: null
            };
            
            selectedCardIndex = null;
            hasSubmitted = false;
            hasVoted = false;
            
            saveGameState();
        }

        async function cleanupRoom() {
            if (!isHost) return;
            
            // Prevent double cleanup
            if (isCleaningUp) {
                console.log('Cleanup already in progress, skipping');
                return;
            }
            
            // Set flag
            isCleaningUp = true;
            
            console.log('Host cleanup: marking room as closed', roomId);
            
            try {
                // Just mark room as closed - simpler than deletion
                const { error: roomError } = await supabaseClient
                    .from('rooms')
                    .update({ 
                        status: 'closed',
                        updated_at: new Date().toISOString()
                    })
                    .eq('id', roomId);
                
                if (roomError) {
                    console.error('Error closing room:', roomError);
                } else {
                    console.log('‚úì Room marked as closed');
                }
            } catch (error) {
                console.error('Cleanup failed:', error);
            }
        }

        async function endGame() {
            if (!isHost) return;
            
            if (confirm('Are you sure you want to end the game? All players will return to the lobby.')) {
                // Show final results (which will handle cleanup)
                await showFinalResults();
            }
        }

        // Watch for room status changes (for non-host players)
        async function checkRoomStatus() {
            const { data: room } = await supabaseClient
                .from('rooms')
                .select('status')
                .eq('id', roomId)
                .maybeSingle();
                
            if (room && room.status === 'waiting') {
                // Game ended, redirect to lobby
                alert('Game has ended. Returning to lobby...');
                window.location.href = '/multiplayer.html';
            }
        }

        // === STATE MANAGEMENT ===
        async function saveGameState() {
            // Don't save if we're in the middle of cleanup
            if (isCleaningUp) {
                console.log('Skipping save - cleanup in progress');
                return;
            }
            
            console.log('saveGameState called by:', isHost ? 'HOST' : 'PLAYER', myPlayerId);
            
            // Load current state from DB first
            const { data: existing } = await supabaseClient
                .from('game_states')
                .select('*')
                .eq('room_id', roomId)
                .eq('game_type', 'who-said-it-better')
                .maybeSingle();

            let stateToSave;
            
            if (isHost) {
                // Host can save everything
                stateToSave = currentState;
                console.log('Host saving full state');
            } else {
                // Non-host merges their submission/vote into existing state
                if (existing && existing.state) {
                    stateToSave = existing.state;
                    console.log('Non-host merging into existing state');
                    
                    // Merge my submission
                    if (currentState.submissions && currentState.submissions[myPlayerId]) {
                        stateToSave.submissions = stateToSave.submissions || {};
                        stateToSave.submissions[myPlayerId] = currentState.submissions[myPlayerId];
                        console.log('Merged submission:', myPlayerId, currentState.submissions[myPlayerId]);
                    }
                    // Merge my vote
                    if (currentState.votes && currentState.votes[myPlayerId]) {
                        stateToSave.votes = stateToSave.votes || {};
                        stateToSave.votes[myPlayerId] = currentState.votes[myPlayerId];
                        console.log('Merged vote:', myPlayerId, currentState.votes[myPlayerId]);
                    }
                    // Merge my hand changes
                    if (currentState.playerHands && currentState.playerHands[myPlayerId]) {
                        stateToSave.playerHands = stateToSave.playerHands || {};
                        stateToSave.playerHands[myPlayerId] = currentState.playerHands[myPlayerId];
                    }
                } else {
                    // No existing state, shouldn't happen for non-host
                    console.error('Non-host trying to save but no existing state');
                    return;
                }
            }

            console.log('State to save submissions:', stateToSave.submissions);

            if (existing) {
                const { error } = await supabaseClient
                    .from('game_states')
                    .update({
                        state: stateToSave,
                        updated_at: new Date().toISOString()
                    })
                    .eq('id', existing.id);

                if (error) {
                    console.error('Error updating game state:', error);
                } else {
                    console.log('State saved successfully');
                }
            } else {
                // Only host should create initial state
                if (!isHost) return;
                
                const { error } = await supabaseClient
                    .from('game_states')
                    .insert({
                        room_id: roomId,
                        game_type: 'who-said-it-better',
                        state: stateToSave,
                        created_at: new Date().toISOString(),
                        updated_at: new Date().toISOString()
                    });

                if (error) {
                    console.error('Error inserting game state:', error);
                } else {
                    console.log('Initial state created successfully');
                }
            }
        }

        async function loadGameState() {
            const { data, error } = await supabaseClient
                .from('game_states')
                .select('state')
                .eq('room_id', roomId)
                .eq('game_type', 'who-said-it-better')
                .maybeSingle();

            if (error) {
                console.error('Error loading game state:', error);
                applyState(null);
                return;
            }

            applyState(data ? data.state : null);
        }

        function applyState(state) {
            if (!state || !state.phase) {
                currentState.phase = "lobby";
                currentState.round = 0;
                currentState.totalRounds = 5;
                currentState.handSize = 7;
                currentState.prompt = null;
                currentState.playerHands = {};
                currentState.submissions = {};
                currentState.votes = {};
                currentState.scores = {};
                currentState.roundWinner = null;
            } else {
                currentState = state;
            }

            document.getElementById("roundNumber").innerText = currentState.round || 0;
            document.getElementById("totalRounds").innerText = currentState.totalRounds || 5;
            
            // Reset submission/vote flags for new phases
            if (currentState.phase === 'submit') {
                hasSubmitted = !!(currentState.submissions && currentState.submissions[myPlayerId]);
                selectedCardIndex = null;
                
                // If host and in submit phase, check if everyone submitted
                if (isHost) {
                    setTimeout(() => checkAllSubmitted(), 1000);
                }
            } else if (currentState.phase === 'vote') {
                // Only update hasVoted if we haven't already voted locally
                // This prevents deselection when other players vote simultaneously
                if (!hasVoted) {
                    hasVoted = !!(currentState.votes && currentState.votes[myPlayerId]);
                }
                
                // If host and in vote phase, check if everyone voted
                if (isHost) {
                    setTimeout(() => checkAllVoted(), 1000);
                }
            } else if (currentState.phase === 'results' || currentState.phase === 'lobby') {
                hasSubmitted = false;
                hasVoted = false;
                selectedCardIndex = null;
            }

            setPhaseUI(currentState.phase);
            updatePromptDisplay();
            renderScores();
            loadPlayers(); // Refresh player list to show submission status
        }

        let isInitialized = false;

        // === INIT ===
        async function init() {
            if (isInitialized) {
                console.log('Already initialized, skipping...');
                return;
            }
            isInitialized = true;

            roomId = getQueryParam('room');
            if (!roomId) {
                alert('No room specified!');
                window.location.href = '/multiplayer.html';
                return;
            }

            // Wait for auth to be ready
            const { data: { session }, error: authError } = await supabaseClient.auth.getSession();
            if (authError || !session) {
                alert('Not logged in!');
                window.location.href = '/login.html?redirect=' + encodeURIComponent(window.location.href);
                return;
            }

            currentUser = session.user;
            myPlayerId = currentUser.id;

            const { data: profile, error: profileError } = await supabaseClient
                .from('profiles')
                .select('player_name')
                .eq('id', myPlayerId)
                .maybeSingle();

            if (profileError) {
                console.error('Error loading profile:', profileError);
                myPlayerName = currentUser.email?.split('@')[0] || 'Player';
            } else {
                myPlayerName = profile?.player_name || currentUser.email?.split('@')[0] || 'Player';
            }

            console.log('Looking for room:', roomId);
            
            const { data: room, error: roomError } = await supabaseClient
                .from('rooms')
                .select('*')
                .eq('id', roomId)
                .maybeSingle();

            console.log('Room query result:', { room, roomError });

            if (roomError) {
                console.error('Error loading room:', roomError);
                alert('Error loading room: ' + roomError.message);
                window.location.href = '/multiplayer.html';
                return;
            }
            
            if (!room) {
                console.error('Room not found in database');
                // Room doesn't exist, redirect back
                window.location.href = '/multiplayer.html';
                return;
            }

            isHost = room.host_user_id === myPlayerId;

            document.getElementById("roomInfo").innerText = "Room: " + roomId.substring(0, 8);
            document.getElementById("hostTag").innerText = isHost ? "HOST" : "PLAYER";
            
            // Show game log only for host
            if (isHost) {
                document.getElementById("logBox").classList.add("host-only");
            }

            log(`Joined room as ${myPlayerName} (${isHost ? 'HOST' : 'PLAYER'})`);
            setConnectionStatus('Loading...', 'normal');

            await loadGameData();
            await loadPlayers();
            await loadGameState();

            // Subscribe to game state updates
            gameStateChannel = supabaseClient
                .channel(`game-state-${roomId}`)
                .on('postgres_changes',
                    { event: '*', schema: 'public', table: 'game_states', filter: `room_id=eq.${roomId}` },
                    (payload) => {
                        if (payload.new && payload.new.state) {
                            applyState(payload.new.state);
                        }
                    }
                )
                .subscribe((status) => {
                    if (status === 'SUBSCRIBED') {
                        setConnectionStatus('Connected', 'connected');
                        log('Connected to game.');
                    }
                });

            // Subscribe to player updates
            playersChannel = supabaseClient
                .channel(`players-${roomId}`)
                .on('postgres_changes',
                    { event: '*', schema: 'public', table: 'room_players', filter: `room_id=eq.${roomId}` },
                    () => {
                        loadPlayers();
                    }
                )
                .subscribe();

            // Subscribe to room status changes (to detect game end)
            supabaseClient
                .channel(`room-status-${roomId}`)
                .on('postgres_changes',
                    { event: 'UPDATE', schema: 'public', table: 'rooms', filter: `id=eq.${roomId}` },
                    (payload) => {
                        console.log('Room status changed:', payload.new);
                        if (payload.new && (payload.new.status === 'waiting' || payload.new.status === 'closed')) {
                            alert('Game has ended. Returning to lobby...');
                            window.location.href = '/multiplayer.html';
                        }
                    }
                )
                .on('postgres_changes',
                    { event: 'DELETE', schema: 'public', table: 'rooms', filter: `id=eq.${roomId}` },
                    (payload) => {
                        console.log('Room deleted:', payload);
                        alert('Room has been closed. Returning to lobby...');
                        window.location.href = '/multiplayer.html';
                    }
                )
                .subscribe();

            // Event listeners
            document.getElementById("hostStartBtn").addEventListener("click", hostStartNewRound);
            document.getElementById("endGameBtn").addEventListener("click", endGame);
            
            // Host cleanup on disconnect
            if (isHost) {
                const hostCleanup = async () => {
                    console.log('Host cleanup triggered');
                    
                    // Get current session token
                    const { data: { session } } = await supabaseClient.auth.getSession();
                    if (!session) return;
                    
                    const token = session.access_token;
                    
                    // Use fetch with keepalive for reliable cleanup
                    const url = `${SUPABASE_URL}/rest/v1/rooms?id=eq.${roomId}`;
                    
                    try {
                        await fetch(url, {
                            method: 'DELETE',
                            keepalive: true,
                            headers: {
                                'apikey': SUPABASE_ANON_KEY,
                                'Authorization': `Bearer ${token}`,
                                'Content-Type': 'application/json',
                                'Prefer': 'return=minimal'
                            }
                        });
                        console.log('Room cleanup request sent');
                    } catch (error) {
                        console.error('Cleanup error:', error);
                    }
                };
                
                // Use both events for maximum reliability
                window.addEventListener('pagehide', hostCleanup);
                window.addEventListener('beforeunload', hostCleanup);
            }
        }

        // Monitor auth state
        supabaseClient.auth.onAuthStateChange((event, session) => {
            console.log('Auth state changed:', event);
            if (event === 'SIGNED_OUT') {
                window.location.href = '/login.html';
            } else if (event === 'INITIAL_SESSION' && session) {
                // Session is now ready, we can safely init if not already done
                if (!myPlayerId) {
                    console.log('Auth ready, initializing game...');
                    init();
                }
            }
        });

        // Start when page loads - but only if we already have a session
        window.addEventListener('DOMContentLoaded', async () => {
            const { data: { session } } = await supabaseClient.auth.getSession();
            if (session) {
                // We have a session immediately, can init now
                init();
            } else {
                // No immediate session, wait for INITIAL_SESSION event
                console.log('Waiting for auth session...');
            }
        });
    </script>
</body>
</html>