<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Word Rush - Time Attack</title>
<style>
body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; justify-content: center; align-items: flex-start;
    min-height: 100vh; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #111; padding: 20px;
}
#game-container {
    width: auto; max-width: 95vw; text-align: center; user-select: none; background: white;
    padding: 30px; border-radius: 20px; box-shadow: 0 20px 60px rgba(0,0,0,0.3);
}
h1 { color: #333; margin-bottom: 10px; }
#timer-display {
    font-size: 3em; margin: 20px 0; padding: 20px; border-radius: 12px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white; font-weight: bold; box-shadow: 0 4px 15px rgba(0,0,0,0.2); transition: all 0.3s;
}
#timer-display.warning { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); animation: pulse 1s infinite; }
#timer-display.critical { background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); animation: pulse 0.5s infinite; }
@keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
#game-grid {
    display: inline-grid; gap: 8px; margin: 20px 0; padding: 20px; background: #f5f5f5; border-radius: 10px; width: auto;
}
.cell {
    width: 70px; height: 70px; position: relative; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    display: flex; justify-content: center; align-items: center; font-size: 1.8em; font-weight: bold; color: white;
    cursor: pointer; border: none; border-radius: 10px; transition: all 0.3s ease; box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}
.cell:hover { transform: translateY(-2px); box-shadow: 0 6px 12px rgba(0,0,0,0.2); }
.cell:active { transform: translateY(0); }
.cell-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
.selected {
    background: linear-gradient(135deg, #48bb78 0%, #38a169 100%) !important; transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0,0,0,0.2);
}
.bomb-tile {
    background: linear-gradient(135deg, #fc8181 0%, #f56565 100%) !important;
    box-shadow: 0 4px 6px rgba(0,0,0,0.15), 0 0 20px rgba(245, 101, 101, 0.4);
}
.multiplier-tile {
    background: linear-gradient(135deg, #4fd1c5 0%, #38b2ac 100%) !important;
    box-shadow: 0 4px 6px rgba(0,0,0,0.15), 0 0 20px rgba(56, 178, 172, 0.4);
}
.chaos-flash { animation: flash-fade 0.4s forwards; }
@keyframes flash-fade { 0% { transform: scale(1); } 50% { transform: scale(1.15); box-shadow: 0 6px 20px rgba(72, 187, 120, 0.6); } 100% { transform: scale(1); } }
#game-over-screen {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.85);
    display: none; justify-content: center; align-items: center; z-index: 1000;
}
#game-over-content {
    background: white; padding: 40px; border-radius: 15px; text-align: center; max-width: 400px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
}
#game-over-content h2 { color: #667eea; font-size: 2.5em; margin: 0 0 20px 0; }
.final-stat { display: flex; justify-content: space-between; padding: 10px; margin: 5px 0; background-color: #f5f5f5; border-radius: 5px; }
#restart-btn {
    margin-top: 20px; padding: 15px 40px; font-size: 1.2em; font-weight: bold;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none;
    border-radius: 8px; cursor: pointer; transition: transform 0.2s;
}
#restart-btn:hover { transform: scale(1.05); }
@media (max-width: 600px) {
    #game-container { padding: 15px; } h1 { font-size: 1.5em; }
    #timer-display { font-size: 2em; padding: 15px; margin: 15px 0; } #game-grid { gap: 4px; padding: 10px; }
}
#start-screen {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.85);
    display: flex; justify-content: center; align-items: center; z-index: 1000;
}
#start-content {
    background: white; padding: 40px; border-radius: 15px; text-align: center; max-width: 450px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
}
#start-content h2 { color: #667eea; font-size: 2.5em; margin: 0 0 20px 0; }
.game-rule { text-align: left; padding: 12px; margin: 10px 0; background-color: #f5f5f5; border-radius: 5px; font-size: 0.95em; line-height: 1.5; }
.game-rule strong { color: #667eea; }
#start-btn {
    margin-top: 25px; padding: 15px 50px; font-size: 1.3em; font-weight: bold;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none;
    border-radius: 8px; cursor: pointer; transition: transform 0.2s;
}
#start-btn:hover { transform: scale(1.05); }
</style>
</head>
<body>
<audio id="sound-clear" src="sounds/clear.mp3" preload="auto"></audio>
<audio id="sound-defuse" src="sounds/defuse.mp3" preload="auto"></audio>
<audio id="sound-explosion" src="sounds/explosion.mp3" preload="auto"></audio>
<audio id="sound-push" src="sounds/push.mp3" preload="auto"></audio>
<audio id="sound-timer-warning" src="sounds/timer_warning.mp3" preload="auto"></audio>

<audio id="music-track-1" src="music/track1.mp3" preload="auto" loop></audio>
<audio id="music-track-2" src="music/track2.mp3" preload="auto" loop></audio>
<audio id="music-track-3" src="music/track3.mp3" preload="auto" loop></audio>

<div id="start-screen">
    <div id="start-content">
        <h2>Word Rush ‚è±Ô∏è</h2>
        <p style="font-size: 1.1em; margin-bottom: 20px;">Race against time to find words!</p>
        <div class="game-rule"><strong>üî§ Find Words:</strong> Click and drag adjacent letters to form words (2+ letters)</div>
        <div class="game-rule"><strong>‚è∞ Manage Time:</strong> Each word adds time. Run out of time = game over!</div>
        <div class="game-rule"><strong>‚≠ê Power-ups:</strong> **+2/+3** tiles add bonus seconds when adjacent to your word</div>
        <div class="game-rule"><strong>üí£ Bombs:</strong> Defuse by forming words next to them, or lose 5 seconds!</div>
        <div class="game-rule"><strong>üìà Expand:</strong> Every 10 words unlocks a bigger grid (+10 seconds)</div>
        <button id="start-btn">Start Game</button>
    </div>
</div>

<div id="game-container">
<h1>Word Rush ‚è±Ô∏è</h1>
<div id="timer-display">‚è∞ <span id="time-remaining">30</span>s</div>
<div id="game-grid"></div>
</div>

<div id="game-over-screen">
    <div id="game-over-content">
        <div id="creditsContent"></div>
    </div>
</div>

<script type="module">
    // ===== SUPABASE INTEGRATION =====
    import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm';
    
    const SUPABASE_URL = 'https://pknhslxhpohrzgsfkisr.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBrbmhzbHhocG9ocnpnc2ZraXNyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzU1OTY5NjUsImV4cCI6MjA1MTE3Mjk2NX0.tIUj3jIMX5c_jsdjL4RrfwW7wH-8Ry93y5kKOj0uEao';
    
    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    
    let currentUser = null;
    let playerName = "Anonymous";

    async function initGameAuth() {
        try {
            const { data: { session } } = await supabase.auth.getSession();
            if (session?.user) {
                currentUser = session.user;
                playerName = session.user.user_metadata?.display_name || 
                            session.user.email?.split('@')[0] || 
                            "Anonymous";
                scoreManager.playerName = playerName;
                console.log("Player identified:", playerName);
            }
        } catch (error) {
            console.warn("Auth check failed:", error);
        }
    }

    // Score Manager
    class GameScoreManager {
        constructor(gameName) {
            this.gameName = gameName;
            this.sessionStartTime = null;
            this.playerName = "Anonymous";
        }

        startSession() {
            this.sessionStartTime = Date.now();
        }

        getElapsedTime() {
            if (!this.sessionStartTime) return 0;
            return Math.floor((Date.now() - this.sessionStartTime) / 1000);
        }

        getElapsedTimeFormatted() {
            const seconds = this.getElapsedTime();
            if (seconds < 60) return `${seconds}s`;
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}m ${secs}s`;
        }

        async submitGameResult(score = 0) {
            if (!currentUser) {
                console.log('No user logged in, score not saved');
                return;
            }

            const timePlayed = this.getElapsedTime();
            
            try {
                const { error } = await supabase
                    .from('game_highscores')
                    .insert({
                        game_id: this.gameName,
                    player_name: playerName,
                        score: score,
                        user_id: currentUser.id
                    });

                if (error) throw error;
                console.log('Score submitted successfully');
            } catch (error) {
                console.warn('Failed to submit score:', error.message);
            }
        }
    }
    
    const scoreManager = new GameScoreManager('wordrush');
    initGameAuth();

    // --- CORE GAME VARIABLES ---
    const START_GRID_SIZE = 5;
    const MAX_GRID_SIZE = 12;
    const WORDS_PER_GRID_EXPANSION = 10;

    let currentGridSize = START_GRID_SIZE;
    let nextGridExpansion = WORDS_PER_GRID_EXPANSION;

    let grid = [], selectedCells = [];
    let isPushing = false;
    let bombTimerId = null;
    let bombCount = 0; 
    let consumedMultipliers = []; 
    let defusedBombs = []; 

    let timeRemaining = 45;
    let gameTimer = null;
    let wordsFound = 0;
    let totalBombsDefused = 0;
    let wordLengths = [];
    let gameStartTime = null;
    let gameActive = false;
    let timeDecayRate = 1.0;
    let currentMusicTrack = null;
    let lastWarningPlayed = 0;
    
    // Chaos timer variables
    let chaosBaseInterval = 10000;
    let chaosMinInterval = 3000;
    let chaosInterval = chaosBaseInterval;
    let chaosSpeedMultiplier = 1;
    let chaosTimer = null;

    const MULTIPLIER_CHANCE = 0.03;
    const BOMB_CHANCE = 0.02;
    const BOMB_START_VALUE = 6;
    const BOMB_TICK_INTERVAL = 5500;

    const DICTIONARY = new Set();
    const DICTIONARY_URL = 'CSW19.txt'; 

    const LETTER_SCORES = {'A':1,'E':1,'I':1,'O':1,'U':1,'L':1,'N':1,'R':1,'S':1,'T':1,'D':2,'G':2,'B':3,'C':3,'M':3,'P':3,'F':4,'H':4,'V':4,'W':4,'Y':4,'K':5,'J':8,'X':8,'Q':10,'Z':10};

    const VOWELS = ['A','E','I','O','U'];
    const COMMON_CONSONANTS = ['L','N','R','S','T','D','G'];
    const UNCOMMON_CONSONANTS = ['B','C','M','P','P','F','H','V','W','Y','K','J','X','Q','Z'];

    const WEIGHTED_ALPHABET = [
        ...VOWELS, ...VOWELS, ...VOWELS, ...VOWELS,
        ...COMMON_CONSONANTS, ...COMMON_CONSONANTS, ...COMMON_CONSONANTS,
        ...UNCOMMON_CONSONANTS
    ];

    const gridElement = document.getElementById('game-grid');
    const timeDisplay = document.getElementById('time-remaining');
    const timerDisplay = document.getElementById('timer-display');
    const gameOverScreen = document.getElementById('game-over-screen');
    const startScreen = document.getElementById('start-screen');
    const startBtn = document.getElementById('start-btn');

    startBtn.addEventListener('click', () => {
        startScreen.style.display = 'none';
        scoreManager.startSession();
        startBombTimer(); startChaosTimer(); startGameTimer(); startBackgroundMusic();
    });

    function playSound(id){
        const audio = document.getElementById(id);
        if(audio){ audio.currentTime = 0; audio.play().catch(e => console.log("Audio playback failed:", e)); }
    }

    function startBackgroundMusic(){
        if(currentMusicTrack){ currentMusicTrack.pause(); currentMusicTrack.currentTime = 0; }
        const trackNumber = Math.floor(Math.random() * 3) + 1;
        currentMusicTrack = document.getElementById(`music-track-${trackNumber}`);
        if(currentMusicTrack){ currentMusicTrack.volume = 0.3; currentMusicTrack.play().catch(e => console.log("Music playback failed:", e)); }
    }

    function stopBackgroundMusic(){
        if(currentMusicTrack){ currentMusicTrack.pause(); currentMusicTrack.currentTime = 0; }
    }

    function getRandomTile(){
        const r=Math.random();
        if(r<BOMB_CHANCE && bombCount === 0){ bombCount++; return{letter:'üí£',type:'BOMB',value:BOMB_START_VALUE}; }
        else if(r<BOMB_CHANCE+MULTIPLIER_CHANCE){ const m=(Math.random()<0.5?2:3); return{letter:`+${m}`,type:'MULTIPLIER',value:m}; }
        else{ const ch=WEIGHTED_ALPHABET[Math.floor(Math.random()*WEIGHTED_ALPHABET.length)]; return{letter:ch,type:'LETTER',value:1}; }
    }

    async function loadDictionary(){
        try{
            const res=await fetch(DICTIONARY_URL);
            if (!res.ok) throw new Error(`HTTP error! Status: ${res.status}`);
            const txt=await res.text();
            const words = txt.split('\n');
            words.map(w=>w.trim().toUpperCase()).filter(w=>w.length>=2).forEach(w=>DICTIONARY.add(w));
        }catch(e){
            console.error("Dictionary load failed");
            ["AT", "TO", "IS", "CAT","DOG","RUN","PLAY","WORD","GAME","RUSH"].forEach(w=>DICTIONARY.add(w));
        }
        initializeGrid();
    }

    function startGameTimer(){
        if(gameTimer) clearInterval(gameTimer);
        gameActive = true; gameStartTime = Date.now(); lastWarningPlayed = 0;
        gameTimer = setInterval(() => {
            if(!gameActive) return;
            const elapsedMinutes = (Date.now() - gameStartTime) / 60000;
            timeDecayRate = 1.0 + (elapsedMinutes * 0.15);
            timeRemaining -= (0.1 * timeDecayRate);
            const timeCeil = Math.ceil(timeRemaining);
            const warningTimes = [10, 5, 3, 2, 1];
            if(warningTimes.includes(timeCeil) && timeCeil !== lastWarningPlayed){
                if(timeCeil < lastWarningPlayed || lastWarningPlayed === 0) { playSound('sound-timer-warning'); lastWarningPlayed = timeCeil; }
            } else if (timeCeil > lastWarningPlayed && lastWarningPlayed !== 0) { lastWarningPlayed = 0; }
            if(timeRemaining <= 0){ timeRemaining = 0; endGame(); }
            updateTimerDisplay();
        }, 100);
    }

    function updateTimerDisplay(){
        timeDisplay.textContent = Math.ceil(timeRemaining);
        timerDisplay.classList.remove('warning', 'critical');
        if(timeRemaining <= 10) timerDisplay.classList.add('critical');
        else if(timeRemaining <= 20) timerDisplay.classList.add('warning');
    }

    function addTime(seconds){
        timeRemaining += seconds; timeRemaining = Math.min(timeRemaining, 120);
        const newTimeCeil = Math.ceil(timeRemaining);
        if (newTimeCeil > lastWarningPlayed && lastWarningPlayed !== 0) lastWarningPlayed = 0;
        updateTimerDisplay();
    }

    function removeTime(seconds){
        timeRemaining -= seconds; if(timeRemaining < 0) timeRemaining = 0; updateTimerDisplay();
    }

    function calculateTimeBonus(word, baseScore){
        let timeBonus = word.length * 1.5;
        if(word.length >= 5) timeBonus += 2; if(word.length >= 6) timeBonus += 3;
        if(word.length >= 7) timeBonus += 4; if(word.length >= 8) timeBonus += 6;
        const highValueCount = word.split('').filter(l => LETTER_SCORES[l] >= 5).length;
        timeBonus += highValueCount * 1;
        consumedMultipliers.forEach(m => { if(m.value === 2) timeBonus += 3; if(m.value === 3) timeBonus += 5; });
        return timeBonus;
    }

    function endGame(){
        gameActive = false;
        clearInterval(gameTimer); clearInterval(bombTimerId); clearInterval(chaosTimer);
        stopBackgroundMusic();
        
        const playTime = Math.floor((Date.now() - gameStartTime) / 1000);
        const avgWordLength = wordLengths.length > 0 ? (wordLengths.reduce((a,b) => a+b, 0) / wordLengths.length).toFixed(1) : 0;
        let finalScore = 0;
        if(wordsFound > 0) {
            finalScore = (wordsFound * 100) + (wordLengths.reduce((a,b) => a+b, 0) * 10) + (totalBombsDefused * 250) + (playTime * 5);
        }
        finalScore = Math.floor(finalScore);

        scoreManager.submitGameResult(finalScore);
        
        // Enhanced credits screen
        const creditsHTML = `
            <div style="line-height: 1.8; font-size: 0.8rem; text-align: center;">
                <h2 style="font-size: 2.5rem; margin-bottom: 1rem; color: #667eea; text-shadow: 0 0 10px #667eea;">TIME'S UP!</h2>
                
                <div style="margin: 1.5rem 0; padding: 1.5rem; background: rgba(0,0,0,0.1); border-radius: 12px;">
                    <p style="color: #667eea; margin-bottom: 0.3rem; font-size: 0.7rem; font-weight: bold;">FINAL SCORE</p>
                    <p style="font-size: 2.5rem; color: #333; margin-bottom: 1.5rem; font-weight: bold;">${finalScore}</p>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; text-align: left; margin-bottom: 1rem;">
                        <div style="background: rgba(102, 126, 234, 0.1); padding: 0.8rem; border-radius: 8px;">
                            <p style="color: #667eea; margin-bottom: 0.2rem; font-size: 0.65rem; font-weight: bold;">WORDS FOUND</p>
                            <p style="font-size: 1.5rem; color: #333; font-weight: bold;">${wordsFound}</p>
                        </div>
                        <div style="background: rgba(118, 75, 162, 0.1); padding: 0.8rem; border-radius: 8px;">
                            <p style="color: #764ba2; margin-bottom: 0.2rem; font-size: 0.65rem; font-weight: bold;">AVG LENGTH</p>
                            <p style="font-size: 1.5rem; color: #333; font-weight: bold;">${avgWordLength}</p>
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; text-align: left;">
                        <div style="background: rgba(255, 107, 107, 0.1); padding: 0.8rem; border-radius: 8px;">
                            <p style="color: #ff6b6b; margin-bottom: 0.2rem; font-size: 0.65rem; font-weight: bold;">BOMBS DEFUSED</p>
                            <p style="font-size: 1.5rem; color: #333; font-weight: bold;">${totalBombsDefused}</p>
                        </div>
                        <div style="background: rgba(78, 205, 196, 0.1); padding: 0.8rem; border-radius: 8px;">
                            <p style="color: #4ecdc4; margin-bottom: 0.2rem; font-size: 0.65rem; font-weight: bold;">PLAY TIME</p>
                            <p style="font-size: 1.5rem; color: #333; font-weight: bold;">${playTime}s</p>
                        </div>
                    </div>
                </div>
                
                <div style="margin-top: 1.5rem; padding-top: 1rem; border-top: 2px solid #e0e0e0;">
                    <p style="font-size: 0.6rem; color: #999; margin-bottom: 0.3rem;">GAME BY</p>
                    <p style="font-size: 0.8rem; color: #e94560; margin-bottom: 0.8rem; font-weight: bold;">GUNNER'S GAMES</p>
                    <p style="font-size: 0.55rem; color: #666;">Thanks for playing!</p>
                </div>
                
                <p style="font-size: 0.65rem; margin-top: 1.5rem; color: #999;">Returning to Arcade in 5 seconds...</p>
            </div>
        `;
        
        document.getElementById('creditsContent').innerHTML = creditsHTML;
        gameOverScreen.style.display = 'flex';
        
        // Return to arcade after showing credits
        setTimeout(() => {
            if (window.parent !== window) {
                window.parent.postMessage({ action: 'closeGame' }, '*');
            } else {
                window.location.href = '/arcade.html';
            }
        }, 5000);
    }

    function initializeGrid(){
        currentGridSize = START_GRID_SIZE; nextGridExpansion = WORDS_PER_GRID_EXPANSION;
        bombCount = 0; selectedCells = []; consumedMultipliers = []; defusedBombs = [];
        timeRemaining = 45; wordsFound = 0; totalBombsDefused = 0; wordLengths = [];
        gameActive = false; timeDecayRate = 1.0; lastWarningPlayed = 0;
        updateTimerDisplay();
        chaosInterval = chaosBaseInterval; createGrid(currentGridSize);
    }

    function createGrid(size){
        grid=[]; gridElement.innerHTML='';
        const screenWidth = window.innerWidth;
        const availableWidth = Math.min(screenWidth * 0.9, 900) - 100;
        const maxTileSize = Math.floor(availableWidth / size) - 8;
        
        let tileSize = Math.min(70, maxTileSize);
        if (size > 7) tileSize = Math.min(55, maxTileSize);
        if (size > 9) tileSize = Math.min(45, maxTileSize);
        if (size > 11) tileSize = Math.min(40, maxTileSize);
        if (screenWidth < 600) tileSize = Math.min(tileSize, Math.floor((screenWidth - 80) / size) - 6);
        
        gridElement.style.gridTemplateColumns = `repeat(${size}, ${tileSize}px)`;
        gridElement.style.gridTemplateRows = `repeat(${size}, ${tileSize}px)`;
        
        for(let r=0;r<size;r++){
            grid[r]=[];
            for(let c=0;c<size;c++){
                const tile=getRandomTile();
                grid[r][c]={...tile,r,c};
                const cell=document.createElement('div');
                cell.className='cell'; cell.id=`cell-${r}-${c}`;
                cell.dataset.r=r; cell.dataset.c=c;
                cell.style.width = `${tileSize}px`; cell.style.height = `${tileSize}px`;
                cell.style.fontSize = `${tileSize * 0.4}px`;
                
                cell.addEventListener('mousedown',handleCellClick); cell.addEventListener('mouseenter',handleCellEnter);
                cell.addEventListener('touchstart', handleCellClick); cell.addEventListener('touchmove', handleCellEnter);
                cell.addEventListener('touchend', endSelection); 
                gridElement.appendChild(cell);
            }
        }
        updateAllVisuals();
    }

    function updateAllVisuals(){
        const size = currentGridSize;
        for(let r=0;r<size;r++) for(let c=0;c<size;c++) updateCellVisual(r,c);
    }

    function updateCellVisual(r,c){
        if (r >= currentGridSize || c >= currentGridSize) return;
        const cell=grid[r][c],el=document.getElementById(`cell-${r}-${c}`);
        el.classList.remove('selected','bomb-tile','multiplier-tile','chaos-flash');
        if(!cell.letter){el.innerHTML='';return;}
        let text=cell.letter;
        if(cell.type==='BOMB'){ el.classList.add('bomb-tile'); text=`üí£${cell.value}`; }
        else if(cell.type==='MULTIPLIER'){ el.classList.add('multiplier-tile'); text=cell.letter; }
        if(selectedCells.some(s=>s.r===r&&s.c===c)) el.classList.add('selected');
        el.innerHTML=`<span class="cell-text">${text}</span>`;
    }

    function isAdjacent(r1,c1,r2,c2){return Math.abs(r1-r2)<=1&&Math.abs(c1-c2)<=1&&(r1!==r2||c1!==c2);}

    function handleCellClick(e){
        e.preventDefault(); 
        if(isPushing || !gameActive)return;
        if(!selectedCells.length){
            const r=parseInt(e.currentTarget.dataset.r),c=parseInt(e.currentTarget.dataset.c);
            if(grid[r][c].type!=='LETTER')return; 
            selectCell(r,c);
        }
        document.addEventListener('mouseup',endSelection);
    }

    function handleCellEnter(e){
        e.preventDefault(); 
        if(isPushing || !gameActive) return;
        const isTouch = e.type.startsWith('touch');
        if (isTouch && e.touches.length === 0) return; 
        if (!isTouch && e.buttons !== 1) return; 
        let targetElement = e.currentTarget;
        if (isTouch) {
            const touch = e.touches[0];
            targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
            if (!targetElement || !targetElement.classList.contains('cell')) return;
        }
        const r=parseInt(targetElement.dataset.r),c=parseInt(targetElement.dataset.c);
        if (r >= currentGridSize || c >= currentGridSize) return;
        if(grid[r][c].type!=='LETTER')return;
        if(!selectedCells.length)return selectCell(r,c);
        const last=selectedCells[selectedCells.length-1];
        if(isAdjacent(r,c,last.r,last.c)&&!selectedCells.some(s=>s.r===r&&s.c===c))selectCell(r,c);
    }

    function selectCell(r,c){
        selectedCells.push(grid[r][c]);
        document.getElementById(`cell-${r}-${c}`).classList.add('selected');
    }

    function endSelection(){
        document.removeEventListener('mouseup',endSelection);
        const w=selectedCells.filter(c=>c.type==='LETTER').map(c=>c.letter).join('');
        if(DICTIONARY.has(w.toUpperCase())&&w.length>=2&&!isPushing&&gameActive)submitWord();
        else{clearSelection();}
    }

    function clearSelection(){
        selectedCells.forEach(c=>document.getElementById(`cell-${c.r}-${c.c}`).classList.remove('selected'));
        selectedCells=[];
    }

    function handleExplosion(b){
        removeTime(5); playSound('sound-explosion'); bombCount = Math.max(0, bombCount - 1); 
        const cells=[];
        for(let r=b.r-1;r<=b.r+1;r++) for(let c=b.c-1;c<=b.c+1;c++)
            if(r>=0&&r<currentGridSize&&c>=0&&c<currentGridSize&&grid[r][c].letter)cells.push(grid[r][c]);
        const newCount=clearAndCascade(cells); triggerChaos(newCount);
    }

    function clearAndCascade(cells){
        const cols=[...new Set(cells.map(c=>c.c))];
        for(const c of cells){grid[c.r][c.c]={letter:null,type:null,value:null,r:c.r,c:c.c};}
        let added=0;
        for(const col of cols){
            let filled=[];
            for(let r=0;r<currentGridSize;r++)if(grid[r][col].letter)filled.push(grid[r][col]);
            while(filled.length<currentGridSize){
                const t=getRandomTile();filled.unshift({...t,r:currentGridSize-filled.length-1,c:col});added++;
            }
            for(let r=0;r<currentGridSize;r++){grid[r][col]=filled[r];grid[r][col].r=r;updateCellVisual(r,col);}
        }
        return added;
    }

    function getAdjacentMultipliers(cells){
        const multipliers = [], usedCoords = new Set();
        cells.forEach(cell => {
            for (let dr = -1; dr <= 1; dr++) for (let dc = -1; dc <= 1; dc++) {
                if (dr === 0 && dc === 0) continue;
                const nr = cell.r + dr, nc = cell.c + dc;
                if (nr >= 0 && nr < currentGridSize && nc >= 0 && nc < currentGridSize) {
                    const neighbor = grid[nr][nc]; const coordKey = `${nr}-${nc}`;
                    if (neighbor.type === 'MULTIPLIER' && !usedCoords.has(coordKey)) { multipliers.push(neighbor); usedCoords.add(coordKey); }
                }
            }
        });
        return multipliers;
    }

    function getAdjacentBombs(cells){
        const bombs = [], usedCoords = new Set();
        cells.forEach(cell => {
            for (let dr = -1; dr <= 1; dr++) for (let dc = -1; dc <= 1; dc++) {
                if (dr === 0 && dc === 0) continue;
                const nr = cell.r + dr, nc = cell.c + dc;
                if (nr >= 0 && nr < currentGridSize && nc >= 0 && nc < currentGridSize) {
                    const neighbor = grid[nr][nc]; const coordKey = `${nr}-${nc}`;
                    if (neighbor.type === 'BOMB' && !usedCoords.has(coordKey)) { bombs.push(neighbor); usedCoords.add(coordKey); }
                }
            }
        });
        return bombs;
    }

    function calculateScore(word){
        let base=0; consumedMultipliers = []; defusedBombs = []; 
        const letterCells = selectedCells.filter(c => c.type === 'LETTER');
        letterCells.forEach(c => base += LETTER_SCORES[c.letter] || 0);
        const adjacentMultipliers = getAdjacentMultipliers(letterCells);
        adjacentMultipliers.forEach(m => consumedMultipliers.push(m));
        defusedBombs = getAdjacentBombs(letterCells);
        return base * word.length * 10;
    }

    function checkGridExpansion(){
        if (currentGridSize >= MAX_GRID_SIZE) return;
        if (wordsFound >= nextGridExpansion) {
            const oldSize = currentGridSize; currentGridSize++; nextGridExpansion += WORDS_PER_GRID_EXPANSION;
            addTime(10);
            const oldGrid = [];
            for(let r = 0; r < oldSize; r++) { oldGrid[r] = []; for(let c = 0; c < oldSize; c++) oldGrid[r][c] = {...grid[r][c]}; }
            grid = []; gridElement.innerHTML = '';
            
            const screenWidth = window.innerWidth;
            const availableWidth = Math.min(screenWidth * 0.9, 900) - 100;
            const maxTileSize = Math.floor(availableWidth / currentGridSize) - 8;
            let tileSize = Math.min(70, maxTileSize);
            if (currentGridSize > 7) tileSize = Math.min(55, maxTileSize);
            if (currentGridSize > 9) tileSize = Math.min(45, maxTileSize);
            if (currentGridSize > 11) tileSize = Math.min(40, maxTileSize);
            if (screenWidth < 600) tileSize = Math.min(tileSize, Math.floor((screenWidth - 80) / currentGridSize) - 6);
            
            gridElement.style.gridTemplateColumns = `repeat(${currentGridSize}, ${tileSize}px)`;
            gridElement.style.gridTemplateRows = `repeat(${currentGridSize}, ${tileSize}px)`;
            
            for(let r = 0; r < currentGridSize; r++) {
                grid[r] = [];
                for(let c = 0; c < currentGridSize; c++) {
                    let tile;
                    if(r < oldSize && c < oldSize) tile = {...oldGrid[r][c], r, c};
                    else tile = {...getRandomTile(), r, c};
                    grid[r][c] = tile;
                    const cell = document.createElement('div');
                    cell.className = 'cell'; cell.id = `cell-${r}-${c}`;
                    cell.dataset.r = r; cell.dataset.c = c;
                    cell.style.width = `${tileSize}px`; cell.style.height = `${tileSize}px`; cell.style.fontSize = `${tileSize * 0.4}px`;
                    cell.addEventListener('mousedown', handleCellClick); cell.addEventListener('mouseenter', handleCellEnter);
                    cell.addEventListener('touchstart', handleCellClick); cell.addEventListener('touchmove', handleCellEnter);
                    cell.addEventListener('touchend', endSelection);
                    gridElement.appendChild(cell);
                }
            }
            updateAllVisuals();
        }
    }

    function submitWord(){
        const w=selectedCells.filter(c=>c.type==='LETTER').map(c=>c.letter).join('');
        const gain=calculateScore(w); const timeBonus = calculateTimeBonus(w, gain);
        wordsFound++; wordLengths.push(w.length);
        addTime(timeBonus); playSound('sound-clear'); 
        if (defusedBombs.length > 0) {
            const bombTimeBonus = defusedBombs.length * 3; addTime(bombTimeBonus); totalBombsDefused += defusedBombs.length;
            playSound('sound-defuse'); bombCount = Math.max(0, bombCount - defusedBombs.length);
        }
        const cellsToClear = selectedCells.filter(c => c.type === 'LETTER').concat(consumedMultipliers).concat(defusedBombs);
        clearSelection(); checkGridExpansion();
        const added=clearAndCascade(cellsToClear); triggerChaos(added);
    }

    async function performPush(axis, direction){
        return new Promise(resolve=>{
            let rowOrColIndex; let cellsToFlash = []; const size = currentGridSize;
            if (axis === 'vertical') { 
                rowOrColIndex = Math.floor(Math.random() * size); 
                if (direction === 'down') { 
                    for(let r = size - 1; r > 0; r--) grid[r][rowOrColIndex] = {...grid[r-1][rowOrColIndex], r, c: rowOrColIndex};
                    const newTile = getRandomTile(); grid[0][rowOrColIndex] = {...newTile, r: 0, c: rowOrColIndex};
                    cellsToFlash.push(document.getElementById(`cell-0-${rowOrColIndex}`));
                } else if (direction === 'up') { 
                    for(let r = 0; r < size - 1; r++) grid[r][rowOrColIndex] = {...grid[r+1][rowOrColIndex], r, c: rowOrColIndex};
                    const newTile = getRandomTile(); grid[size-1][rowOrColIndex] = {...newTile, r: size-1, c: rowOrColIndex};
                    cellsToFlash.push(document.getElementById(`cell-${size-1}-${rowOrColIndex}`));
                }
            } else if (axis === 'horizontal') { 
                rowOrColIndex = Math.floor(Math.random() * size); 
                if (direction === 'right') { 
                    for(let c = size - 1; c > 0; c--) grid[rowOrColIndex][c] = {...grid[rowOrColIndex][c-1], r: rowOrColIndex, c};
                    const newTile = getRandomTile(); grid[rowOrColIndex][0] = {...newTile, r: rowOrColIndex, c: 0};
                    cellsToFlash.push(document.getElementById(`cell-${rowOrColIndex}-0`));
                } else if (direction === 'left') { 
                    for(let c = 0; c < size - 1; c++) grid[rowOrColIndex][c] = {...grid[rowOrColIndex][c+1], r: rowOrColIndex, c};
                    const newTile = getRandomTile(); grid[rowOrColIndex][size-1] = {...newTile, r: rowOrColIndex, c: size-1};
                    cellsToFlash.push(document.getElementById(`cell-${rowOrColIndex}-${size-1}`));
                }
            }
            cellsToFlash.forEach(el => el.classList.add('chaos-flash')); playSound('sound-push'); 
            setTimeout(()=>{ cellsToFlash.forEach(el => el.classList.remove('chaos-flash')); updateAllVisuals(); resolve(); }, 400);
        });
    }

    function triggerChaos(pushCount){
        if(pushCount<=0)return; isPushing=true;
        (async()=>{
            for(let i=0;i<pushCount;i++){ await performPush('vertical', 'down'); await new Promise(r=>setTimeout(r,100)); }
            isPushing=false;
        })();
    }

    function startBombTimer(){
        if(bombTimerId)clearInterval(bombTimerId);
        bombTimerId=setInterval(()=>{
            if(isPushing || !gameActive)return;
            const size = currentGridSize; const bombs=[];
            for(let r=0;r<size;r++) for(let c=0;c<size;c++){
                const cell=grid[r][c];
                if(cell.type==='BOMB'&&cell.letter){cell.value--;if(cell.value<=0)bombs.push(cell);else updateCellVisual(r,c);}
            }
            if(bombs.length>0)bombs.forEach(b=>handleExplosion(b));
        },BOMB_TICK_INTERVAL);
    }

    function startChaosTimer(){
        if(chaosTimer)clearInterval(chaosTimer);
        chaosTimer=setInterval(async()=>{
            if(!gameActive) return;
            const pushes = [{axis: 'vertical', direction: 'down'}, {axis: 'vertical', direction: 'up'}, {axis: 'horizontal', direction: 'right'}, {axis: 'horizontal', direction: 'left'}];
            const {axis, direction} = pushes[Math.floor(Math.random() * pushes.length)];
            await performPush(axis, direction);
            chaosInterval=Math.max(chaosMinInterval,chaosInterval-250); restartChaosTimer();
        },chaosInterval/chaosSpeedMultiplier);
    }

    function restartChaosTimer(){clearInterval(chaosTimer);startChaosTimer();}

    loadDictionary(); 
</script>
</body>
</html>
