<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Squartris</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        :root { --block-size: 30px; --board-width: 10; --board-height: 20; --border-color: #333; }
        body { font-family: 'Press Start 2P', cursive; background-color: #1a1a2e; }
        .tetris-block {
            width: var(--block-size); height: var(--block-size);
            border: 2px solid rgba(255, 255, 255, 0.2); box-sizing: border-box;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5); transition: background-color 0.1s;
        }
        #game-board {
            display: grid; grid-template-columns: repeat(var(--board-width), var(--block-size));
            grid-template-rows: repeat(var(--board-height), var(--block-size));
            border: 8px solid var(--border-color); background-color: #0d0d1a;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5), inset 0 0 10px rgba(255, 255, 255, 0.1);
            margin: 0 auto; border-radius: 8px;
        }
        @media (max-width: 640px) { :root { --block-size: 20px; } }
        .color-0 { background-color: #00ffff; } .color-1 { background-color: #0000ff; }
        .color-2 { background-color: #ffa500; } .color-3 { background-color: #ffff00; }
        .color-4 { background-color: #00ff00; } .color-5 { background-color: #800080; }
        .color-6 { background-color: #ff0000; }
        .color-0, .color-1, .color-2, .color-3, .color-4, .color-5, .color-6 { border-color: rgba(0, 0, 0, 0.5); }
        .stats-card {
            background-color: #2b3a55; color: #ffffff; border-radius: 8px; padding: 1rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3); text-align: center;
        }
        .btn-game { transition: all 0.1s ease-in-out; box-shadow: 0 4px 0 0 #0f4c75; transform: translateY(0); }
        .btn-game:active { box-shadow: 0 0 0 0 #0f4c75; transform: translateY(4px); }
        .message-box {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9); color: #fff; padding: 3rem; border-radius: 10px;
            text-align: center; border: 5px solid #ffcc00; box-shadow: 0 0 30px #ffcc00; z-index: 100;
        }
        #next-piece-display {
            display: grid; grid-template-columns: repeat(4, 15px); grid-template-rows: repeat(4, 15px);
            margin: 1rem auto; width: 60px; height: 60px; border: 2px dashed #00bfff; padding: 5px;
        }
        #next-piece-display .tetris-block { width: 15px; height: 15px; border-width: 1px; }
        .mobile-btn {
            background-color: #3f51b5; color: white; padding: 10px; border-radius: 8px;
            box-shadow: 0 3px 0 0 #2c387e; transition: all 0.1s; display: flex; align-items: center; justify-content: center;
        }
        .mobile-btn:active { box-shadow: 0 0 0 0 #2c387e; transform: translateY(3px); }
    </style>
</head>
<body class="min-h-screen p-4 flex items-center justify-center">

    <div id="game-container" class="flex flex-col lg:flex-row gap-8 items-center lg:items-start p-4 bg-gray-900/80 rounded-xl shadow-2xl max-w-6xl w-full">
        <div class="flex flex-col gap-4 w-full lg:w-1/3">
            <h1 class="text-4xl text-cyan-300 text-center uppercase tracking-widest mt-4 lg:mt-0 shadow-sm">Squartris</h1>
            <div class="stats-card"><p class="text-xl mb-2">Score</p><div id="score" class="text-3xl text-yellow-300">0</div></div>
            <div class="stats-card"><p class="text-xl mb-2">Next</p><div id="next-piece-display"></div></div>
            <div class="stats-card">
                <p class="text-xl mb-2">Controls</p>
                <p class="text-sm">A / Left: Move Left</p><p class="text-sm">D / Right: Move Right</p>
                <p class="text-sm">W / Up: Rotate</p><p class="text-sm">S / Down: Soft Drop</p>
                <p class="text-sm">Space: Hard Drop</p><p class="text-sm">P: Pause/Resume</p>
            </div>
            <button id="start-button" class="btn-game bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg uppercase tracking-wider">Start Game</button>
        </div>

        <div id="game-board-wrapper" class="relative">
            <div id="game-board"></div>
            <div id="message-overlay" class="hidden message-box">
                <p id="message-text" class="text-3xl mb-4"></p>
                <button id="restart-button" class="btn-game bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded uppercase text-lg hidden">Restart</button>
            </div>
        </div>
        
        <div id="mobile-controls" class="lg:hidden w-full flex justify-around p-4">
            <button class="mobile-btn" data-key="ArrowLeft">⬅️</button>
            <button class="mobile-btn" data-key="ArrowDown">⬇️</button>
            <button class="mobile-btn" data-key="ArrowRight">➡️</button>
            <button class="mobile-btn" data-key="ArrowUp">⬆️</button>
            <button class="mobile-btn text-lg" data-key="Space">DROP</button>
        </div>
    </div>

    <script type="module">
        // ===== UPDATED FIREBASE & SCORE MANAGER =====
        import { db } from '/firebase-config.js';
        import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { collection, addDoc, serverTimestamp, doc, setDoc, increment } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

        let auth = null;
        let currentUser = null;

        // Gatekeeper: Check if logged in
        async function initGameAuth() {
            try {
                auth = getAuth(db.app);
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        console.log("Pilot Identified:", user.displayName);
                        currentUser = user;
                        scoreManager.playerName = user.displayName || "Unknown Pilot";
                    } else {
                        // Not logged in? Kick back to the portal
                        window.location.href = '/index.html';
                    }
                });
            } catch (error) {
                console.error("Auth failed:", error);
            }
        }

        // Score Manager
        class GameScoreManager {
            constructor(gameName) {
                this.gameName = gameName;
                this.sessionStartTime = null;
                this.playerName = "Loading...";
            }

            startSession() {
                this.sessionStartTime = Date.now();
            }

            getElapsedTime() {
                if (!this.sessionStartTime) return 0;
                return Math.floor((Date.now() - this.sessionStartTime) / 1000);
            }

            async submitGameResult(score = 0) {
                if (!currentUser) return;

                const timePlayed = this.getElapsedTime();
                
                try {
                    // 1. Public Leaderboard
                    await addDoc(collection(db, 'scores'), {
                        gameName: this.gameName,
                        playerName: this.playerName,
                        score: score,
                        timePlayed: timePlayed,
                        timestamp: serverTimestamp(),
                        uid: currentUser.uid
                    });

                    // 2. Update Career Stats
                    const userRef = doc(db, 'users', currentUser.uid);
                    await setDoc(userRef, {
                        lastActive: serverTimestamp(),
                        totalArcadeScore: increment(parseInt(score)),
                        [`gamesPlayed_${this.gameName}`]: increment(1),
                        totalTimePlayed: increment(timePlayed)
                    }, { merge: true });

                    console.log('Score submitted & Career updated');
                } catch (error) {
                    console.warn('Failed to submit score:', error.message);
                }
            }
        }
        
        // Initialize
        const scoreManager = new GameScoreManager('squartris');
        initGameAuth();

        // ===== GAME LOGIC =====
        const BOARD_WIDTH = 10; const BOARD_HEIGHT = 20; const BLOCK_SIZE = 30;
        const SCORE_PER_LINE = [0, 40, 100, 300, 1200]; const INITIAL_DROP_RATE = 1000;

        const TETROMINOS = [
            [[1, 1, 1, 1]], [[1, 0, 0], [1, 1, 1]], [[0, 0, 1], [1, 1, 1]],
            [[1, 1], [1, 1]], [[0, 1, 1], [1, 1, 0]], [[0, 1, 0], [1, 1, 1]], [[1, 1, 0], [0, 1, 1]]
        ];

        let board = [], score = 0, isPlaying = false, isPaused = false;
        let dropCounter = 0, dropInterval = INITIAL_DROP_RATE, lastTime = 0;
        let currentPiece, nextPiece, lockSynth, clearSynth;

        function initializeAudio() {
            lockSynth = new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 2, envelope: { attack: 0.001, decay: 0.2, sustain: 0.01, release: 0.1 } }).toDestination();
            clearSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "square" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0 } }).toDestination();
        }

        function playLockSound() { if(lockSynth) lockSynth.triggerAttackRelease("C2", "8n"); }
        function playClearSound(lines) { 
            if(clearSynth) {
                const notes = ["C5", "E5", "G5", "C6"].slice(0, lines + 1);
                clearSynth.triggerAttackRelease(notes, "16n");
            }
        }

        const boardElement = document.getElementById('game-board');
        const scoreElement = document.getElementById('score');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const messageOverlay = document.getElementById('message-overlay');
        const messageText = document.getElementById('message-text');
        const nextPieceDisplay = document.getElementById('next-piece-display');

        function createBoard() {
            board = Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(null));
            boardElement.innerHTML = '';
            boardElement.style.setProperty('--block-size', `${BLOCK_SIZE}px`);
            boardElement.style.width = `${BOARD_WIDTH * BLOCK_SIZE + 16}px`;
            boardElement.style.height = `${BOARD_HEIGHT * BLOCK_SIZE + 16}px`;
            for (let y = 0; y < BOARD_HEIGHT; y++) for (let x = 0; x < BOARD_WIDTH; x++) {
                const cell = document.createElement('div'); cell.classList.add('tetris-block'); boardElement.appendChild(cell);
            }
        }

        function getCell(x, y) { return boardElement.children[y * BOARD_WIDTH + x]; }

        function generatePiece() {
            const index = Math.floor(Math.random() * TETROMINOS.length);
            return { shape: TETROMINOS[index], color: index, x: Math.floor(BOARD_WIDTH / 2) - Math.ceil(TETROMINOS[index][0].length / 2), y: 0 };
        }

        function rotateMatrix(matrix) {
            const rows = matrix.length, cols = matrix[0].length;
            const newMatrix = Array.from({ length: cols }, () => Array(rows).fill(0));
            for (let y = 0; y < rows; y++) for (let x = 0; x < cols; x++) newMatrix[x][rows - 1 - y] = matrix[y][x];
            return newMatrix;
        }

        function movePiece(dx, dy) {
            currentPiece.x += dx; currentPiece.y += dy;
            if (isValidMove(currentPiece.shape, currentPiece.x, currentPiece.y)) return true;
            currentPiece.x -= dx; currentPiece.y -= dy; return false;
        }

        function rotatePiece() {
            const rotated = rotateMatrix(currentPiece.shape);
            if (isValidMove(rotated, currentPiece.x, currentPiece.y)) { currentPiece.shape = rotated; return true; }
            for (const offset of [1, -1]) {
                if (isValidMove(rotated, currentPiece.x + offset, currentPiece.y)) {
                    currentPiece.x += offset; currentPiece.shape = rotated; return true;
                }
            }
            return false;
        }

        function isValidMove(shape, x, y) {
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const boardX = x + col, boardY = y + row;
                        if (boardX < 0 || boardX >= BOARD_WIDTH || boardY >= BOARD_HEIGHT) return false;
                        if (boardY < 0) continue;
                        if (board[boardY] && board[boardY][boardX] !== null) return false;
                    }
                }
            }
            return true;
        }

        function lockPiece() {
            playLockSound();
            for (let row = 0; row < currentPiece.shape.length; row++) {
                for (let col = 0; col < currentPiece.shape[row].length; col++) {
                    if (currentPiece.shape[row][col]) {
                        const boardY = currentPiece.y + row; const boardX = currentPiece.x + col;
                        if (boardY < 0) { gameOver(); return; }
                        if (boardY < BOARD_HEIGHT && boardX < BOARD_WIDTH) board[boardY][boardX] = currentPiece.color;
                    }
                }
            }
            clearLines();
            currentPiece = nextPiece; nextPiece = generatePiece(); drawNextPiece();
            if (!isValidMove(currentPiece.shape, currentPiece.x, currentPiece.y)) gameOver();
        }

        function clearLines() {
            let linesCleared = 0;
            for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
                if (board[y].every(cell => cell !== null)) {
                    linesCleared++; board.splice(y, 1); board.unshift(Array(BOARD_WIDTH).fill(null)); y++;
                }
            }
            if (linesCleared > 0) {
                playClearSound(linesCleared);
                score += SCORE_PER_LINE[linesCleared] || 0; scoreElement.textContent = score;
                dropInterval = Math.max(100, INITIAL_DROP_RATE - Math.floor(score / 500) * 50);
            }
        }

        function draw() {
            for (let i = 0; i < boardElement.children.length; i++) boardElement.children[i].className = 'tetris-block';
            for (let y = 0; y < BOARD_HEIGHT; y++) for (let x = 0; x < BOARD_WIDTH; x++) {
                if (board[y][x] !== null) getCell(x, y).classList.add(`color-${board[y][x]}`);
            }
            if (currentPiece) {
                for (let row = 0; row < currentPiece.shape.length; row++) for (let col = 0; col < currentPiece.shape[row].length; col++) {
                    if (currentPiece.shape[row][col]) {
                        const boardY = currentPiece.y + row; const boardX = currentPiece.x + col;
                        if (boardY >= 0 && boardY < BOARD_HEIGHT && boardX >= 0 && boardX < BOARD_WIDTH) getCell(boardX, boardY).classList.add(`color-${currentPiece.color}`);
                    }
                }
            }
        }

        function drawNextPiece() {
            nextPieceDisplay.innerHTML = '';
            for (let y = 0; y < 4; y++) for (let x = 0; x < 4; x++) {
                const cell = document.createElement('div'); cell.classList.add('tetris-block');
                if (nextPiece) {
                    const shape = nextPiece.shape;
                    const startX = Math.floor((4 - shape[0].length) / 2), startY = Math.floor((4 - shape.length) / 2);
                    const shapeX = x - startX, shapeY = y - startY;
                    if (shapeY >= 0 && shapeY < shape.length && shapeX >= 0 && shapeX < shape[0].length) {
                        if (shape[shapeY][shapeX]) cell.classList.add(`color-${nextPiece.color}`);
                    }
                }
                nextPieceDisplay.appendChild(cell);
            }
        }

        function gameLoop(time = 0) {
            if (!isPlaying || isPaused) { draw(); return; }
            const deltaTime = time - lastTime; lastTime = time; dropCounter += deltaTime;
            if (dropCounter > dropInterval) { dropPiece(); dropCounter = 0; }
            draw(); requestAnimationFrame(gameLoop);
        }

        function dropPiece() { if (!movePiece(0, 1)) lockPiece(); dropCounter = 0; }
        function hardDrop() { if (!isPlaying || isPaused) return; while (movePiece(0, 1)) {}; lockPiece(); }

        function gameOver() {
            isPlaying = false; showMessage('Game Over! Final Score: ' + score, true);
            scoreManager.submitGameResult(score);
            if(lockSynth) lockSynth.triggerAttackRelease("A1", 0.5);
        }

        function togglePause() {
            if (!isPlaying) return;
            isPaused = !isPaused;
            if (isPaused) showMessage('PAUSED', false); else { hideMessage(); lastTime = performance.now(); requestAnimationFrame(gameLoop); }
        }

        function showMessage(msg, showRestart) {
            messageText.textContent = msg;
            if (showRestart) restartButton.classList.remove('hidden'); else restartButton.classList.add('hidden');
            messageOverlay.classList.remove('hidden');
        }
        function hideMessage() { messageOverlay.classList.add('hidden'); }

        async function startGame() {
            if (Tone.context.state !== 'running') await Tone.start();
            if (isPlaying) return;
            createBoard(); score = 0; scoreElement.textContent = score; dropInterval = INITIAL_DROP_RATE;
            isPaused = false; isPlaying = true; hideMessage();
            scoreManager.startSession();
            currentPiece = generatePiece(); nextPiece = generatePiece(); drawNextPiece();
            lastTime = performance.now(); requestAnimationFrame(gameLoop);
        }

        function handleKey(key) {
            if (!isPlaying || isPaused) return;
            switch (key) {
                case 'ArrowLeft': case 'KeyA': movePiece(-1, 0); break;
                case 'ArrowRight': case 'KeyD': movePiece(1, 0); break;
                case 'ArrowDown': case 'KeyS': movePiece(0, 1); break;
                case 'ArrowUp': case 'KeyW': rotatePiece(); break;
                case ' ': case 'Space': hardDrop(); break;
            }
        }

        document.addEventListener('keydown', (e) => {
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyW', 'KeyA', 'KeyS', 'KeyD'].includes(e.code)) e.preventDefault();
            if (e.code === 'KeyP') togglePause(); else handleKey(e.code);
        });

        document.querySelectorAll('.mobile-btn').forEach(button => {
            button.addEventListener('click', (e) => {
                const key = e.currentTarget.getAttribute('data-key');
                if (key === 'Space') { e.preventDefault(); hardDrop(); } else handleKey(key);
            });
        });

        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);

        window.onload = function() {
            initializeAudio(); createBoard(); showMessage('Press START to play!', false);
        };
    </script>
</body>
</html>
