<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Squario</title>
    <script src="levels.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #5c94fc; font-family: Arial, sans-serif; }
        canvas { display: block; background: #5c94fc; width: 100vw; height: 100vh; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: white; font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5); z-index: 10;
        }
        #title {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            color: white; font-size: 36px; font-weight: bold; text-shadow: 3px 3px 6px rgba(0,0,0,0.7);
            z-index: 10; font-family: 'Arial Black', Impact, sans-serif;
        }
        #gameOver {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8); color: white; padding: 40px; border-radius: 10px;
            text-align: center; display: none; z-index: 20; max-width: 600px;
        }
        
        #startScreen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex; flex-direction: column; align-items: center; justify-content: flex-start; 
            z-index: 30; color: white; overflow-y: auto; padding: 40px 20px; box-sizing: border-box; 
        }
        #startScreen h1 {
            font-size: 56px; margin-bottom: 15px; font-family: 'Arial Black', Impact, sans-serif;
            text-shadow: 4px 4px 8px rgba(0,0,0,0.5); animation: bounce 1s infinite; text-align: center; 
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        #startScreen .instructions {
            background: rgba(0,0,0,0.5); padding: 20px; border-radius: 15px;
            margin: 20px; max-width: 500px;
        }
        #startScreen .instructions h2 { margin-bottom: 10px; font-size: 24px; }
        #startScreen .instructions p { margin: 8px 0; font-size: 16px; line-height: 1.4; }
        #startScreen .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px; }
        #startScreen .control-item { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; }
        #startScreen button {
            margin-top: 30px; padding: 15px 50px; font-size: 28px; cursor: pointer;
            background: #4CAF50; color: white; border: none; border-radius: 10px;
            font-weight: bold; box-shadow: 0 5px 15px rgba(0,0,0,0.3); transition: transform 0.2s;
            margin-bottom: 20px; 
        }
        #startScreen button:hover { background: #45a049; transform: scale(1.05); }

        #mobile-controls {
            position: absolute; bottom: 20px; left: 20px; right: 20px;
            display: none; justify-content: space-between; align-items: flex-end;
            z-index: 50; user-select: none; pointer-events: none; 
        }
        #dpad, #action-buttons { display: flex; pointer-events: auto; }
        #mobile-controls button {
            width: 70px; height: 70px; background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5); border-radius: 50%; margin: 0 10px;
            font-size: 36px; color: white; -webkit-tap-highlight-color: transparent; 
        }
        #dpad #down-btn { width: 60px; height: 60px; align-self: center; }
        #action-buttons button { width: 80px; height: 80px; }
        #action-buttons #run-btn { width: 70px; height: 70px; align-self: center; }

        @media (max-width: 800px), (hover: none) and (pointer: coarse) {
            #mobile-controls { display: flex; }
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1>üéÆ SQUARIO üéÆ</h1>
        <div class="instructions">
            <h2>How to Play</h2>
            <p><strong>Objective:</strong> Reach the flagpole!</p>
            <div class="controls">
                <div class="control-item">‚¨ÖÔ∏è‚û°Ô∏è Move</div>
                <div class="control-item">‚¨ÜÔ∏è Jump</div>
                <div class="control-item">‚¨áÔ∏è Enter Pipes</div>
                <div class="control-item">SHIFT Run</div>
            </div>
            <p style="margin-top: 15px;"><strong>Tips:</strong></p>
            <p>‚Ä¢ Hit ‚ùì blocks for power-ups ‚Ä¢ Collect 50 coins for 1UP</p>
            <p>‚Ä¢ Jump on enemies to defeat them ‚Ä¢ Enter pipes for bonus rooms</p>
        </div>
        <button onclick="startGame()">START GAME</button>
    </div>
    <div id="title">SQUARIO</div>
    <div id="ui">
        <div>Score: <span id="score">0</span></div>
        <div>Coins: <span id="coins">0</span></div> <div>Lives: <span id="lives">3</span></div>
        <div>Time: <span id="time">300</span></div>
        <div>Level: <span id="level">1</span></div>
        <div>High Score: <span id="highScore">0</span></div>
    </div>
    <div id="gameOver">
        <h1 id="endMessage">Game Over!</h1>
        <p id="finalScore"></p>
        <p id="currentHighScore"></p>
        <div id="credits" style="margin-top: 30px; height: 250px; overflow: hidden; position: relative;">
            <div id="creditsScroll" style="position: absolute; width: 100%; animation: scrollUp 8s linear 1;">
                <div style="text-align: center; font-size: 18px; line-height: 2.5; color: #fff;">
                    <p style="font-size: 24px; color: #FFD700; margin-bottom: 20px;">‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</p>
                    
                    <p style="font-size: 20px; color: #FFD700; margin-top: 30px;">GAME DESIGN</p>
                    <p style="color: #ddd;">GunnersGames Studio</p>
                    
                    <p style="font-size: 20px; color: #FFD700; margin-top: 30px;">DEVELOPMENT</p>
                    <p style="color: #ddd;">Claude AI Assistant</p>
                    
                    <p style="font-size: 20px; color: #FFD700; margin-top: 30px;">SPECIAL THANKS</p>
                    <p style="color: #ddd;">All GunnersGames Players</p>
                    
                    <p style="font-size: 24px; color: #FFD700; margin-top: 40px;">‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</p>
                    
                    <p style="margin-top: 40px; color: #888; font-size: 14px;">
                        Returning to arcade in 5 seconds...
                    </p>
                    
                    <p style="margin-top: 60px; color: #666; font-size: 16px;">
                        THANKS FOR PLAYING!
                    </p>
                </div>
            </div>
        </div>
    </div>
    
    <style>
        @keyframes scrollUp {
            0% { top: 100%; }
            100% { top: -100%; }
        }
    </style>
    <canvas id="game"></canvas>

    <div id="mobile-controls">
        <div id="dpad">
            <button id="left-btn">‚¨ÖÔ∏è</button>
            <button id="right-btn">‚û°Ô∏è</button>
            <button id="down-btn">‚¨áÔ∏è</button>
        </div>
        <div id="action-buttons">
            <button id="run-btn">üëü</button>
            <button id="jump-btn">‚¨ÜÔ∏è</button>
        </div>
    </div>

    <script type="module">
        // ===== SUPABASE + SCORE MANAGER (REPLACES FIREBASE) =====
        import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

        const SUPABASE_URL = "https://pknhslxhpohrzgsfkisr.supabase.co";
        const SUPABASE_ANON_KEY = "sb_publishable_-zZw-pi_3q1sdNGhITKuhQ_ECyDARzc";

        const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        class GameScoreManager {
            constructor(gameName) {
                this.gameName = gameName;
                this.sessionStartTime = null;
                this.playerName = "PLAYER";
                this.user = null;   // Supabase user
            }

            startSession() {
                this.sessionStartTime = Date.now();
            }

            getElapsedTime() {
                if (!this.sessionStartTime) return 0;
                return Math.floor((Date.now() - this.sessionStartTime) / 1000);
            }

            getElapsedTimeFormatted() {
                const seconds = this.getElapsedTime();
                if (seconds < 60) return `${seconds}s`;
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins}m ${secs}s`;
            }

            async submitGameResult(score = 0) {
                // Skip if no user logged in
                if (!this.user) {
                    console.log("No user logged in, skipping score submission");
                    return;
                }

                const timePlayed = this.getElapsedTime();

                try {
                    const { error } = await supabase.from("game_highscores").insert({
                        user_id: this.user.id,
                        game: this.gameName,
                        score: Math.floor(score),
                        time_played: timePlayed
                    });

                    if (error) {
                        console.error("Supabase stats insert failed:", error);
                    } else {
                        console.log(`Score submitted: ${score} for ${this.gameName}`);
                    }
                } catch (err) {
                    console.error("Error submitting score:", err);
                }
            }
        }

        const scoreManager = new GameScoreManager("squario");

        async function initGameAuth() {
            try {
                const { data: { session } } = await supabase.auth.getSession();
                if (!session?.user) {
                    console.log("No Supabase user in Squario ‚Äì scores will stay local only.");
                    return;
                }

                scoreManager.user = session.user;

                // Prefer Supabase metadata, fall back to cached profile name if needed
                const metaName = session.user.user_metadata?.display_name;
                const cachedName = localStorage.getItem("playerName");
                scoreManager.playerName = (metaName || cachedName || "Player").toString();
                console.log("Supabase player initialized:", scoreManager.playerName, "User ID:", session.user.id);
            } catch (err) {
                console.error("Supabase auth init failed in Squario:", err);
            }
        }

        // Wait for Supabase auth to initialize before starting
        initGameAuth();

        // ===== GAME LOGIC =====
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        let timerInterval = null;
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const sounds = {
            jump: new Audio('sounds/jump.mp3'),
            coin: new Audio('sounds/coin.mp3'),
            powerup: new Audio('sounds/powerup.mp3'),
            stomp: new Audio('sounds/stomp.mp3'),
            hit: new Audio('sounds/hit.mp3'),
            pipe: new Audio('sounds/pipe.mp3'),
            flagpole: new Audio('sounds/flagpole.mp3'),
            death: new Audio('sounds/death.mp3')
        };

        const music = new Audio('music/theme.mp3');
        music.loop = true; music.volume = 0.2; 
        
        function playSound(name) {
            if (sounds[name]) {
                sounds[name].currentTime = 0;
                sounds[name].play().catch(e => console.log('Audio error:', e));
            }
        }

        function startMusic() { music.play().catch(e => console.log('Music error:', e)); }
        function stopMusic() { music.pause(); music.currentTime = 0; }

        // Game state
        let gameState = {
            camera: 0, cameraY: 0, score: 0, coins: 0, highScore: 0, lives: 3,
            time: 300, currentLevelIndex: 0, currentRoom: 'main', powerUp: false,
            gameRunning: false, levelComplete: false, returnX: 0, returnY: 0  
        };

        window.startGame = function() {
            document.getElementById('startScreen').style.display = 'none';
            gameState.score = 0; gameState.coins = 0; gameState.lives = 3;
            lastTime = 0; 
            scoreManager.startSession();
            loadLevel(0); 
        }

        const player = {
            x: 100, y: 400, width: 32, height: 32, baseWidth: 32, baseHeight: 32,
            powerWidth: 40, powerHeight: 40, vx: 0, vy: 0, speed: 300, runSpeed: 480,    
            jumpPower: 900, gravity: 2500, onGround: false, facingRight: true, dying: false,
            coyoteTime: 0.1, coyoteTimeCounter: 0, jumpKeyHeld: false, jumpCount: 0,
            invincible: false, invincibleTimer: 0, pipeLock: false 
        };

        const keys = {};
        window.addEventListener('keydown', e => {
            keys[e.code] = true; 
            if (e.code === 'Space' || e.code === 'ArrowUp') e.preventDefault();
        });
        window.addEventListener('keyup', e => keys[e.code] = false);
        
        // Touch Controls
        const controls = [
            { el: document.getElementById('left-btn'), key: 'KeyA' },
            { el: document.getElementById('right-btn'), key: 'KeyD' },
            { el: document.getElementById('down-btn'), key: 'KeyS' },
            { el: document.getElementById('jump-btn'), key: 'Space' },
            { el: document.getElementById('run-btn'), key: 'ShiftLeft' }
        ];

        controls.forEach(c => {
            if (c.el) {
                c.el.addEventListener('touchstart', e => { e.preventDefault(); keys[c.key]=true; }, {passive:false});
                c.el.addEventListener('touchend', e => { e.preventDefault(); keys[c.key]=false; }, {passive:false});
            }
        });

        let liveLevelData = {};

        function loadLevel(levelIndex) {
            if (levelIndex >= levelTemplates.length) { console.error("Level index out of bounds:", levelIndex); return; }
            const template = levelTemplates[levelIndex];
            liveLevelData.main = JSON.parse(JSON.stringify(template.main));
            liveLevelData.bonus = JSON.parse(JSON.stringify(template.bonus));
            
            gameState.currentLevelIndex = levelIndex;
            gameState.currentRoom = 'main';
            gameState.camera = 0; gameState.cameraY = 0; gameState.time = 300; 
            gameState.powerUp = false; gameState.gameRunning = true;

            player.x = 100; player.y = 400; player.vx = 0; player.vy = 0; player.dying = false;
            player.width = player.baseWidth; player.height = player.baseHeight;
            player.coyoteTimeCounter = 0; player.jumpKeyHeld = false; player.jumpCount = 0;
            player.invincible = false; player.invincibleTimer = 0; player.pipeLock = false; 
            
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('level').textContent = levelIndex + 1;
            
            let savedScore = localStorage.getItem('squarioHighScore');
            gameState.highScore = savedScore ? parseInt(savedScore) : 0;
            document.getElementById('highScore').textContent = gameState.highScore;
            
            startMusic();
            
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if (gameState.gameRunning) {
                    gameState.time--;
                    if (gameState.time <= 0) { gameState.time = 0; playerDeath(); }
                }
            }, 1000);
        }

        function getCurrentRoom() { return liveLevelData[gameState.currentRoom]; }

        function drawPlayer() {
            if (player.invincible && Math.floor(player.invincibleTimer * 10) % 2 !== 0) return;
            ctx.fillStyle = gameState.powerUp ? '#FFD700' : '#FF0000';
            ctx.fillRect(player.x - gameState.camera, player.y - gameState.cameraY, player.width, player.height); 
            ctx.fillStyle = '#FFFFFF';
            const eyeOffset = player.facingRight ? 8 : -8;
            ctx.fillRect(player.x - gameState.camera + 10 + eyeOffset, player.y - gameState.cameraY + 10, 6, 6); 
        }

        function drawRoom() {
            const room = getCurrentRoom();
            room.platforms.forEach(p => {
                ctx.fillStyle = p.type === 'moving' ? '#6082B6' : (gameState.currentRoom === 'main' ? '#8B4513' : '#787878');
                ctx.fillRect(p.x - gameState.camera, p.y - gameState.cameraY, p.width, p.height); 
            });

            room.blocks.forEach(b => {
                if (b.hit) { ctx.fillStyle = '#A0A0A0'; ctx.fillRect(b.x - gameState.camera, b.y - gameState.cameraY, b.width, b.height); } 
                else if (b.type === 'powerup') {
                    ctx.fillStyle = '#FF8C00'; ctx.fillRect(b.x - gameState.camera, b.y - gameState.cameraY, b.width, b.height); 
                    ctx.fillStyle = '#FFF'; ctx.font = '30px Arial'; ctx.fillText('P', b.x - gameState.camera + 10, b.y - gameState.cameraY + 32); 
                } else { 
                    ctx.fillStyle = '#FFD700'; ctx.fillRect(b.x - gameState.camera, b.y - gameState.cameraY, b.width, b.height); 
                    ctx.fillStyle = '#FFF'; ctx.font = '30px Arial'; ctx.fillText('?', b.x - gameState.camera + 10, b.y - gameState.cameraY + 32); 
                }
            });

            ctx.fillStyle = '#00AA00';
            room.pipes.forEach(p => {
                ctx.fillRect(p.x - gameState.camera, p.y - gameState.cameraY, p.width, p.height); 
                ctx.fillStyle = '#006600'; ctx.fillRect(p.x - gameState.camera, p.y - gameState.cameraY, p.width, 10); 
            });

            room.enemies.forEach(e => {
                if(e.type === 'bullet') {
                    ctx.fillStyle = '#333'; ctx.beginPath();
                    ctx.arc(e.x - gameState.camera + e.width/2, e.y - gameState.cameraY + e.height/2, e.width/2, 0, Math.PI*2);
                    ctx.fill();
                    ctx.fillStyle = 'white'; ctx.fillRect(e.x - gameState.camera + 4, e.y - gameState.cameraY + 4, 6, 6);
                } else {
                    ctx.fillStyle = '#228B22'; ctx.fillRect(e.x - gameState.camera, e.y - gameState.cameraY, e.width, e.height); 
                    ctx.fillStyle = '#FFD700'; ctx.fillRect(e.x - gameState.camera + 5, e.y - gameState.cameraY + 5, e.width - 10, e.height - 10); 
                }
            });

            ctx.fillStyle = '#000000';
            room.gaps.forEach(g => { ctx.fillRect(g.x - gameState.camera, 550 - gameState.cameraY, g.width, 50); });

            ctx.fillStyle = '#CD853F';
            room.stairs.forEach(s => {
                for (let i = 0; i < s.steps; i++) {
                    ctx.fillRect(s.x + (i * 40) - gameState.camera, (550 - (i + 1) * 30) - gameState.cameraY, 40, (i + 1) * 30);
                }
            });

            if (room.flagpole) {
                ctx.fillStyle = '#444444'; ctx.fillRect(room.flagpole.x - gameState.camera, room.flagpole.y - gameState.cameraY, 10, room.flagpole.height); 
                ctx.fillStyle = '#FF0000'; ctx.fillRect(room.flagpole.x - gameState.camera + 10, room.flagpole.y - gameState.cameraY, 40, 30); 
            }
        }

        function update(dt) {
            if (!gameState.gameRunning || !liveLevelData.main) return; 
            dt = Math.min(dt, 0.05); 
            const room = getCurrentRoom();

            if (player.dying) {
                player.vy += player.gravity * dt; player.y += player.vy * dt;
                if (player.y > canvas.height + 500 + gameState.cameraY) { 
                    player.dying = false; gameState.lives--;
                    if (gameState.lives <= 0) endGame(false); else loadLevel(gameState.currentLevelIndex);
                }
                return; 
            }

            if (player.invincible) { player.invincibleTimer -= dt; if (player.invincibleTimer <= 0) player.invincible = false; }
            
            player.width = gameState.powerUp ? player.powerWidth : player.baseWidth;
            player.height = gameState.powerUp ? player.powerHeight : player.baseHeight;

            const isRunning = keys['ShiftLeft'] || keys['ShiftRight'];
            const currentSpeed = isRunning ? player.runSpeed : player.speed;
            
            if (keys['ArrowLeft'] || keys['KeyA']) { player.vx = -currentSpeed; player.facingRight = false; }
            else if (keys['ArrowRight'] || keys['KeyD']) { player.vx = currentSpeed; player.facingRight = true; }
            else player.vx = 0;

            player.coyoteTimeCounter = player.onGround ? player.coyoteTime : player.coyoteTimeCounter - dt;

            const jumpKeyActive = (keys['Space'] || keys['ArrowUp'] || keys['KeyW']);
            if (jumpKeyActive && !player.jumpKeyHeld) { 
                player.jumpKeyHeld = true;
                if (player.onGround || player.coyoteTimeCounter > 0) { 
                    player.vy = -player.jumpPower; player.onGround = false; player.coyoteTimeCounter = 0; playSound('jump'); player.jumpCount = 1;
                } else if (gameState.powerUp && player.jumpCount < 2) { 
                    player.vy = -player.jumpPower; playSound('jump'); player.jumpCount = 2;
                }
            }
            if (!jumpKeyActive) player.jumpKeyHeld = false;

            player.vy += player.gravity * dt; player.y += player.vy * dt; player.x += player.vx * dt;

            room.platforms.forEach(p => {
                if (p.type === 'moving') {
                    p.x += p.vx * dt; p.y += p.vy * dt;
                    if (p.x < p.minX || p.x > p.maxX) p.vx *= -1; if (p.y < p.minY || p.y > p.maxY) p.vy *= -1;
                }
            });

            player.onGround = false;
            
            // Collisions
            [...room.platforms, ...room.blocks, ...room.pipes].forEach(obj => {
                if (player.x + player.width > obj.x && player.x < obj.x + obj.width) {
                    if (player.y + player.height > obj.y && player.y + player.height < obj.y + 40 && player.vy > 0) {
                        player.y = obj.y - player.height; player.vy = 0; player.onGround = true; player.jumpCount = 0;
                        if (obj.type === 'moving') { player.x += obj.vx * dt; player.y += obj.vy * dt; }
                    }
                }
            });

            room.stairs.forEach(s => {
                for (let i = 0; i < s.steps; i++) {
                    const stepX = s.x + (i * 40); const stepY = 550 - (i + 1) * 30;
                    if (player.x + player.width > stepX && player.x < stepX + 40) {
                        if (player.y + player.height > stepY && player.y + player.height < stepY + 40 && player.vy > 0) {
                            player.y = stepY - player.height; player.vy = 0; player.onGround = true; player.jumpCount = 0; 
                        }
                    }
                }
            });

            room.blocks.forEach(b => {
                if (!b.hit && player.x + player.width > b.x && player.x < b.x + b.width) {
                    if (player.y < b.y + b.height && player.y > b.y && player.vy < 0) {
                        player.vy = 0; player.y = b.y + b.height; b.hit = true; gameState.score += 100;
                        if (b.type === 'powerup') { gameState.powerUp = true; playSound('powerup'); } 
                        else { 
                            playSound('coin'); gameState.coins++;
                            if(gameState.coins >= 50) { gameState.lives++; gameState.coins = 0; playSound('flagpole'); }
                        }
                    }
                }
            });

            const downKeyActive = keys['ArrowDown'] || keys['KeyS'];
            if (!downKeyActive) player.pipeLock = false;

            room.pipes.forEach(p => {
                if (player.x + player.width > p.x && player.x < p.x + p.width &&
                    player.y + player.height >= p.y && player.y + player.height <= p.y + 10) {
                    if (downKeyActive && !player.pipeLock) { 
                        playSound('pipe'); player.pipeLock = true; 
                        if (p.dest === 'bonus') {
                            gameState.returnX = p.exitX; gameState.returnY = p.exitY; gameState.currentRoom = 'bonus';
                            player.x = 100; player.y = 400; gameState.camera = 0; gameState.cameraY = 0;
                        } else if (p.dest === 'main') {
                            gameState.currentRoom = 'main'; player.x = gameState.returnX; player.y = gameState.returnY; 
                            gameState.camera = Math.max(0, player.x - 400); gameState.cameraY = 0;
                        }
                    }
                }
            });

            room.enemies.forEach(e => {
                if (e.type === 'bullet') e.x += (e.vx * 60) * dt;
                else {
                    e.x += (e.vx * 60) * dt;
                    let hitPipe = room.pipes.some(p => e.x + e.width > p.x && e.x < p.x + p.width && e.y + e.height > p.y && e.y < p.y + p.height);
                    if (hitPipe) { e.vx *= -1; e.x += (e.vx * 60) * dt * 2; }
                    let onPlatform = room.platforms.some(p => e.x + e.width > p.x && e.x < p.x + p.width && e.y + e.height >= p.y && e.y + e.height <= p.y + 20);
                    if (!onPlatform || e.x < 0 || e.x > 5000) e.vx *= -1;
                }

                if (player.x + player.width > e.x && player.x < e.x + e.width && player.y + player.height > e.y && player.y < e.y + e.height) {
                    if (player.vy > 0 && player.y + player.height - e.y < 40 && e.type !== 'bullet') {
                        playSound('stomp'); e.x = -1000; player.vy = -400; gameState.score += 200;
                    } else if (!player.invincible) { 
                        if (!gameState.powerUp) playerDeath();
                        else { playSound('hit'); gameState.powerUp = false; player.invincible = true; player.invincibleTimer = 1.5; }
                    }
                }
            });

            room.gaps.forEach(g => {
                if (player.x + player.width > g.x && player.x < g.x + g.width && player.y > 550) playerDeath();
            });

            if (room.flagpole) {
                if (player.x + player.width > room.flagpole.x && player.x < room.flagpole.x + 50 && player.y < room.flagpole.y + room.flagpole.height) {
                    playSound('flagpole'); winLevel(); 
                }
            }

            let targetCameraX = player.x - 400;
            if (targetCameraX > gameState.camera) gameState.camera = targetCameraX;
            if (player.x < gameState.camera) player.x = gameState.camera;
            
            if (canvas.height < 600) {
                let targetCamY = player.y - (canvas.height / 2);
                gameState.cameraY = Math.max(0, targetCamY);
            } else { gameState.cameraY = 0; }

            if (player.y > 700 && !player.dying) playerDeath();

            document.getElementById('score').textContent = gameState.score;
            document.getElementById('coins').textContent = gameState.coins;
            document.getElementById('lives').textContent = gameState.lives;
            document.getElementById('time').textContent = Math.ceil(gameState.time);
            document.getElementById('highScore').textContent = gameState.highScore; 
        }

        function winLevel() {
            gameState.gameRunning = false; stopMusic();
            let timeBonus = Math.ceil(gameState.time) * 10; gameState.score += timeBonus;
            let nextLevelIndex = gameState.currentLevelIndex + 1;
            if (nextLevelIndex < levelTemplates.length) setTimeout(() => loadLevel(nextLevelIndex), 2000); 
            else endGame(true); 
        }

        function playerDeath() {
            if (player.dying) return; 
            gameState.gameRunning = false; player.dying = true; player.vy = -900; 
            playSound('death'); stopMusic(); setTimeout(() => gameState.gameRunning = true, 50);
        }

        function endGame(won) {
            gameState.gameRunning = false; stopMusic();
            if (timerInterval) clearInterval(timerInterval); 
            
            // Remote Supabase stats (if logged in)
            scoreManager.submitGameResult(gameState.score);
            
            const endDiv = document.getElementById('gameOver');
            document.getElementById('endMessage').textContent = won ? 'Game Complete!' : 'Game Over!';
            
            const playTime = scoreManager.getElapsedTimeFormatted();
            document.getElementById('finalScore').textContent = `Final Score: ${gameState.score} | Time: ${playTime}`;
            
            // Local high score (unchanged behavior)
            if (gameState.score > gameState.highScore) {
                gameState.highScore = gameState.score;
                localStorage.setItem('squarioHighScore', gameState.highScore);
                document.getElementById('currentHighScore').textContent = `New High Score: ${gameState.highScore}!`;
                document.getElementById('currentHighScore').style.color = '#FFD700'; 
            } else {
                document.getElementById('currentHighScore').textContent = `High Score: ${gameState.highScore}`;
                document.getElementById('currentHighScore').style.color = 'white'; 
            }
            endDiv.style.display = 'block';
            
            // Auto-redirect to arcade after 5 seconds
            setTimeout(() => {
                window.location.href = '../arcade.html';
            }, 5000);
        }

        window.restartGame = function() {
            gameState.score = 0; gameState.lives = 3; lastTime = 0; loadLevel(0);
        }

        function drawParallaxBackground() {
            const groundY = 550; ctx.fillStyle = '#0a6c03'; 
            const backHillWidth = 600; const backScroll = (gameState.camera * 0.3) % backHillWidth;
            for (let i = -1; i < (canvas.width / backHillWidth) + 2; i++) {
                ctx.beginPath(); ctx.arc(i * backHillWidth - backScroll + (backHillWidth / 2), groundY - gameState.cameraY, backHillWidth / 2, Math.PI, 0); ctx.fill();
            }
            ctx.fillStyle = '#1a9c04'; 
            const frontHillWidth = 450; const frontScroll = (gameState.camera * 0.5) % frontHillWidth;
            for (let i = -1; i < (canvas.width / frontHillWidth) + 2; i++) {
                ctx.beginPath(); ctx.arc(i * frontHillWidth - frontScroll + (frontHillWidth / 2), (groundY + 20) - gameState.cameraY, frontHillWidth / 2, Math.PI, 0); ctx.fill();
            }
        }

        let lastTime = 0;
        function gameLoop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (liveLevelData.main && gameState.currentRoom === 'main') {
                ctx.fillStyle = '#5c94fc'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                drawParallaxBackground();
                ctx.fillStyle = 'rgba(255, 255, 250, 0.8)';
                const cloudScroll = (gameState.camera * 0.2) % 1000; 
                for (let i = 0; i < 5; i++) {
                    const cloudX = (i * 300 - cloudScroll);
                    ctx.beginPath(); ctx.arc(cloudX, 100 + i * 40 - gameState.cameraY * 0.5, 30, 0, Math.PI * 2); 
                    ctx.arc(cloudX + 25, 100 + i * 40 - gameState.cameraY * 0.5, 35, 0, Math.PI * 2);
                    ctx.arc(cloudX + 50, 100 + i * 40 - gameState.cameraY * 0.5, 30, 0, Math.PI * 2); ctx.fill();
                }
            } else if (liveLevelData.bonus && gameState.currentRoom === 'bonus') {
                ctx.fillStyle = '#6b4423'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#4a2f18';
                const rockScroll = (gameState.camera * 0.2) % 200;
                for(let i = 0; i < (canvas.width / 100) + 2; i++) {
                    const rockX = (i * 200) - rockScroll;
                    ctx.fillRect(rockX, 150 - gameState.cameraY * 0.5, 80, 80); 
                    ctx.fillRect(rockX + 90, 350 - gameState.cameraY * 0.5, 60, 60); 
                    ctx.fillRect(rockX + 30, 500 - gameState.cameraY * 0.5, 70, 70); 
                }
            } else {
                ctx.fillStyle = '#5c94fc'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            if (liveLevelData.main) { drawRoom(); drawPlayer(); update(dt); }
            requestAnimationFrame(gameLoop);
        }
        gameLoop(0);
    </script>
</body>
</html>