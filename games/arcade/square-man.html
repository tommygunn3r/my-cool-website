<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Square-Man: 8-bit Maze Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        /* Custom 8-bit look */
        body {
            font-family: 'Press Start 2P', monospace;
            background-color: #0d1117; /* Dark background */
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
            flex-direction: column;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 600px;
        }
        canvas {
            background-color: #000; /* Maze background */
            border: 4px solid #fff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            image-rendering: pixelated; /* Crucial for 8-bit look */
            touch-action: none; /* Prevent browser touch behavior */
            width: 90vw; /* Responsive width */
            max-width: 500px;
            aspect-ratio: 1 / 1; /* Keep it square */
        }
        .info-bar {
            width: 100%;
            max-width: 500px;
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            font-size: 0.8rem;
        }
        .btn-8bit {
            background-color: #ff0;
            color: #000;
            border: 3px solid #000;
            padding: 0.5rem 1rem;
            cursor: pointer;
            box-shadow: 4px 4px 0 #888;
            transition: all 0.1s;
            text-shadow: 2px 2px 0 #f00;
            font-size: 0.8rem;
            margin: 0.5rem;
        }
        .btn-8bit:hover {
            box-shadow: 2px 2px 0 #888;
            transform: translate(2px, 2px);
        }
        .btn-8bit:active {
            box-shadow: none;
            transform: translate(4px, 4px);
        }
        .mobile-controls {
            display: flex;
            gap: 10px;
            margin-top: 1rem;
            font-size: 1.5rem;
        }
        @media (min-width: 768px) {
            .mobile-controls {
                display: none; /* Hide on desktop */
            }
        }
        
        @keyframes scroll-up {
            from {
                transform: translateY(100vh);
            }
            to {
                transform: translateY(-100%);
            }
        }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        .modal-content {
            background-color: #000;
            border: 3px solid #ff0;
            box-shadow: 0 0 20px #ff0;
            padding: 40px;
            text-align: center;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .modal-content input {
            padding: 10px;
            font-size: 16px;
            background-color: #000;
            border: 2px solid #ff0;
            color: #ff0;
            font-family: 'Press Start 2P', monospace;
            text-align: center;
            margin: 10px 0;
        }
        
        .modal-content button {
            background-color: #ff0;
            color: #000;
            border: none;
            padding: 10px 20px;
            margin-top: 20px;
            font-family: 'Press Start 2P', monospace;
            font-size: 0.8rem;
            cursor: pointer;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body class="p-4">

    <div class="game-container">
        <h1 class="text-3xl mb-4 text-yellow-400">Square-Man</h1>
        <div class="info-bar">
            <div id="scoreDisplay">SCORE: 000</div>
            <div id="highScoreDisplay">HIGH: ---</div>
            <div id="livesDisplay">LIVES: 3</div>
        </div>
        <canvas id="gameCanvas" width="500" height="500"></canvas>
        <div id="messageBox" class="text-center text-xl mt-4 p-2 rounded-lg bg-red-800 text-yellow-400 hidden">
            <p>Ready!</p>
        </div>
        <button id="startButton" class="btn-8bit mt-6">
            Start Game (Click to Enable Audio)
        </button>
        <div class="mobile-controls">
            <button class="btn-8bit" onclick="handleTouchInput('up')">▲</button>
            <div class="flex flex-col">
                <button class="btn-8bit" onclick="handleTouchInput('left')">◀</button>
                <button class="btn-8bit" onclick="handleTouchInput('right')">▶</button>
            </div>
            <button class="btn-8bit" onclick="handleTouchInput('down')">▼</button>
        </div>
    </div>

    <!-- End Modal -->
    <div id="endModal" class="modal" style="display:none;">
        <div class="modal-content">
            <h2 style="color: #ff0; font-size: 1.5rem; margin-bottom: 1rem;">GAME OVER!</h2>
            <p style="color: #fff; margin: 10px 0;">Final Score: <span id="finalScore" style="color: #ff0;">0</span></p>
            <p style="color: #fff; margin: 10px 0;">Level Reached: <span id="finalLevel" style="color: #0ff;">1</span></p>
            <div style="margin-top: 20px;">
                <input type="text" id="playerNameInput" placeholder="Enter your name" maxlength="20">
            </div>
            <button onclick="submitAndShowCredits()">SUBMIT SCORE</button>
        </div>
    </div>

    <!-- Credits Screen -->
    <div id="creditsScreen" class="modal" style="display:none;">
        <div style="text-align: center; animation: scroll-up 15s linear; width: 100%; color: #fff;">
            <pre style="font-size: 16px; color: #ff0; margin: 20px 0;">
  ____   ___  _   _   _    ____  _____       __  __    _    _   _ 
 / ___| / _ \| | | | / \  |  _ \| ____|     |  \/  |  / \  | \ | |
 \___ \| | | | | | |/ _ \ | |_) |  _| _____ | |\/| | / _ \ |  \| |
  ___) | |_| | |_| / ___ \|  _ <| |__|_____|| |  | |/ ___ \| |\  |
 |____/ \__\_\\___/_/   \_\_| \_\_____|     |_|  |_/_/   \_\_| \_|
            </pre>
            
            <div style="margin: 40px 0; font-size: 24px;">
                <p style="color: #ff0;">FINAL SCORE</p>
                <p id="creditsScore" style="font-size: 36px; color: #0f0; margin: 10px 0;">0</p>
            </div>
            
            <div style="margin: 40px 0; font-size: 20px;">
                <p style="color: #0ff;">━━━━━━━━━━━━━━━━━━━━</p>
                <p style="color: #ff0; margin: 10px 0;">LEVEL REACHED</p>
                <p id="creditsLevel" style="color: #0f0; font-size: 28px; margin: 10px 0;">1</p>
                <p style="color: #0ff;">━━━━━━━━━━━━━━━━━━━━</p>
            </div>
            
            <div style="margin: 60px 0; font-size: 16px; line-height: 1.8; color: #0f0;">
                <p style="color: #ff0; font-size: 20px; margin-bottom: 20px;">CREDITS</p>
                
                <p style="margin-top: 20px;">LEAD PROGRAMMER</p>
                <p style="color: #0ff;">Claude.ai</p>
                
                <p style="margin-top: 20px;">GAME DESIGN</p>
                <p style="color: #0ff;">GUNNERSGAMES</p>
                
                <p style="margin-top: 20px;">INSPIRED BY</p>
                <p style="color: #0ff;">PAC-MAN (1980)</p>
                
                <p style="margin-top: 30px;">SPECIAL THANKS</p>
                <p style="color: #0ff;">ALL SQUARE-MAN FANS</p>
                
                <p style="margin-top: 50px; color: #ff0; font-size: 16px;">© 2025 GUNNERSGAMES</p>
                <p style="margin-top: 20px; font-size: 14px; color: #888;">THANKS FOR PLAYING!</p>
            </div>
        </div>
    </div>

    <script type="module">
        // ===== SUPABASE INTEGRATION =====
        import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm';
        
        const SUPABASE_URL = 'https://pknhslxhpohrzgsfkisr.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBrbmhzbHhocG9ocnpnc2ZraXNyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzU1OTY5NjUsImV4cCI6MjA1MTE3Mjk2NX0.tIUj3jIMX5c_jsdjL4RrfwW7wH-8Ry93y5kKOj0uEao';
        
        const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        
        let currentUser = null;
        let playerName = "Anonymous";

        // Check for logged in user
        async function initGameAuth() {
            try {
                const { data: { user } } = await supabase.auth.getUser();
                
                if (!user) {
                    console.log("Not logged in - guest mode");
                    return;
                }
                
                currentUser = user;
                playerName = user.user_metadata?.display_name || 
                            user.email?.split('@')[0] || 
                            "Anonymous";
                console.log("Authenticated:", playerName);
                
                await loadHighScore();
            } catch (err) {
                console.warn("Auth check failed:", err);
            }
        }

        async function loadHighScore() {
            if (!currentUser) return;
            
            try {
                const { data, error } = await supabase
                    .from('game_highscores')
                    .select('score')
                    .eq('game_id', 'square-man')
                    .eq('user_id', currentUser.id)
                    .order('score', { ascending: false })
                    .limit(1)
                    .single();
                
                if (data && !error) {
                    document.getElementById('highScoreDisplay').textContent = `HIGH: ${String(data.score).padStart(3, '0')}`;
                }
            } catch (error) {
                console.warn('Could not load high score:', error);
            }
        }

        async function submitHighScore(score, playerNameSubmit) {
            if (!currentUser) {
                console.log("No user logged in, score not saved");
                return;
            }

            try {
                const { error } = await supabase
                    .from('game_highscores')
                    .insert({
                        user_id: currentUser.id,
                        game_id: 'square-man',
                        player_name: playerNameSubmit,
                        score: Math.floor(score)
                    });

                if (error) throw error;
                console.log("Score submitted:", score);
            } catch (error) {
                console.error("Score submission failed:", error);
            }
        }

        // Global function for submit and show credits
        window.submitAndShowCredits = async function() {
            const playerNameValue = document.getElementById('playerNameInput').value.trim() || playerName;
            const finalScore = parseInt(document.getElementById('finalScore').textContent);
            const finalLevel = parseInt(document.getElementById('finalLevel').textContent);
            
            await submitHighScore(finalScore, playerNameValue);

            // Show credits
            document.getElementById('endModal').style.display = 'none';
            document.getElementById('creditsScore').textContent = finalScore;
            document.getElementById('creditsLevel').textContent = finalLevel;
            document.getElementById('creditsScreen').style.display = 'flex';

            // Redirect to arcade after 15 seconds
            setTimeout(() => {
                if (window.parent !== window) {
                    window.parent.postMessage({ action: 'closeGame' }, '*');
                } else {
                    window.location.href = '/arcade.html';
                }
            }, 15000);
        };

        initGameAuth();

        // ===== GAME CODE =====

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const highScoreDisplay = document.getElementById('highScoreDisplay');
        const livesDisplay = document.getElementById('livesDisplay');
        const messageBox = document.getElementById('messageBox');
        const startButton = document.getElementById('startButton');

        const GRID_ROWS = 21;
        const GRID_COLS = 21;
        let TILE_SIZE = canvas.width / GRID_COLS;

        const MOVE_THRESHOLD = 0.1;

        const GHOST_EXIT_TARGET = { row: 7, col: 10 };

        // 0 = Dot, 1 = Wall, 2 = Empty (eaten dot), 3 = Power-Up, 4 = Ghost Home, 5 = Tunnel
        const MAP = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
            [1,3,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1,3,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1],
            [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
            [1,1,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1],
            [1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1],
            [1,1,1,1,0,1,0,1,1,4,4,4,1,1,0,1,0,1,1,1,1],
            [5,0,0,0,0,0,0,1,4,4,4,4,4,1,0,0,0,0,0,0,5],
            [1,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,1,1,1],
            [1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1],
            [1,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1,0,1],
            [1,3,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,3,1],
            [1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,0,1,1],
            [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
            [1,0,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        let game = null;
        let lastTimestamp = null;

        // --- Audio ---
        let bgmSynth = null;
        let deathSound = null;

        function setupAudio() {
            bgmSynth = new Tone.Synth({
                oscillator: { type: 'square' },
                envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 1 }
            }).toDestination();

            const bgmMelody = ['C4', 'E4', 'G4', 'C5'];
            let bgmIndex = 0;

            Tone.Transport.scheduleRepeat((time) => {
                if (game && game.isRunning && !game.isPaused) {
                    bgmSynth.triggerAttackRelease(bgmMelody[bgmIndex % bgmMelody.length], '8n', time);
                    bgmIndex++;
                }
            }, '0.5s');
        }

        function startBGM() {
            if (Tone.Transport.state !== 'started') {
                Tone.Transport.start();
            }
        }

        function stopBGM() {
            Tone.Transport.stop();
        }

        function playMunch() {
            const synth = new Tone.Synth({
                oscillator: { type: 'square' },
                envelope: { attack: 0.01, decay: 0.05, sustain: 0, release: 0.05 }
            }).toDestination();
            synth.triggerAttackRelease('C5', '32n');
        }

        function playPowerUp() {
            const synth = new Tone.Synth({
                oscillator: { type: 'square' },
                envelope: { attack: 0.01, decay: 0.1, sustain: 0.3, release: 0.2 }
            }).toDestination();
            synth.triggerAttackRelease('E5', '8n');
        }

        function playDeathSound() {
            const synth = new Tone.Synth({
                oscillator: { type: 'sawtooth' },
                envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.5 }
            }).toDestination();
            
            // Descending death sound
            const now = Tone.now();
            synth.triggerAttackRelease('C5', '16n', now);
            synth.triggerAttackRelease('A4', '16n', now + 0.1);
            synth.triggerAttackRelease('F4', '16n', now + 0.2);
            synth.triggerAttackRelease('D4', '16n', now + 0.3);
            synth.triggerAttackRelease('A3', '8n', now + 0.4);
        }

        // --- Utility Functions ---
        function manhattanDistance(r1, c1, r2, c2) {
            return Math.abs(r1 - r2) + Math.abs(c1 - c2);
        }

        // --- Entity Base Class ---
        class Entity {
            constructor(row, col, color) {
                this.row = row;
                this.col = col;
                this.currentDirection = 'none';
                this.nextDirection = 'none';
                this.speed = 0.1;
                this.color = color;
                this.sizeRatio = 0.7;
            }

            draw() {
                const x = this.col * TILE_SIZE + TILE_SIZE / 2;
                const y = this.row * TILE_SIZE + TILE_SIZE / 2;
                const size = TILE_SIZE * this.sizeRatio;
                
                ctx.fillStyle = this.color;
                ctx.fillRect(x - size / 2, y - size / 2, size, size);
            }

            move(map, delta) {
                this.handleTurns(map);

                if (this.currentDirection === 'none') return false;

                const moveAmount = this.speed * delta;
                let nextRow = this.row;
                let nextCol = this.col;

                if (this.currentDirection === 'up') nextRow -= moveAmount;
                else if (this.currentDirection === 'down') nextRow += moveAmount;
                else if (this.currentDirection === 'left') nextCol -= moveAmount;
                else if (this.currentDirection === 'right') nextCol += moveAmount;

                const r = Math.round(nextRow);
                const c = Math.round(nextCol);

                if (r < 0 || r >= GRID_ROWS || c < 0 || c >= GRID_COLS) {
                    if (this.row === 9.0 || this.row === 10.0) {
                        this.row = nextRow;
                        this.col = nextCol;
                    } else {
                        this.currentDirection = 'none';
                        return false;
                    }
                } else {
                    const tileAhead = map[r][c];
                    const isGhostLeavingHome = (this instanceof Ghost) && this.isLeavingHome;
                    let blocksMovement = tileAhead === 1;
                    
                    if (!isGhostLeavingHome) {
                        blocksMovement = blocksMovement || (tileAhead === 4);
                    }

                    if (blocksMovement) {
                        this.currentDirection = 'none';
                        return false;
                    } else {
                        this.row = nextRow;
                        this.col = nextCol;
                    }
                }

                // Teleport Check (Boundary Wrap-around)
                if (this.col < 0) {
                    this.col = GRID_COLS - 1;
                    this.row = 9.0;
                } else if (this.col >= GRID_COLS) {
                    this.col = 0;
                    this.row = 9.0;
                }

                const moved = this.currentDirection !== 'none';

                // Stuck recovery auto-center
                {
                    const rCenter = Math.round(this.row);
                    const cCenter = Math.round(this.col);
                    const tileHere = map[rCenter]?.[cCenter];
                    if (!moved && tileHere !== 4) {
                        this.row = rCenter;
                        this.col = cCenter;
                    }
                }

                return moved; 
            }

            handleTurns(map) {
                const rowCenter = Math.round(this.row);
                const colCenter = Math.round(this.col);
                
                const isAligned = (Math.abs(this.row - rowCenter) < MOVE_THRESHOLD) && 
                                  (Math.abs(this.col - colCenter) < MOVE_THRESHOLD);

                if (this.nextDirection !== 'none') {
                    let nextR = rowCenter;
                    let nextC = colCenter;
                    if (this.nextDirection === 'up') nextR--;
                    else if (this.nextDirection === 'down') nextR++;
                    else if (this.nextDirection === 'left') nextC--;
                    else if (this.nextDirection === 'right') nextC++;

                    const isGhostLeavingHome = (this instanceof Ghost) && this.isLeavingHome;
                    let blocksTile = map[nextR] && map[nextR][nextC] === 1;

                    if (!isGhostLeavingHome) {
                        blocksTile = blocksTile || (map[nextR] && map[nextR][nextC] === 4);
                    }

                    if (map[nextR] && !blocksTile) {
                        if (isAligned || this.currentDirection === 'none') { 
                            this.row = rowCenter;
                            this.col = colCenter;
                            this.currentDirection = this.nextDirection;
                            this.nextDirection = 'none';
                        }
                    }
                }
            }
        }

        class Player extends Entity {
            constructor(row, col) {
                super(row, col, '#ff0');
                this.baseSizeRatio = 0.8;
                this.sizeRatio = this.baseSizeRatio;
                this.isPoweredUp = false;
                this.powerUpTimer = 0;
                this.speed = 0.12;
                this.isDying = false;
                this.deathAnimationFrame = 0;
            }

            update(map, ghosts, delta) {
                if (this.isDying) {
                    this.deathAnimationFrame++;
                    return;
                }

                if (this.move(map, delta)) {
                    this.checkCollisions(map, ghosts);
                }

                if (this.isPoweredUp) {
                    this.powerUpTimer -= delta;
                    this.sizeRatio = this.baseSizeRatio * 1.2;
                    if (this.powerUpTimer <= 0) {
                        this.isPoweredUp = false;
                        this.sizeRatio = this.baseSizeRatio;
                        ghosts.forEach(g => g.color = g.originalColor);
                    }
                }
            }

            checkCollisions(map, ghosts) {
                const r = Math.round(this.row);
                const c = Math.round(this.col);

                if (r < 0 || r >= GRID_ROWS || c < 0 || c >= GRID_COLS) return;

                const tileValue = map[r][c];

                if (tileValue === 0) {
                    map[r][c] = 2;
                    game.score += 10;
                    game.dotsRemaining--;
                    playMunch();
                } else if (tileValue === 3) {
                    map[r][c] = 2;
                    this.isPoweredUp = true;
                    this.powerUpTimer = 300;
                    game.score += 50;
                    playPowerUp();
                    ghosts.forEach(g => g.color = '#00f');
                }
            }

            startDeathAnimation() {
                this.isDying = true;
                this.deathAnimationFrame = 0;
                playDeathSound();
            }

            draw() {
                if (this.isDying) {
                    this.drawDeathAnimation();
                    return;
                }

                const x = this.col * TILE_SIZE + TILE_SIZE / 2;
                const y = this.row * TILE_SIZE + TILE_SIZE / 2;
                const size = TILE_SIZE * this.sizeRatio;
                
                ctx.fillStyle = this.color;
                ctx.fillRect(x - size / 2, y - size / 2, size, size);
            }

            drawDeathAnimation() {
                const x = this.col * TILE_SIZE + TILE_SIZE / 2;
                const y = this.row * TILE_SIZE + TILE_SIZE / 2;
                const baseSize = TILE_SIZE * this.baseSizeRatio;
                
                const progress = Math.min(this.deathAnimationFrame / 60, 1);
                
                if (progress < 1) {
                    // Split into 4 pieces moving apart
                    const spread = progress * TILE_SIZE * 0.5;
                    const pieceSize = baseSize / 2.5;
                    const fade = 1 - progress * 0.5;
                    
                    ctx.fillStyle = `rgba(255, 255, 0, ${fade})`;
                    
                    // Top-left piece
                    ctx.fillRect(x - spread - pieceSize/2, y - spread - pieceSize/2, pieceSize, pieceSize);
                    // Top-right piece
                    ctx.fillRect(x + spread - pieceSize/2, y - spread - pieceSize/2, pieceSize, pieceSize);
                    // Bottom-left piece
                    ctx.fillRect(x - spread - pieceSize/2, y + spread - pieceSize/2, pieceSize, pieceSize);
                    // Bottom-right piece
                    ctx.fillRect(x + spread - pieceSize/2, y + spread - pieceSize/2, pieceSize, pieceSize);
                }
            }
        }

        class Ghost extends Entity {
            constructor(row, col, color) {
                super(row, col, color);
                this.originalColor = color;
                this.startRow = row;
                this.startCol = col;
                this.speed = 0.08;
                this.isLeavingHome = true;
                this.scatterTarget = { row: 1, col: 1 }; // Default scatter target
                this.chaseMode = true;
                this.modeTimer = 0;
            }

            update(map, player, delta) {
                // Update chase/scatter mode timer
                this.modeTimer++;
                if (this.modeTimer > 600) { // Switch modes every ~10 seconds
                    this.chaseMode = !this.chaseMode;
                    this.modeTimer = 0;
                }

                this.nextDirection = this.determineNextAction(map, player);
                this.move(map, delta);
                this.checkPlayerCollision(player);

                if (this.isLeavingHome) {
                    const r = Math.round(this.row);
                    const c = Math.round(this.col);
                    if (r === GHOST_EXIT_TARGET.row && c === GHOST_EXIT_TARGET.col) {
                        this.isLeavingHome = false;
                    }
                }
            }
            
            determineNextAction(map, player) {
                const r = Math.round(this.row);
                const c = Math.round(this.col);
                
                if (Math.abs(this.row - r) > 0.01 || Math.abs(this.col - c) > 0.01) {
                    return this.nextDirection;
                }

                let targetR, targetC;

                if (this.isLeavingHome) {
                    targetR = GHOST_EXIT_TARGET.row;
                    targetC = GHOST_EXIT_TARGET.col;
                    return this.chooseDirectionToTarget(map, targetR, targetC, false);
                } else if (player.isPoweredUp && this.color === '#00f') {
                    // Flee Mode: Run away from player
                    targetR = r < GRID_ROWS / 2 ? GRID_ROWS - 2 : 1;
                    targetC = c < GRID_COLS / 2 ? GRID_COLS - 2 : 1;
                    return this.chooseDirectionToTarget(map, targetR, targetC, true);
                } else if (this.chaseMode) {
                    // Chase Mode: Go directly toward player
                    targetR = Math.round(player.row);
                    targetC = Math.round(player.col);
                    return this.chooseDirectionToTarget(map, targetR, targetC, false);
                } else {
                    // Scatter Mode: Go to scatter corner
                    return this.chooseDirectionToTarget(map, this.scatterTarget.row, this.scatterTarget.col, false);
                }
            }

            chooseDirectionToTarget(map, targetR, targetC, isFleeing) {
                const directions = ['up', 'down', 'left', 'right'];
                let bestDir = 'none';
                let bestScore = isFleeing ? -1 : Infinity;
                
                const r = Math.round(this.row);
                const c = Math.round(this.col);

                for (const dir of directions) {
                    const tempRow = r + (dir === 'up' ? -1 : dir === 'down' ? 1 : 0);
                    const tempCol = c + (dir === 'left' ? -1 : dir === 'right' ? 1 : 0);

                    if (tempRow < 0 || tempRow >= GRID_ROWS || tempCol < 0 || tempCol >= GRID_COLS) continue;

                    const isBlocked = map[tempRow][tempCol] === 1 || (!this.isLeavingHome && map[tempRow][tempCol] === 4);

                    if (!isBlocked) {
                        if (this.getOppositeDirection(this.currentDirection) !== dir) {
                            const dist = manhattanDistance(tempRow, tempCol, targetR, targetC);
                            
                            if (isFleeing) {
                                if (dist > bestScore) {
                                    bestScore = dist;
                                    bestDir = dir;
                                }
                            } else {
                                if (dist < bestScore) {
                                    bestScore = dist;
                                    bestDir = dir;
                                }
                            }
                        }
                    }
                }
                
                if (bestDir === 'none' && this.currentDirection !== 'none') {
                    const opposite = this.getOppositeDirection(this.currentDirection);
                    const tempRow = r + (opposite === 'up' ? -1 : opposite === 'down' ? 1 : 0);
                    const tempCol = c + (opposite === 'left' ? -1 : opposite === 'right' ? 1 : 0);

                    if (tempRow >= 0 && tempRow < GRID_ROWS && tempCol >= 0 && tempCol < GRID_COLS) {
                        const isBlocked = map[tempRow][tempCol] === 1 || (!this.isLeavingHome && map[tempRow][tempCol] === 4);
                        if (!isBlocked) {
                             return opposite;
                        }
                    }
                }

                return bestDir;
            }

            getOppositeDirection(dir) {
                if (dir === 'up') return 'down';
                if (dir === 'down') return 'up';
                if (dir === 'left') return 'right';
                if (dir === 'right') return 'left';
                return 'none';
            }

            checkPlayerCollision(player) {
                if (player.isDying) return;

                const distance = Math.sqrt(Math.pow(this.row - player.row, 2) + Math.pow(this.col - player.col, 2));

                if (distance < 0.7) {
                    if (player.isPoweredUp && this.color === '#00f') {
                        game.score += 200;
                        this.respawn();
                        player.powerUpTimer = Math.max(0, player.powerUpTimer - 60);
                    } else {
                        game.loseLife();
                    }
                }
            }

            respawn() {
                this.row = this.startRow;
                this.col = this.startCol;
                this.currentDirection = 'none';
                this.nextDirection = 'none';
                this.isLeavingHome = true;
                this.color = this.originalColor;
            }
        }

        // --- Game Manager ---

        class DotMuncherGame {
            constructor() {
                this.score = 0;
                this.lives = 3;
                this.level = 1;
                this.isRunning = false;
                this.isPaused = true;
                this.dotsRemaining = 0;
                this.player = null;
                this.ghosts = [];
                this.map = this.deepCopyMap(MAP);

                this.initialize();
                window.addEventListener('resize', this.resizeCanvas.bind(this));
            }

            deepCopyMap(original) {
                return original.map(row => [...row]);
            }

            initialize() {
                this.score = 0;
                this.lives = 3;
                this.level = 1;
                this.dotsRemaining = 0;
                this.map = this.deepCopyMap(MAP);

                for (let r = 0; r < GRID_ROWS; r++) {
                    for (let c = 0; c < GRID_COLS; c++) {
                        if (this.map[r][c] === 0 || this.map[r][c] === 3) {
                            this.dotsRemaining++;
                        }
                    }
                }

                this.player = new Player(16.0, 10.0);

                // Initialize ghosts with different scatter corners
                this.ghosts = [
                    new Ghost(9.0, 9.0, '#f00'),   // Red - top right corner
                    new Ghost(9.0, 11.0, '#ff8800'), // Orange - top left corner
                    new Ghost(10.0, 9.0, '#0f0'),    // Green - bottom right corner
                    new Ghost(10.0, 11.0, '#ffc0cb'), // Pink - bottom left corner
                ];
                
                // Set scatter targets for each ghost
                this.ghosts[0].scatterTarget = { row: 1, col: GRID_COLS - 2 };
                this.ghosts[1].scatterTarget = { row: 1, col: 1 };
                this.ghosts[2].scatterTarget = { row: GRID_ROWS - 2, col: GRID_COLS - 2 };
                this.ghosts[3].scatterTarget = { row: GRID_ROWS - 2, col: 1 };

                this.resizeCanvas();
                this.updateDisplay();
                this.showMessage("GET READY!", false);
            }

            resizeCanvas() {
                const container = canvas.parentElement;
                const size = container.clientWidth || 500;
                TILE_SIZE = Math.floor(Math.min(size, 500) / GRID_COLS);
            }

            start() {
                if (this.isRunning && !this.isPaused) return;
                
                this.isPaused = false;
                this.isRunning = true;
                this.hideMessage();
                startBGM();
                lastTimestamp = null;
                requestAnimationFrame(this.gameLoop.bind(this));
            }

            pause() {
                if (!this.isRunning) return;
                this.isPaused = !this.isPaused;
                if (this.isPaused) {
                    stopBGM();
                    this.showMessage("PAUSED - Press P to Resume", true);
                } else {
                    startBGM();
                    this.hideMessage();
                }
            }

            loseLife() {
                this.lives--;
                this.updateDisplay();
                
                if (this.lives <= 0) {
                    // Start death animation
                    this.player.startDeathAnimation();
                    this.isPaused = true;
                    stopBGM();
                    
                    // Wait for death animation to complete
                    setTimeout(() => {
                        this.gameOver();
                    }, 1500);
                    return;
                }
                
                // Start death animation for life lost
                this.player.startDeathAnimation();
                this.isPaused = true;
                stopBGM();
                
                setTimeout(() => {
                    this.resetPositions();
                }, 1500);
            }

            resetPositions() {
                this.isPaused = true;
                this.player.row = 16.0;
                this.player.col = 10.0;
                this.player.currentDirection = 'none';
                this.player.nextDirection = 'none';
                this.player.isPoweredUp = false;
                this.player.powerUpTimer = 0;
                this.player.sizeRatio = this.player.baseSizeRatio;
                this.player.isDying = false;
                this.player.deathAnimationFrame = 0;

                this.ghosts.forEach(g => {
                    g.respawn();
                });

                this.showMessage(`LIFE LOST! LIVES: ${this.lives}`, false);
                setTimeout(() => {
                    this.showMessage("GET READY!", false);
                    setTimeout(() => {
                        this.isPaused = false;
                        this.hideMessage();
                        startBGM();
                    }, 2000);
                }, 1000);
            }

            gameOver() {
                this.isRunning = false;
                this.isPaused = true;
                stopBGM();
                
                // Show end modal
                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('finalLevel').textContent = this.level;
                document.getElementById('playerNameInput').value = playerName;
                document.getElementById('endModal').style.display = 'flex';
            }

            winGame() {
                this.isRunning = false;
                this.isPaused = true;
                stopBGM();
                
                this.level++;
                const levelBonus = 1000 * this.level;
                this.score += levelBonus;
                
                this.showMessage(`LEVEL ${this.level - 1} COMPLETE! Bonus: ${levelBonus}`, false);
                
                setTimeout(() => {
                    this.nextLevel();
                }, 3000);
            }
            
            nextLevel() {
                this.map = this.deepCopyMap(MAP);
                this.dotsRemaining = 0;
                
                for (let r = 0; r < GRID_ROWS; r++) {
                    for (let c = 0; c < GRID_COLS; c++) {
                        if (this.map[r][c] === 0 || this.map[r][c] === 3) {
                            this.dotsRemaining++;
                        }
                    }
                }
                
                this.player.row = 16.0;
                this.player.col = 10.0;
                this.player.currentDirection = 'none';
                this.player.nextDirection = 'none';
                this.player.isPoweredUp = false;
                this.player.powerUpTimer = 0;
                this.player.sizeRatio = this.player.baseSizeRatio;
                
                this.ghosts.forEach(g => g.respawn());
                
                // Increase ghost speed slightly each level
                this.ghosts.forEach(g => {
                    g.speed = 0.08 + (this.level * 0.005);
                });
                
                this.updateDisplay();
                this.showMessage(`LEVEL ${this.level} - GET READY!`, false);
                
                setTimeout(() => {
                    this.isPaused = false;
                    this.isRunning = true;
                    this.hideMessage();
                    startBGM();
                }, 2000);
            }

            update(delta) {
                if (this.isPaused || !this.isRunning) return;

                this.player.update(this.map, this.ghosts, delta);
                this.ghosts.forEach(g => g.update(this.map, this.player, delta));

                this.updateDisplay();

                if (this.dotsRemaining === 0) {
                    this.winGame();
                }
            }

            draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                for (let r = 0; r < GRID_ROWS; r++) {
                    for (let c = 0; c < GRID_COLS; c++) {
                        const x = c * TILE_SIZE;
                        const y = r * TILE_SIZE;

                        const tile = this.map[r][c];

                        if (tile === 1) {
                            ctx.fillStyle = '#0044ff';
                            ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                            ctx.strokeStyle = '#002288';
                            ctx.lineWidth = 1;
                            ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);
                        } else if (tile === 5) {
                            ctx.fillStyle = '#000';
                            ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                        } else if (tile === 0) {
                            ctx.fillStyle = '#fff';
                            const dotSize = TILE_SIZE / 6;
                            ctx.fillRect(x + TILE_SIZE / 2 - dotSize / 2, y + TILE_SIZE / 2 - dotSize / 2, dotSize, dotSize);
                        } else if (tile === 3) {
                            ctx.fillStyle = '#ff00ff';
                            const puSize = TILE_SIZE / 3;
                            ctx.fillRect(x + TILE_SIZE / 2 - puSize / 2, y + TILE_SIZE / 2 - puSize / 2, puSize, puSize);
                        }
                    }
                }

                this.player.draw();
                this.ghosts.forEach(g => g.draw());
            }

            gameLoop(timestamp) {
                if (lastTimestamp === null) lastTimestamp = timestamp;
                const delta = (timestamp - lastTimestamp) / 16.67;
                lastTimestamp = timestamp;

                this.update(delta);
                this.draw();
                if (this.isRunning) {
                    requestAnimationFrame(this.gameLoop.bind(this));
                }
            }

            updateDisplay() {
                scoreDisplay.textContent = `SCORE: ${String(this.score).padStart(3, '0')}`;
                livesDisplay.textContent = `LIVES: ${this.lives}`;
            }

            showMessage(text, isPermanent = false, bgColor = 'bg-red-800') {
                messageBox.classList.remove('hidden', 'bg-red-800', 'bg-green-900');
                messageBox.classList.add(bgColor);
                messageBox.innerHTML = `<p>${text}</p>`;

                if (!isPermanent) {
                    setTimeout(() => {
                        messageBox.classList.add('hidden');
                    }, 1500);
                }
            }

            hideMessage() {
                messageBox.classList.add('hidden');
            }
        }

        // --- Input and Event Handlers ---

        function handleKeyDown(e) {
            if (!game) return;
            
            if (!game.isRunning) return;
            
            if (game.isPaused) {
                if (e.key === ' ' || e.key === 'Enter') {
                    game.start();
                }
                return;
            }

            let newDir = 'none';
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                    newDir = 'up'; break;
                case 'ArrowDown':
                case 's':
                    newDir = 'down'; break;
                case 'ArrowLeft':
                case 'a':
                    newDir = 'left'; break;
                case 'ArrowRight':
                case 'd':
                    newDir = 'right'; break;
                case 'p':
                    game.pause();
                    break;
            }
            if (newDir !== 'none') {
                game.player.nextDirection = newDir;
            }
        }

        window.handleTouchInput = function(direction) {
            if (game && game.isRunning && !game.isPaused) {
                game.player.nextDirection = direction;
            } else if (game && !game.isRunning) {
                 game.start();
            }
        }

        let touchstartX = 0;
        let touchstartY = 0;

        canvas.addEventListener('touchstart', e => {
            if (e.touches.length === 1) {
                touchstartX = e.touches[0].clientX;
                touchstartY = e.touches[0].clientY;
            }
            e.preventDefault();
        }, { passive: false });

        canvas.addEventListener('touchend', e => {
            const touchendX = e.changedTouches[0].clientX;
            const touchendY = e.changedTouches[0].clientY;

            const diffX = touchendX - touchstartX;
            const diffY = touchendY - touchstartY;

            if (Math.abs(diffX) > 10 || Math.abs(diffY) > 10) {
                if (Math.abs(diffX) > Math.abs(diffY)) {
                    game.player.nextDirection = diffX > 0 ? 'right' : 'left';
                } else {
                    game.player.nextDirection = diffY > 0 ? 'down' : 'up';
                }
            }
            e.preventDefault();
        }, { passive: false });

        // --- Initialization ---

        function initGame() {
            game = new DotMuncherGame();
            setupAudio();
            document.addEventListener('keydown', handleKeyDown);

            startButton.addEventListener('click', async () => {
                await Tone.start();
                startButton.textContent = 'Use Arrow Keys/WASD or Swipe to Play!';
                startButton.disabled = true;
                startButton.classList.add('hidden');
                game.start();
            });

            game.draw();
        }

        window.onload = initGame;
    </script>
</body>
</html>