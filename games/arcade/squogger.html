<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Squogger - GunnersGames</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial Black', Arial, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a0a1a 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: white;
        }

        .game-container {
            text-align: center;
            padding: 20px;
        }

        h1 {
            font-size: 3em;
            color: #ffff00;
            text-shadow: 0 0 20px #ffaa00, 0 0 40px #ffaa00;
            margin-bottom: 10px;
        }

        .game-info {
            display: flex;
            justify-content: space-around;
            max-width: 600px;
            margin: 20px auto;
            font-size: 1.2em;
        }

        .info-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #9370db;
            box-shadow: 0 0 10px #9370db;
        }

        .info-label {
            color: #9370db;
            font-size: 0.8em;
        }

        .info-value {
            color: #ffff00;
            font-size: 1.3em;
            font-weight: bold;
        }

        #gameCanvas {
            border: 4px solid #9370db;
            box-shadow: 0 0 30px #9370db, inset 0 0 20px rgba(147, 112, 219, 0.2);
            background: #000;
            display: block;
            margin: 20px auto;
            max-width: 95vw;
        }

        .controls {
            margin-top: 20px;
            color: #ffff00;
            font-size: 1.1em;
        }

        .game-over-screen, .start-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border: 4px solid #9370db;
            border-radius: 20px;
            box-shadow: 0 0 40px #9370db;
            display: none;
            text-align: center;
            z-index: 10;
        }

        .game-over-screen h2, .start-screen h2 {
            font-size: 2.5em;
            color: #ffff00;
            text-shadow: 0 0 20px #ffaa00;
            margin-bottom: 20px;
        }

        .game-over-screen p, .start-screen p {
            font-size: 1.3em;
            margin: 10px 0;
            color: #9370db;
        }

        button {
            background: linear-gradient(135deg, #9370db, #ba90ff);
            border: none;
            color: white;
            padding: 15px 40px;
            font-size: 1.3em;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 0 20px #9370db;
            transition: all 0.3s;
        }

        button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px #9370db;
        }

        .lives {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
        }

        .life {
            width: 30px;
            height: 30px;
            background: #ffff00;
            border: 2px solid #fff;
            box-shadow: 0 0 10px #ffaa00;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>SQUOGGER</h1>
        
        <div class="game-info">
            <div class="info-item">
                <div class="info-label">SCORE</div>
                <div class="info-value" id="score">0</div>
            </div>
            <div class="info-item">
                <div class="info-label">LEVEL</div>
                <div class="info-value" id="level">1</div>
            </div>
            <div class="info-item">
                <div class="info-label">HIGH SCORE</div>
                <div class="info-value" id="highScore">0</div>
            </div>
        </div>

        <div class="lives" id="livesDisplay"></div>

        <canvas id="gameCanvas" width="800" height="600"></canvas>

        <div class="controls">
            ðŸŽ® Use ARROW KEYS to move | Reach the top safely!
        </div>

        <div class="start-screen" id="startScreen">
            <h2>SQUOGGER</h2>
            <p>Guide the square frog to safety!</p>
            <p>ðŸš— Avoid traffic</p>
            <p>ðŸªµ Hop on logs and lily pads</p>
            <p>ðŸŽ¯ Reach the goal zones at the top</p>
            <button onclick="startGame()">START GAME</button>
        </div>

        <div class="game-over-screen" id="gameOverScreen">
            <h2>GAME OVER</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p>Level Reached: <span id="finalLevel">1</span></p>
            <button onclick="restartGame()">PLAY AGAIN</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Audio context for sound effects
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        function playBoing() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(600, audioContext.currentTime + 0.1);
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.15);
        }

        function playSplat() {
            const bufferSize = audioContext.sampleRate * 0.3;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            
            // Generate noise
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            
            const noise = audioContext.createBufferSource();
            noise.buffer = buffer;
            
            const filter = audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 800;
            
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            
            noise.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            noise.start(audioContext.currentTime);
            noise.stop(audioContext.currentTime + 0.3);
        }

        // Game state
        let gameRunning = false;
        let score = 0;
        let level = 1;
        let lives = 3;
        let highScore = localStorage.getItem('squoggerHighScore') || 0;

        // Player
        const player = {
            x: 385,
            y: 560,
            size: 35,
            startY: 560,
            goalY: 30,
            moveDistance: 40
        };

        // Lane configuration - classic Frogger style
        const laneHeight = 40;
        const lanes = [
            { type: 'safe', y: 560, color: '#2d5016' }, // Start - grass
            { type: 'road', y: 520, color: '#404040', direction: 1, speed: 1.5 },
            { type: 'road', y: 480, color: '#4a4a4a', direction: -1, speed: 2 },
            { type: 'road', y: 440, color: '#404040', direction: 1, speed: 2.5 },
            { type: 'road', y: 400, color: '#4a4a4a', direction: -1, speed: 1.8 },
            { type: 'road', y: 360, color: '#404040', direction: 1, speed: 2.2 },
            { type: 'safe', y: 320, color: '#2d5016' }, // Middle safe zone - grass
            { type: 'water', y: 280, color: '#1e3a8a', direction: 1, speed: 1.2 },
            { type: 'water', y: 240, color: '#1e40af', direction: -1, speed: 1.5 },
            { type: 'water', y: 200, color: '#1e3a8a', direction: 1, speed: 1.8 },
            { type: 'water', y: 160, color: '#1e40af', direction: -1, speed: 1.3 },
            { type: 'water', y: 120, color: '#1e3a8a', direction: 1, speed: 1.6 },
            { type: 'safe', y: 80, color: '#2d5016' }, // Top safe zone - grass
            { type: 'goal', y: 40, color: '#1a3a0f' } // Goal zones - dark grass
        ];

        // Obstacles (cars/trucks)
        let obstacles = [];

        // Platforms (logs/lily pads)
        let platforms = [];

        // Goal zones
        const goalZones = [
            { x: 80, y: 40, size: 35, filled: false },
            { x: 225, y: 40, size: 35, filled: false },
            { x: 370, y: 40, size: 35, filled: false },
            { x: 515, y: 40, size: 35, filled: false },
            { x: 660, y: 40, size: 35, filled: false }
        ];

        // Initialize game
        document.getElementById('highScore').textContent = highScore;
        document.getElementById('startScreen').style.display = 'block';

        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            resetGame();
            gameRunning = true;
            gameLoop();
        }

        function resetGame() {
            score = 0;
            level = 1;
            lives = 3;
            player.x = 385;
            player.y = 560;
            obstacles = [];
            platforms = [];
            goalZones.forEach(zone => zone.filled = false);
            updateDisplay();
            generateObstacles();
            generatePlatforms();
        }

        function updateDisplay() {
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('highScore').textContent = highScore;
            
            const livesDisplay = document.getElementById('livesDisplay');
            livesDisplay.innerHTML = '';
            for (let i = 0; i < lives; i++) {
                const life = document.createElement('div');
                life.className = 'life';
                livesDisplay.appendChild(life);
            }
        }

        function generateObstacles() {
            lanes.forEach((lane, index) => {
                if (lane.type === 'road') {
                    const count = 2 + Math.floor(level * 0.5);
                    for (let i = 0; i < count; i++) {
                        obstacles.push({
                            x: (canvas.width / count) * i,
                            y: lane.y,
                            width: 60 + Math.random() * 40,
                            height: 40,
                            speed: lane.speed * lane.direction * (1 + level * 0.1),
                            lane: index
                        });
                    }
                }
            });
        }

        function generatePlatforms() {
            lanes.forEach((lane, index) => {
                if (lane.type === 'water') {
                    const count = 2;
                    for (let i = 0; i < count; i++) {
                        platforms.push({
                            x: (canvas.width / count) * i + Math.random() * 100,
                            y: lane.y,
                            width: 80 + Math.random() * 60,
                            height: 40,
                            speed: lane.speed * lane.direction * (1 + level * 0.05),
                            lane: index
                        });
                    }
                }
            });
        }

        function drawLanes() {
            lanes.forEach(lane => {
                ctx.fillStyle = lane.color;
                ctx.fillRect(0, lane.y, canvas.width, laneHeight);
                
                if (lane.type === 'safe' || lane.type === 'goal') {
                    // Draw grass texture
                    ctx.fillStyle = '#3a6b1f';
                    for (let i = 0; i < 50; i++) {
                        const x = Math.random() * canvas.width;
                        const y = lane.y + Math.random() * laneHeight;
                        ctx.fillRect(x, y, 2, 3);
                    }
                } else if (lane.type === 'road') {
                    // Draw road markings - dashed yellow line
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([15, 15]);
                    ctx.beginPath();
                    ctx.moveTo(0, lane.y + laneHeight / 2);
                    ctx.lineTo(canvas.width, lane.y + laneHeight / 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                } else if (lane.type === 'water') {
                    // Draw water ripples
                    ctx.strokeStyle = 'rgba(100, 150, 255, 0.3)';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(0, lane.y + 10 + i * 10);
                        ctx.lineTo(canvas.width, lane.y + 10 + i * 10);
                        ctx.stroke();
                    }
                }
            });
        }

        function drawGoalZones() {
            goalZones.forEach(zone => {
                if (zone.filled) {
                    // Filled with a frog
                    ctx.fillStyle = '#22dd22';
                    ctx.fillRect(zone.x, zone.y, zone.size, zone.size);
                    
                    // Eyes on the filled frog
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(zone.x + 8, zone.y + 6, 6, 6);
                    ctx.fillRect(zone.x + zone.size - 14, zone.y + 6, 6, 6);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(zone.x + 10, zone.y + 8, 3, 3);
                    ctx.fillRect(zone.x + zone.size - 12, zone.y + 8, 3, 3);
                } else {
                    // Empty goal zone - looks like a lily pad or home
                    ctx.fillStyle = '#2d5016';
                    ctx.fillRect(zone.x, zone.y, zone.size, zone.size);
                    
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(zone.x + 2, zone.y + 2, zone.size - 4, zone.size - 4);
                }
            });
        }

        function drawPlayer() {
            // Frog body - classic green
            ctx.fillStyle = '#22dd22';
            ctx.fillRect(player.x, player.y, player.size, player.size);
            
            // Eyes - big classic frog eyes
            ctx.fillStyle = '#fff';
            const eyeSize = 8;
            ctx.fillRect(player.x + 6, player.y + 4, eyeSize, eyeSize);
            ctx.fillRect(player.x + player.size - eyeSize - 6, player.y + 4, eyeSize, eyeSize);
            
            // Pupils
            ctx.fillStyle = '#000';
            const pupilSize = 4;
            ctx.fillRect(player.x + 8, player.y + 6, pupilSize, pupilSize);
            ctx.fillRect(player.x + player.size - pupilSize - 8, player.y + 6, pupilSize, pupilSize);
            
            // Mouth
            ctx.fillStyle = '#000';
            ctx.fillRect(player.x + player.size / 2 - 5, player.y + player.size - 8, 10, 2);
        }

        function drawObstacles() {
            obstacles.forEach(obs => {
                // Different colored vehicles
                const colors = ['#ff4444', '#4444ff', '#ffff44', '#ff44ff', '#44ff44'];
                const colorIndex = Math.floor(obs.x / 200) % colors.length;
                
                // Car body - simpler classic style
                ctx.fillStyle = colors[colorIndex];
                ctx.fillRect(obs.x, obs.y + 5, obs.width, obs.height - 10);
                
                // Wheels
                ctx.fillStyle = '#222';
                const wheelSize = 6;
                ctx.fillRect(obs.x + 5, obs.y + obs.height - 5, wheelSize, wheelSize);
                ctx.fillRect(obs.x + obs.width - wheelSize - 5, obs.y + obs.height - 5, wheelSize, wheelSize);
                
                // Window
                ctx.fillStyle = '#6699ff';
                ctx.fillRect(obs.x + obs.width * 0.3, obs.y + 8, obs.width * 0.4, obs.height - 20);
            });
        }

        function drawPlatforms() {
            platforms.forEach(plat => {
                // Log body - classic brown
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(plat.x, plat.y + 8, plat.width, plat.height - 16);
                
                // End caps (rounded look)
                ctx.fillStyle = '#654321';
                ctx.fillRect(plat.x, plat.y + 8, 8, plat.height - 16);
                ctx.fillRect(plat.x + plat.width - 8, plat.y + 8, 8, plat.height - 16);
                
                // Wood rings
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 2;
                for (let i = 20; i < plat.width - 20; i += 25) {
                    ctx.beginPath();
                    ctx.arc(plat.x + i, plat.y + plat.height / 2, 8, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });
        }

        function updateObstacles() {
            obstacles.forEach(obs => {
                obs.x += obs.speed;
                
                if (obs.speed > 0 && obs.x > canvas.width) {
                    obs.x = -obs.width;
                } else if (obs.speed < 0 && obs.x < -obs.width) {
                    obs.x = canvas.width;
                }
            });
        }

        function updatePlatforms() {
            platforms.forEach(plat => {
                plat.x += plat.speed;
                
                if (plat.speed > 0 && plat.x > canvas.width) {
                    plat.x = -plat.width;
                } else if (plat.speed < 0 && plat.x < -plat.width) {
                    plat.x = canvas.width;
                }
            });
        }

        function checkCollisions() {
            const playerLane = lanes.findIndex(lane => 
                player.y >= lane.y && player.y < lane.y + laneHeight
            );

            if (playerLane === -1) return;

            const currentLane = lanes[playerLane];

            if (currentLane.type === 'road') {
                // Check car collisions
                for (let obs of obstacles) {
                    if (obs.lane === playerLane &&
                        player.x < obs.x + obs.width &&
                        player.x + player.size > obs.x &&
                        player.y < obs.y + obs.height &&
                        player.y + player.size > obs.y) {
                        loseLife();
                        return;
                    }
                }
            } else if (currentLane.type === 'water') {
                // Check if on platform
                let onPlatform = false;
                for (let plat of platforms) {
                    if (plat.lane === playerLane &&
                        player.x < plat.x + plat.width &&
                        player.x + player.size > plat.x &&
                        player.y < plat.y + plat.height &&
                        player.y + player.size > plat.y) {
                        onPlatform = true;
                        player.x += plat.speed; // Move with platform
                        break;
                    }
                }
                
                if (!onPlatform) {
                    loseLife();
                    return;
                }
            } else if (currentLane.type === 'goal') {
                // Check goal zones
                for (let zone of goalZones) {
                    if (!zone.filled &&
                        player.x >= zone.x - 10 &&
                        player.x <= zone.x + zone.size - player.size + 10 &&
                        player.y <= zone.y + zone.size) {
                        zone.filled = true;
                        score += 100 * level;
                        player.x = 385;
                        player.y = 560;
                        
                        // Check if all zones filled
                        if (goalZones.every(z => z.filled)) {
                            levelUp();
                        }
                        return;
                    }
                }
            }

            // Keep player on screen
            if (player.x < 0) player.x = 0;
            if (player.x > canvas.width - player.size) player.x = canvas.width - player.size;
        }

        function loseLife() {
            playSplat();
            lives--;
            player.x = 385;
            player.y = 560;
            
            if (lives <= 0) {
                gameOver();
            } else {
                updateDisplay();
            }
        }

        function levelUp() {
            level++;
            goalZones.forEach(zone => zone.filled = false);
            obstacles = [];
            platforms = [];
            generateObstacles();
            generatePlatforms();
            updateDisplay();
        }

        function gameOver() {
            gameRunning = false;
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('squoggerHighScore', highScore);
            }
            
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalLevel').textContent = level;
            document.getElementById('gameOverScreen').style.display = 'block';
        }

        function restartGame() {
            document.getElementById('gameOverScreen').style.display = 'none';
            resetGame();
            gameRunning = true;
            gameLoop();
        }

        // Controls
        document.addEventListener('keydown', (e) => {
            if (!gameRunning) return;
            
            let moved = false;
            switch(e.key) {
                case 'ArrowUp':
                    if (player.y > 40) {
                        player.y -= player.moveDistance;
                        score += 10;
                        moved = true;
                    }
                    break;
                case 'ArrowDown':
                    if (player.y < player.startY) {
                        player.y += player.moveDistance;
                        moved = true;
                    }
                    break;
                case 'ArrowLeft':
                    if (player.x > 0) {
                        player.x -= player.moveDistance;
                        moved = true;
                    }
                    break;
                case 'ArrowRight':
                    if (player.x < canvas.width - player.size) {
                        player.x += player.moveDistance;
                        moved = true;
                    }
                    break;
            }
            
            if (moved) {
                playBoing();
            }
            updateDisplay();
        });

        function gameLoop() {
            if (!gameRunning) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawLanes();
            drawGoalZones();
            drawPlatforms();
            drawObstacles();
            drawPlayer();
            
            updateObstacles();
            updatePlatforms();
            checkCollisions();
            
            requestAnimationFrame(gameLoop);
        }
    </script>
</body>
</html>
