<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Space Shooter</title>
    <style>
        /* Retro Green Screen Styling */
        :root {
            --game-color: #00ff00;
            --bg-color: #000000;
            --font-family: "Courier New", monospace;
        }

        body {
            margin: 0;
            background-color: var(--bg-color);
            color: var(--game-color);
            font-family: var(--font-family);
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            padding-bottom: 20px;
        }

        #scoreboard {
            width: 800px;
            margin-bottom: 10px;
            padding: 5px 0;
            display: flex;
            justify-content: space-between;
            font-size: 1.2em;
            border-bottom: 1px solid var(--game-color);
        }

        #gameCanvas {
            border: 2px solid var(--game-color);
            box-shadow: 0 0 15px var(--game-color);
            cursor: none;
            width: 800px;
            height: 600px;
        }

        .modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .modal-content {
            background-color: var(--bg-color);
            border: 3px solid var(--game-color);
            box-shadow: 0 0 20px var(--game-color);
            padding: 40px;
            text-align: center;
            font-size: 1.5em;
        }

        .modal-content button {
            background-color: var(--game-color);
            color: var(--bg-color);
            border: none;
            padding: 10px 20px;
            margin-top: 20px;
            font-family: var(--font-family);
            font-size: 1em;
            cursor: pointer;
        }

        #motionPermissionButton {
            display: none;
            margin-top: 15px;
            background-color: #ff6600;
            color: var(--bg-color);
            border-radius: 5px;
            padding: 10px 20px;
            cursor: pointer;
        }

        #controls {
            display: none;
            width: 100%;
            max-width: 800px;
            margin-top: 15px;
            justify-content: space-around;
            padding: 0 10px;
            box-sizing: border-box;
            align-items: flex-end;
        }

        .control-btn {
            background-color: var(--game-color);
            color: var(--bg-color);
            border: 2px solid var(--game-color);
            padding: 15px 20px;
            font-family: var(--font-family);
            font-size: 1.2em;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
            width: 80px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
        }

        .control-btn.fire {
            width: 90px;
            height: 90px;
            font-size: 1.5em;
            background-color: #ff0000;
            border-color: #ff0000;
        }

        @media (max-width: 820px) {
            #scoreboard {
                width: 95%;
                font-size: 1em;
            }
            #gameCanvas {
                width: 95%;
                height: 70vw;
            }
            #controls {
                display: flex;
            }
            .control-btn {
                width: 60px;
                height: 60px;
            }
            .control-btn.fire {
                width: 80px;
                height: 80px;
            }
        }

        @keyframes scroll-up {
            from {
                transform: translateY(100vh);
            }
            to {
                transform: translateY(-100%);
            }
        }
    </style>
</head>
<body>

    <div id="scoreboard">
        <span>SCORE: <span id="scoreValue">0</span></span>
        <span>HP: <span id="hpValue">3</span>/<span id="maxHpValue">3</span></span>
        <span>SALVAGE: <span id="salvageValue">0</span></span>
    </div>

    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <div id="controls">
        <div class="control-btn" data-key="KeyW" data-virtual-key="ArrowUp">THRUST</div>
        <div class="control-btn fire" data-key="Space">FIRE</div>
    </div>

    <button id="motionPermissionButton" onclick="requestMotionPermission()">Enable Tilt Control</button>

    <div id="startModal" class="modal">
        <div class="modal-content">
            <h2>SPACE SHOOTER</h2>
            <p><strong>Desktop:</strong> WASD/Arrows move, Space fires.</p>
            <p><strong>Mobile:</strong> Tilt to turn. Buttons to thrust/fire.</p>
            <button onclick="startGame()">START GAME</button>
        </div>
    </div>

    <div id="endModal" class="modal" style="display:none;">
        <div class="modal-content">
            <h2>GAME OVER!</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <div style="margin-top: 20px;">
                <input type="text" id="playerName" placeholder="Enter your name" maxlength="20" 
                    style="padding: 10px; font-size: 16px; background-color: #000; border: 2px solid #0f0; color: #0f0; font-family: monospace; text-align: center;">
            </div>
            <button onclick="submitAndShowCredits()">SUBMIT SCORE</button>
        </div>
    </div>

    <div id="creditsScreen" class="modal" style="display:none;">
        <div style="text-align: center; animation: scroll-up 15s linear; width: 100%;">
            <pre style="font-size: 20px; color: #ff0; margin: 20px 0;">
  _____ ____   _    ____ _____   ____  _   _  ___   ___ _____ _____ ____  
 / ____|  _ \ / \  / ___| ____| / ___|| | | |/ _ \ / _ \_   _| ____|  _ \ 
 \___ \| |_) / _ \| |   |  _|   \___ \| |_| | | | | | | || | |  _| | |_) |
  ___) |  __/ ___ \ |___| |___   ___) |  _  | |_| | |_| || | | |___|  _ < 
 |____/|_| /_/   \_\____|_____| |____/|_| |_|\___/ \___/ |_| |_____|_| \_\
            </pre>
            
            <div style="margin: 40px 0; font-size: 32px; color: #ff0;">
                <p>FINAL SCORE</p>
                <p id="creditsScore" style="font-size: 48px; color: #0f0;">0</p>
            </div>
            
            <div style="margin: 40px 0; font-size: 24px; line-height: 2;">
                <p style="color: #0ff;">━━━━━━━━━━━━━━━━━━━━</p>
                <p style="color: #ff0;">SALVAGE COLLECTED</p>
                <p id="creditsSalvage" style="color: #0f0; font-size: 36px;">0</p>
                <p style="color: #0ff;">━━━━━━━━━━━━━━━━━━━━</p>
            </div>
            
            <div style="margin: 60px 0; font-size: 20px; line-height: 1.8; color: #0f0;">
                <p style="color: #ff0; font-size: 24px;">CREDITS</p>
                <p style="margin-top: 30px;">LEAD PROGRAMMER</p>
                <p style="color: #0ff;">TOM</p>
                
                <p style="margin-top: 30px;">GAME DESIGN</p>
                <p style="color: #0ff;">GUNNERSGAMES</p>
                
                <p style="margin-top: 30px;">SPECIAL THANKS</p>
                <p style="color: #0ff;">ALL PLAYERS</p>
                
                <p style="margin-top: 50px; color: #ff0; font-size: 18px;">© 2024 GUNNERSGAMES</p>
                <p style="margin-top: 20px; font-size: 16px; color: #888;">INSERT COIN TO CONTINUE</p>
            </div>
        </div>
    </div>

    <!-- ======================= SUPABASE + GAME CODE ======================= -->
    <script type="module">
        import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

        const SUPABASE_URL = "https://pknhslxhpohrzgsfkisr.supabase.co";
        const SUPABASE_ANON_KEY = "sb_publishable_-zZw-pi_3q1sdNGhITKuhQ_ECyDARzc";

        const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        let currentUser = null;

        // ---------------- AUTH (LOGIN REQUIRED) ----------------
        async function initGameAuth() {
            try {
                const { data: { user } } = await supabase.auth.getUser();

                if (!user) {
                    console.log("Not logged in. Redirecting.");
                    window.location.href = "/index.html";
                    return;
                }

                currentUser = user;
                console.log("Authenticated:", user.email);

            } catch (err) {
                console.error("Supabase auth error:", err);
                window.location.href = "/index.html";
            }
        }

        initGameAuth();

        // ---------------- SCORE SUBMISSION ----------------
        async function submitHighScore(score, playerName) {
            if (!currentUser) return;

            const { error } = await supabase.from("arcade_scores").insert({
                user_id: currentUser.id,
                game_name: "shooter",
                score: Math.floor(score),
                player_name: playerName,
                time_played: 0
            });

            if (error) console.warn("Score submit failed:", error.message);
            else console.log("Score submitted OK:", score);
        }

        // Global function for submit and show credits
        window.submitAndShowCredits = async function() {
            const playerName = document.getElementById('playerName').value.trim();
            
            if (!playerName) {
                alert("Please enter your name!");
                return;
            }

            const finalScore = parseInt(document.getElementById('finalScore').textContent);
            await submitHighScore(finalScore, playerName);

            // Show credits
            document.getElementById('endModal').style.display = 'none';
            document.getElementById('creditsScore').textContent = finalScore;
            document.getElementById('creditsSalvage').textContent = salvage;
            document.getElementById('creditsScreen').style.display = 'flex';

            // Redirect to arcade after 15 seconds
            setTimeout(() => {
                window.location.href = '/arcade.html';
            }, 15000);
        };

        // =====================================================================
        // ============================ GAME LOGIC =============================
        // =====================================================================

        const SOUND_PATHS = {
            shoot: './sounds/laser_pew.wav',
            upgrade: './sounds/upgrade_collect.wav',
            engineLoop: './sounds/engine_loop.wav',
            gameOver: './sounds/game_over_jingle.wav',
            explosion: './sounds/explosion.wav'
        };

        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");

        const GAME_WIDTH = canvas.width;
        const GAME_HEIGHT = canvas.height;

        const GAME_COLOR = getComputedStyle(document.documentElement)
            .getPropertyValue("--game-color")
            .trim();

        let gameRunning = false;
        let score = 0;
        let salvage = 0;

        let ship;
        let bullets = [];
        let enemies = [];
        let debris = [];
        let explosions = [];

        let lastBulletTime = 0;
        const keyMap = {};

        // Tilt
        let tiltGamma = 0;
        let tiltMax = 45;

        let engineSound = null;

        function playSound(src, vol = 1) {
            const a = new Audio(src);
            a.volume = vol;
            a.play().catch(() => {});
        }

        // Tilt controls
        function handleDeviceOrientation(event) {
            tiltGamma = Math.max(-tiltMax, Math.min(tiltMax, event.gamma || 0));
        }

        window.requestMotionPermission = async function () {
            if (typeof DeviceOrientationEvent.requestPermission === "function") {
                const permissionState = await DeviceOrientationEvent.requestPermission();
                if (permissionState === "granted") {
                    window.addEventListener("deviceorientation", handleDeviceOrientation);
                    document.getElementById("motionPermissionButton").style.display = "none";
                }
            } else {
                window.addEventListener("deviceorientation", handleDeviceOrientation);
                document.getElementById("motionPermissionButton").style.display = "none";
            }
        };

        if (typeof DeviceOrientationEvent.requestPermission !== "function") {
            window.addEventListener("deviceorientation", handleDeviceOrientation);
        } else {
            document.getElementById("motionPermissionButton").style.display = "block";
        }

        // -------------------------------------------------------
        // GAME OBJECT CREATORS
        // -------------------------------------------------------
        function createShip() {
            return {
                x: GAME_WIDTH / 2,
                y: GAME_HEIGHT / 2,
                velX: 0,
                velY: 0,
                angle: 0,
                radius: 15,

                maxSpeed: 5,
                thrust: 0.15,
                turnRate: 0.05,
                fireRate: 150,
                bulletSpeed: 7,

                hullHP: 3,
                maxHP: 3
            };
        }

        function createEnemy(x = null, y = null, tier = 3) {
            let ex, ey;

            if (x !== null) {
                ex = x;
                ey = y;
            } else {
                const edge = Math.floor(Math.random() * 4);
                if (edge === 0) {
                    ex = Math.random() * GAME_WIDTH;
                    ey = 0;
                } else if (edge === 1) {
                    ex = GAME_WIDTH;
                    ey = Math.random() * GAME_HEIGHT;
                } else if (edge === 2) {
                    ex = Math.random() * GAME_WIDTH;
                    ey = GAME_HEIGHT;
                } else {
                    ex = 0;
                    ey = Math.random() * GAME_HEIGHT;
                }
            }

            let radius, speed, hp, scoreValue;

            if (tier === 3) {
                radius = 35;
                speed = 1.1;
                hp = 4;
                scoreValue = 100;
            } else if (tier === 2) {
                radius = 20;
                speed = 2;
                hp = 2;
                scoreValue = 50;
            } else {
                radius = 10;
                speed = 3.3;
                hp = 1;
                scoreValue = 25;
            }

            let angle = x !== null ? Math.random() * Math.PI * 2 : Math.atan2(ship.y - ey, ship.x - ex);

            const shapes = ["square", "triangle", "diamond"];
            const shape = shapes[Math.floor(Math.random() * shapes.length)];

            return {
                x: ex,
                y: ey,
                velX: Math.cos(angle) * speed,
                velY: Math.sin(angle) * speed,
                radius,
                hp,
                tier,
                scoreValue,
                shape
            };
        }

        function createDebris(x, y) {
            const types = ["motor", "armour"];
            const type = types[Math.floor(Math.random() * types.length)];

            return {
                x,
                y,
                radius: type === "armour" ? 10 : 8,
                type,
                velX: Math.random() * 2 - 1,
                velY: Math.random() * 2 - 1
            };
        }

        function createExplosion(x, y, parts = 10, maxR = 3) {
            playSound(SOUND_PATHS.explosion, 0.6);

            for (let i = 0; i < parts; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 1;

                explosions.push({
                    x,
                    y,
                    velX: Math.cos(angle) * speed,
                    velY: Math.sin(angle) * speed,
                    radius: maxR,
                    life: 60,
                    maxLife: 60
                });
            }
        }

        document.addEventListener("keydown", (e) => (keyMap[e.code] = true));
        document.addEventListener("keyup", (e) => (keyMap[e.code] = false));

        // -------------------------------------------------------
        // TOUCH CONTROLS
        // -------------------------------------------------------
        document.querySelectorAll(".control-btn").forEach((btn) => {
            const key = btn.dataset.key;

            const press = () => {
                keyMap[key] = true;
                const vkey = btn.dataset.virtualKey;
                if (vkey) keyMap[vkey] = true;
            };
            const release = () => {
                keyMap[key] = false;
                const vkey = btn.dataset.virtualKey;
                if (vkey) keyMap[vkey] = false;
            };

            btn.addEventListener("touchstart", (e) => {
                e.preventDefault();
                press();
            });
            btn.addEventListener("touchend", release);
            btn.addEventListener("mousedown", press);
            btn.addEventListener("mouseup", release);
        });

        // -------------------------------------------------------
        // UPDATE LOOP
        // -------------------------------------------------------
        function update() {
            if (!gameRunning) return;

            const isThrusting = keyMap["ArrowUp"] || keyMap["KeyW"];

            // Control engine sound based on thrust
            if (engineSound) {
                if (isThrusting) {
                    if (engineSound.paused) {
                        engineSound.play().catch(() => {});
                    }
                } else {
                    if (!engineSound.paused) {
                        engineSound.pause();
                    }
                }
            }

            // Turning, tilt first
            const tiltNorm = tiltGamma / tiltMax;
            if (Math.abs(tiltNorm) > 0.1) ship.angle += ship.turnRate * tiltNorm;

            if (keyMap["ArrowLeft"] || keyMap["KeyA"]) ship.angle -= ship.turnRate;
            if (keyMap["ArrowRight"] || keyMap["KeyD"]) ship.angle += ship.turnRate;

            if (isThrusting) {
                ship.velX += Math.cos(ship.angle) * ship.thrust;
                ship.velY += Math.sin(ship.angle) * ship.thrust;
            } else {
                ship.velX *= 0.99;
                ship.velY *= 0.99;
            }

            // Speed limit
            const spd = Math.hypot(ship.velX, ship.velY);
            if (spd > ship.maxSpeed) {
                const r = ship.maxSpeed / spd;
                ship.velX *= r;
                ship.velY *= r;
            }

            // Move + wrap
            ship.x += ship.velX;
            ship.y += ship.velY;

            if (ship.x < 0) ship.x = GAME_WIDTH;
            if (ship.x > GAME_WIDTH) ship.x = 0;
            if (ship.y < 0) ship.y = GAME_HEIGHT;
            if (ship.y > GAME_HEIGHT) ship.y = 0;

            // Shooting
            if ((keyMap["Space"] || keyMap["KeyF"]) && Date.now() - lastBulletTime > ship.fireRate) {
                bullets.push({
                    x: ship.x + Math.cos(ship.angle) * ship.radius,
                    y: ship.y + Math.sin(ship.angle) * ship.radius,
                    velX: Math.cos(ship.angle) * ship.bulletSpeed + ship.velX,
                    velY: Math.sin(ship.angle) * ship.bulletSpeed + ship.velY,
                    radius: 3
                });
                lastBulletTime = Date.now();
                playSound(SOUND_PATHS.shoot, 0.4);
            }

            bullets.forEach((b) => ((b.x += b.velX), (b.y += b.velY)));
            bullets = bullets.filter(
                (b) => b.x > 0 && b.x < GAME_WIDTH && b.y > 0 && b.y < GAME_HEIGHT
            );

            enemies.forEach((e) => ((e.x += e.velX), (e.y += e.velY)));
            enemies.forEach((e) => {
                if (e.x < 0) e.x = GAME_WIDTH;
                if (e.x > GAME_WIDTH) e.x = 0;
                if (e.y < 0) e.y = GAME_HEIGHT;
                if (e.y > GAME_HEIGHT) e.y = 0;
            });

            debris.forEach((d) => {
                d.x += d.velX;
                d.y += d.velY;
                d.velX *= 0.99;
                d.velY *= 0.99;
            });

            explosions.forEach((p) => {
                p.x += p.velX;
                p.y += p.velY;
                p.life--;
                p.velX *= 0.95;
                p.velY *= 0.95;
            });
            explosions = explosions.filter((p) => p.life > 0);

            // BULLET vs ENEMY
            let newEnemies = [];
            let newDebris = [];

            bullets = bullets.filter((b) => {
                let hit = false;

                enemies = enemies.filter((e) => {
                    const dist = Math.hypot(b.x - e.x, b.y - e.y);
                    if (dist < b.radius + e.radius) {
                        e.hp--;
                        hit = true;

                        if (e.hp <= 0) {
                            score += e.scoreValue;
                            createExplosion(e.x, e.y, e.tier * 5);

                            if (e.tier > 1) {
                                newEnemies.push(createEnemy(e.x, e.y, e.tier - 1));
                                newEnemies.push(createEnemy(e.x, e.y, e.tier - 1));
                            }

                            if (Math.random() < 0.2 && e.tier > 1) {
                                newDebris.push(createDebris(e.x, e.y));
                            }

                            return false;
                        }

                        return true;
                    }
                    return true;
                });

                return !hit;
            });

            enemies.push(...newEnemies);
            debris.push(...newDebris);

            // PLAYER COLLISIONS
            enemies = enemies.filter((e) => {
                const d = Math.hypot(ship.x - e.x, ship.y - e.y);
                if (d < ship.radius + e.radius) {
                    ship.hullHP--;
                    createExplosion(e.x, e.y, 5, 2);

                    if (ship.hullHP <= 0) endGame();
                    return false;
                }
                return true;
            });

            debris = debris.filter((d) => {
                const dist = Math.hypot(ship.x - d.x, ship.y - d.y);
                if (dist < ship.radius + d.radius) {
                    salvage++;

                    if (d.type === "motor") {
                        ship.thrust += 0.02;
                        ship.maxSpeed += 0.5;
                    } else {
                        ship.maxHP += 1;
                        ship.hullHP = ship.maxHP;
                    }

                    playSound(SOUND_PATHS.upgrade);
                    return false;
                }
                return true;
            });

            if (enemies.length < 2 + Math.floor(score / 1000)) {
                enemies.push(createEnemy());
            }

            document.getElementById("scoreValue").textContent = score;
            document.getElementById("hpValue").textContent = ship.hullHP;
            document.getElementById("maxHpValue").textContent = ship.maxHP;
            document.getElementById("salvageValue").textContent = salvage;
        }

        // -------------------------------------------------------
        // DRAW FUNCTIONS
        // -------------------------------------------------------
        function drawShip() {
            ctx.strokeStyle = GAME_COLOR;
            ctx.lineWidth = 2;

            ctx.save();
            ctx.translate(ship.x, ship.y);
            ctx.rotate(ship.angle);

            ctx.beginPath();
            ctx.moveTo(ship.radius, 0);
            ctx.lineTo(-ship.radius * 0.8, -ship.radius * 0.8);
            ctx.lineTo(-ship.radius * 0.6, 0);
            ctx.lineTo(-ship.radius * 0.8, ship.radius * 0.8);
            ctx.closePath();
            ctx.stroke();

            if (keyMap["ArrowUp"] || keyMap["KeyW"]) {
                ctx.fillStyle = "yellow";
                ctx.beginPath();
                ctx.moveTo(-ship.radius * 0.6, -ship.radius * 0.4);
                ctx.lineTo(-ship.radius * 1.5, 0);
                ctx.lineTo(-ship.radius * 0.6, ship.radius * 0.4);
                ctx.fill();
            }

            ctx.restore();
        }

        function drawEnemy(e) {
            ctx.strokeStyle = GAME_COLOR;
            ctx.lineWidth = 2;

            ctx.save();
            ctx.translate(e.x, e.y);

            if (e.shape === "square") {
                const s = e.radius * 1.4;
                ctx.strokeRect(-s / 2, -s / 2, s, s);
            } else if (e.shape === "triangle") {
                ctx.beginPath();
                ctx.moveTo(e.radius, 0);
                ctx.lineTo(-e.radius / 2, e.radius * 0.866);
                ctx.lineTo(-e.radius / 2, -e.radius * 0.866);
                ctx.closePath();
                ctx.stroke();
            } else if (e.shape === "diamond") {
                const s = e.radius * 1.2;
                ctx.beginPath();
                ctx.moveTo(s, 0);
                ctx.lineTo(0, s);
                ctx.lineTo(-s, 0);
                ctx.lineTo(0, -s);
                ctx.closePath();
                ctx.stroke();
            } else {
                ctx.beginPath();
                ctx.arc(0, 0, e.radius, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.restore();

            if (e.tier > 1) {
                ctx.font = "12px Courier New";
                ctx.fillText(`HP:${e.hp}`, e.x - 15, e.y - e.radius - 5);
            }
        }

        function draw() {
            ctx.fillStyle = "black";
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            drawShip();

            ctx.fillStyle = GAME_COLOR;
            bullets.forEach((b) => {
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                ctx.fill();
            });

            enemies.forEach(drawEnemy);

            debris.forEach((d) => {
                ctx.fillStyle = d.type === "motor" ? "yellow" : "cyan";
                ctx.fillRect(d.x - d.radius / 2, d.y - d.radius / 2, d.radius, d.radius);
            });

            explosions.forEach((p) => {
                const ratio = p.life / p.maxLife;
                const sz = p.radius * ratio;

                ctx.fillStyle = ratio > 0.5 ? "yellow" : "orange";
                ctx.fillRect(p.x - sz / 2, p.y - sz / 2, sz, sz);
            });
        }

        // -------------------------------------------------------
        // GAME CONTROL
        // -------------------------------------------------------
        function gameLoop() {
            update();
            draw();
            if (gameRunning) requestAnimationFrame(gameLoop);
        }

        window.startGame = function () {
            ship = createShip();
            score = 0;
            salvage = 0;

            bullets = [];
            enemies = [];
            debris = [];
            explosions = [];

            gameRunning = true;

            if (!engineSound) {
                engineSound = new Audio(SOUND_PATHS.engineLoop);
                engineSound.loop = true;
                engineSound.volume = 0.3;
                document.body.appendChild(engineSound);
            }

            // Don't auto-play engine sound - it will play when thrusting

            document.getElementById("startModal").style.display = "none";
            gameLoop();
        };

        function endGame() {
            gameRunning = false;

            if (engineSound) {
                engineSound.pause();
                engineSound.currentTime = 0;
            }

            playSound(SOUND_PATHS.gameOver);

            document.getElementById("finalScore").textContent = score;
            document.getElementById("endModal").style.display = "flex";
            document.getElementById('playerName').focus();
        }

        // Add enter key support for name input
        document.addEventListener('DOMContentLoaded', function() {
            const nameInput = document.getElementById('playerName');
            if (nameInput) {
                nameInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        submitAndShowCredits();
                    }
                });
            }
        });

        ctx.font = "16px var(--font-family)";
        ctx.fillStyle = GAME_COLOR;
    </script>
</body>
</html>