<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Space Salvage</title>
    <style>
        /* Retro Green Screen Styling */
        :root {
            --game-color: #00FF00; /* Bright Green */
            --bg-color: #000000;
            --font-family: 'Courier New', monospace;
        }

        body {
            margin: 0;
            background-color: var(--bg-color);
            color: var(--game-color);
            font-family: var(--font-family);
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            padding-bottom: 20px; /* Space for controls */
        }

        /* Scoreboard */
        #scoreboard {
            width: 800px;
            margin-bottom: 10px;
            padding: 5px 0;
            display: flex;
            justify-content: space-between;
            font-size: 1.2em;
            border-bottom: 1px solid var(--game-color);
        }
        
        /* Game Canvas */
        #gameCanvas {
            border: 2px solid var(--game-color);
            box-shadow: 0 0 15px var(--game-color); /* Glow effect */
            cursor: none; /* Hide default cursor */
            width: 800px;
            height: 600px;
        }
        
        /* Modal Popups (Start/End Game) */
        .modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .modal-content {
            background-color: var(--bg-color);
            border: 3px solid var(--game-color);
            box-shadow: 0 0 20px var(--game-color);
            padding: 40px;
            text-align: center;
            font-size: 1.5em;
        }

        .modal-content button {
            background-color: var(--game-color);
            color: var(--bg-color);
            border: none;
            padding: 10px 20px;
            margin-top: 20px;
            font-family: var(--font-family);
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.1s;
        }

        .modal-content button:hover {
            background-color: var(--bg-color);
            color: var(--game-color);
            border: 1px solid var(--game-color);
        }
        
        /* New button for iOS permission */
        #motionPermissionButton {
            display: none;
            margin-top: 15px;
            background-color: #FF6600; /* Orange for attention */
            color: var(--bg-color);
            border-radius: 5px;
            padding: 10px 20px;
            cursor: pointer;
        }

        /* --- MOBILE CONTROLS STYLING (Simplified for Tilt) --- */
        #controls {
            display: none; /* Hidden by default on desktop */
            width: 100%;
            max-width: 800px;
            margin-top: 15px;
            justify-content: space-around; /* Space for Thrust and Fire */
            padding: 0 10px;
            box-sizing: border-box;
            align-items: flex-end;
        }

        .control-btn {
            background-color: var(--game-color);
            color: var(--bg-color);
            border: 2px solid var(--game-color);
            padding: 15px 20px;
            font-family: var(--font-family);
            font-size: 1.2em;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
            width: 80px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            box-shadow: 0 0 5px var(--game-color);
        }

        .control-btn.fire {
            width: 90px;
            height: 90px;
            font-size: 1.5em;
            background-color: #FF0000; /* Red for fire */
            color: var(--game-color);
            border-color: #FF0000;
            box-shadow: 0 0 10px #FF0000;
        }
        
        /* Responsive adjustments for mobile */
        @media (max-width: 820px) {
            #scoreboard {
                width: 95%;
                font-size: 1em;
            }
            #gameCanvas {
                width: 95%;
                height: 70vw; 
            }
            #controls {
                display: flex; /* Show controls on mobile */
            }
            .control-btn {
                width: 60px;
                height: 60px;
                font-size: 1em;
            }
            .control-btn.fire {
                width: 80px;
                height: 80px;
                font-size: 1.2em;
            }
        }
    </style>
</head>
<body>

    <div id="scoreboard">
        <span>SCORE: <span id="scoreValue">0</span></span>
        <span>HP: <span id="hpValue">3</span>/<span id="maxHpValue">3</span></span>
        <span>SALVAGE: <span id="salvageValue">0</span></span>
    </div>

    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <!-- MOBILE CONTROLS (Now only Thrust and Fire) -->
    <div id="controls">
        <div class="control-btn" data-key="KeyW" data-virtual-key="ArrowUp">THRUST</div>
        <div class="control-btn fire" data-key="Space">FIRE</div>
    </div>
    <!-- END MOBILE CONTROLS -->
    
    <button id="motionPermissionButton" onclick="requestMotionPermission()">Enable Tilt Control</button>


    <div id="startModal" class="modal">
        <div class="modal-content">
            <h2>RETRO SPACE SALVAGE</h2>
            <p><strong>Desktop:</strong> WASD/Arrows to move, Spacebar to shoot.</p>
            <p><strong>Mobile:</strong> **Tilt device** to turn, **THRUST** button to move, **FIRE** button to shoot.</p>
            <p>Collect **Debris** for permanent ship upgrades!</p>
            <button onclick="startGame()">START GAME</button>
        </div>
    </div>

    <div id="endModal" class="modal" style="display:none;">
        <div class="modal-content">
            <h2>GAME OVER!</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button onclick="window.location.reload()">PLAY AGAIN</button>
        </div>
    </div>

    <script type="module">
        import GameScoreManager from '../game-score-manager.js';
        
        // Initialize score manager for Space Shooter
        const scoreManager = new GameScoreManager('shooter', true);
        
        // --- CONFIGURATION ---
        const SOUND_PATHS = {
            shoot: './sounds/laser_pew.wav', 
            upgrade: './sounds/upgrade_collect.wav', 
            engineLoop: './sounds/engine_loop.wav', 
            gameOver: './sounds/game_over_jingle.wav',
            explosion: './sounds/explosion.wav' 
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const GAME_WIDTH = canvas.width;
        const GAME_HEIGHT = canvas.height;
        
        const GAME_COLOR = getComputedStyle(document.documentElement).getPropertyValue('--game-color').trim();

        let gameRunning = false;
        let score = 0;
        let salvage = 0;
        let ship;
        let bullets = [];
        let enemies = [];
        let debris = [];
        let explosions = []; 
        const keyMap = {};
        let lastBulletTime = 0;

        // --- TILT CONTROL STATE ---
        let tiltGamma = 0; // Left/right tilt (-90 to 90)
        let tiltMax = 45; // Maximum tilt angle (in degrees) used for full turn rate

        // --- SOUND UTILITIES ---
        let engineSound;

        function initializeEngineSound() {}
        initializeEngineSound();

        function playSound(src, volume = 1.0) {
            if (src && engineSound && !engineSound.paused) { 
                const audio = new Audio(src);
                audio.volume = volume;
                audio.play().catch(e => {
                    console.error("Local audio failed to load/play:", src, e.message);
                });
            }
        }

        // --- DEVICE ORIENTATION (TILT) SETUP ---

        function handleDeviceOrientation(event) {
            // Gamma is the front-to-back tilt (for movement direction)
            // Beta is the side-to-side tilt (for turning)
            
            // We use gamma for side-to-side turning (tilting the device left/right)
            // Clamp gamma between -tiltMax and tiltMax for responsive control
            tiltGamma = Math.max(-tiltMax, Math.min(tiltMax, event.gamma || 0));
        }

        window.requestMotionPermission = async function() {
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                const permissionState = await DeviceOrientationEvent.requestPermission();
                if (permissionState === 'granted') {
                    window.addEventListener('deviceorientation', handleDeviceOrientation);
                    document.getElementById('motionPermissionButton').style.display = 'none';
                } else {
                    console.warn("Motion sensor permission denied.");
                }
            } else {
                // Non-iOS device, permission not required
                window.addEventListener('deviceorientation', handleDeviceOrientation);
                document.getElementById('motionPermissionButton').style.display = 'none';
            }
        }

        // Check if we need the permission button (typically iOS 13+)
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            document.getElementById('motionPermissionButton').style.display = 'block';
        } else {
            // Automatically start listening for orientation on non-iOS
            window.addEventListener('deviceorientation', handleDeviceOrientation);
        }

        // --- GAME OBJECTS ---

        function createShip() {
            return {
                x: GAME_WIDTH / 2,
                y: GAME_HEIGHT / 2,
                velX: 0,
                velY: 0,
                angle: 0,
                radius: 15,
                // Upgradeable Stats
                maxSpeed: 5,
                thrust: 0.15,
                turnRate: 0.05,
                fireRate: 150, 
                bulletSpeed: 7,
                hullHP: 3,
                maxHP: 3,
            };
        }

        function createEnemy() {
            const edge = Math.floor(Math.random() * 4); 
            let x, y;
            if (edge === 0) { x = Math.random() * GAME_WIDTH; y = 0; }
            else if (edge === 1) { x = GAME_WIDTH; y = Math.random() * GAME_HEIGHT; }
            else if (edge === 2) { x = Math.random() * GAME_WIDTH; y = GAME_HEIGHT; }
            else { x = 0; y = Math.random() * GAME_HEIGHT; }

            const angleToPlayer = Math.atan2(ship.y - y, ship.x - x);
            const speed = 1 + Math.random(); 
            
            const shapes = ['square', 'triangle', 'diamond'];
            const shape = shapes[Math.floor(Math.random() * shapes.length)];
            
            const radius = 15 + Math.random() * 10;

            return {
                x, y,
                velX: Math.cos(angleToPlayer) * speed,
                velY: Math.sin(angleToPlayer) * speed,
                radius: radius, 
                hp: 3,
                shape: shape, 
            };
        }

        function createDebris(x, y) {
            const types = ['motor', 'armour']; 
            const type = types[Math.floor(Math.random() * types.length)];
            
            return {
                x, y, 
                radius: type === 'armour' ? 10 : 8,
                type: type,
                velX: Math.random() * 2 - 1, 
                velY: Math.random() * 2 - 1,
            };
        }
        
        function createExplosion(x, y, numParticles = 10, maxRadius = 3) {
            playSound(SOUND_PATHS.explosion, 0.6);

            for (let i = 0; i < numParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 1;

                explosions.push({
                    x: x,
                    y: y,
                    velX: Math.cos(angle) * speed,
                    velY: Math.sin(angle) * speed,
                    radius: maxRadius, 
                    life: 60, 
                    maxLife: 60,
                });
            }
        }
        
        // --- INPUTS (KEYBOARD) ---
        document.addEventListener('keydown', (event) => { keyMap[event.code] = true; });
        document.addEventListener('keyup', (event) => { keyMap[event.code] = false; });

        // --- INPUTS (TOUCH CONTROLS) ---
        function setupTouchControls() {
            document.querySelectorAll('.control-btn').forEach(button => {
                const key = button.getAttribute('data-key');
                
                const press = () => {
                    keyMap[key] = true;
                    const virtualKey = button.getAttribute('data-virtual-key');
                    if (virtualKey) keyMap[virtualKey] = true; 
                    button.style.filter = 'brightness(1.5)';
                };

                const release = () => {
                    keyMap[key] = false;
                    const virtualKey = button.getAttribute('data-virtual-key');
                    if (virtualKey) keyMap[virtualKey] = false;
                    button.style.filter = 'brightness(1.0)';
                };

                button.addEventListener('touchstart', (e) => {
                    e.preventDefault(); 
                    press();
                }, { passive: false });

                button.addEventListener('touchend', release);
                button.addEventListener('mousedown', press);
                button.addEventListener('mouseup', release);
                button.addEventListener('mouseleave', (e) => {
                    if (keyMap[key]) release();
                });
            });
        }
        
        setupTouchControls();

        // --- GAME LOGIC ---

        function update() {
            if (!gameRunning) return;
            
            const isThrusting = keyMap['ArrowUp'] || keyMap['KeyW'];
            
            // 1. SHIP MOVEMENT
            
            // --- NEW: TILT CONTROL FOR TURNING ---
            const tiltFactor = tiltGamma / tiltMax; // Normalized value between -1 and 1
            if (Math.abs(tiltFactor) > 0.1) { // Apply turning if tilted more than 10%
                 ship.angle += ship.turnRate * tiltFactor;
            }
            
            // Fallback for keyboard turning (for desktop play)
            if (keyMap['ArrowLeft'] || keyMap['KeyA']) { ship.angle -= ship.turnRate; }
            if (keyMap['ArrowRight'] || keyMap['KeyD']) { ship.angle += ship.turnRate; }
            
            // Handle thrusting
            if (isThrusting) {
                ship.velX += Math.cos(ship.angle) * ship.thrust;
                ship.velY += Math.sin(ship.angle) * ship.thrust;
            } else {
                // Friction/Drag
                ship.velX *= 0.99;
                ship.velY *= 0.99;
            }
            
            // Engine volume adjusts based on thrust
            if (engineSound) {
                engineSound.volume = isThrusting ? 0.5 : 0.2; 
            }
            
            // Limit Speed
            let speed = Math.sqrt(ship.velX**2 + ship.velY**2);
            if (speed > ship.maxSpeed) {
                let ratio = ship.maxSpeed / speed;
                ship.velX *= ratio;
                ship.velY *= ratio;
            }

            // Update Position & Wraparound
            ship.x += ship.velX;
            ship.y += ship.velY;
            if (ship.x < 0) ship.x = GAME_WIDTH;
            if (ship.x > GAME_WIDTH) ship.x = 0;
            if (ship.y < 0) ship.y = GAME_HEIGHT;
            if (ship.y > GAME_HEIGHT) ship.y = 0;

            // 2. SHOOTING
            if ((keyMap['Space'] || keyMap['KeyF']) && Date.now() - lastBulletTime > ship.fireRate) {
                bullets.push({
                    x: ship.x + Math.cos(ship.angle) * ship.radius, 
                    y: ship.y + Math.sin(ship.angle) * ship.radius,
                    velX: Math.cos(ship.angle) * ship.bulletSpeed + ship.velX,
                    velY: Math.sin(ship.angle) * ship.bulletSpeed + ship.velY,
                    radius: 3,
                });
                lastBulletTime = Date.now();
                playSound(SOUND_PATHS.shoot, 0.4); 
            }

            // 3. UPDATE BULLETS, ENEMIES, AND DEBRIS
            bullets.forEach(b => { b.x += b.velX; b.y += b.velY; });
            bullets = bullets.filter(b => b.x > 0 && b.x < GAME_WIDTH && b.y > 0 && b.y < GAME_HEIGHT);

            enemies.forEach(e => { e.x += e.velX; e.y += e.velY; });
            enemies.forEach(e => {
                if (e.x < 0) e.x = GAME_WIDTH;
                if (e.x > GAME_WIDTH) e.x = 0;
                if (e.y < 0) e.y = GAME_HEIGHT;
                if (e.y > GAME_HEIGHT) e.y = 0;
            });

            debris.forEach(d => { d.x += d.velX; d.y += d.velY; d.velX *= 0.99; d.velY *= 0.99; });

            // Update explosions (particles)
            explosions.forEach(p => {
                p.x += p.velX;
                p.y += p.velY;
                p.life--;
                p.velX *= 0.95;
                p.velY *= 0.95;
            });
            explosions = explosions.filter(p => p.life > 0); 


            // 4. COLLISIONS (Bullet vs. Enemy)
            let newDebris = [];
            bullets = bullets.filter(b => {
                let hit = false;
                enemies = enemies.filter(e => {
                    const dist = Math.sqrt((b.x - e.x)**2 + (b.y - e.y)**2);
                    if (dist < b.radius + e.radius) {
                        e.hp--;
                        hit = true;
                        if (e.hp <= 0) {
                            score += 100;
                            createExplosion(e.x, e.y); 
                            if (Math.random() < 0.2) { 
                                newDebris.push(createDebris(e.x, e.y));
                            }
                            return false; 
                        }
                        return true; 
                    }
                    return true; 
                });
                return !hit; 
            });
            debris.push(...newDebris);

            // 5. COLLISIONS (Player vs. Enemy) - Take Damage
            enemies = enemies.filter(e => {
                const dist = Math.sqrt((ship.x - e.x)**2 + (ship.y - e.y)**2);
                if (dist < ship.radius + e.radius) {
                    ship.hullHP--;
                    createExplosion(e.x, e.y, 5, 2); 
                    if (ship.hullHP <= 0) {
                        endGame();
                    }
                    return false; 
                }
                return true;
            });
            
            // 6. COLLISIONS (Player vs. Debris) - Salvage/Upgrade
            debris = debris.filter(d => {
                const dist = Math.sqrt((ship.x - d.x)**2 + (ship.y - d.y)**2);
                if (dist < ship.radius + d.radius) {
                    salvage++;
                    
                    if (d.type === 'motor') {
                        ship.thrust += 0.02;
                        ship.maxSpeed += 0.5;
                        playSound(SOUND_PATHS.upgrade);
                    } else if (d.type === 'armour') {
                        ship.maxHP += 1;
                        ship.hullHP = ship.maxHP; 
                        playSound(SOUND_PATHS.upgrade); 
                    }

                    return false; 
                }
                return true;
            });

            // 7. ENEMY SPAWN (Simple Wave Logic)
            if (enemies.length < 3 + Math.floor(score / 500)) {
                enemies.push(createEnemy());
            }

            // 8. UPDATE SCOREBOARD
            document.getElementById('scoreValue').textContent = score;
            document.getElementById('hpValue').textContent = ship.hullHP;
            document.getElementById('maxHpValue').textContent = ship.maxHP;
            document.getElementById('salvageValue').textContent = salvage;
        }

        // --- DRAWING FUNCTIONS ---

        function drawShip() {
            ctx.strokeStyle = GAME_COLOR;
            ctx.lineWidth = 2;
            
            ctx.save();
            ctx.translate(ship.x, ship.y);
            ctx.rotate(ship.angle);
            
            // Draw a triangle for the ship (Asteroids style)
            ctx.beginPath();
            ctx.moveTo(ship.radius, 0); // Nose
            ctx.lineTo(-ship.radius * 0.8, -ship.radius * 0.8);
            ctx.lineTo(-ship.radius * 0.6, 0); // Base of the flame
            ctx.lineTo(-ship.radius * 0.8, ship.radius * 0.8);
            ctx.closePath();
            ctx.stroke();

            // Draw a small flame when thrusting
            if (keyMap['ArrowUp'] || keyMap['KeyW']) {
                ctx.fillStyle = 'yellow';
                ctx.beginPath();
                ctx.moveTo(-ship.radius * 0.6, -ship.radius * 0.4);
                ctx.lineTo(-ship.radius * 1.5, 0);
                ctx.lineTo(-ship.radius * 0.6, ship.radius * 0.4);
                ctx.fill();
            }

            ctx.restore();
        }

        function drawEnemy(e) {
            ctx.strokeStyle = GAME_COLOR; 
            ctx.lineWidth = 2;
            ctx.save();
            ctx.translate(e.x, e.y);
            
            // Draw different shapes based on the enemy type
            if (e.shape === 'square') {
                const size = e.radius * 1.4;
                ctx.strokeRect(-size / 2, -size / 2, size, size);
            } else if (e.shape === 'triangle') {
                ctx.beginPath();
                ctx.moveTo(e.radius, 0);
                ctx.lineTo(-e.radius / 2, e.radius * 0.866);
                ctx.lineTo(-e.radius / 2, -e.radius * 0.866);
                ctx.closePath();
                ctx.stroke();
            } else if (e.shape === 'diamond') {
                const size = e.radius * 1.2;
                ctx.beginPath();
                ctx.moveTo(size, 0);
                ctx.lineTo(0, size);
                ctx.lineTo(-size, 0);
                ctx.lineTo(0, -size);
                ctx.closePath();
                ctx.stroke();
            } else {
                // Default to circle
                ctx.beginPath();
                ctx.arc(0, 0, e.radius, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            ctx.restore();
            
            // HP Indicator
            ctx.fillText(`HP:${e.hp}`, e.x - 15, e.y - e.radius - 5);
        }

        function draw() {
            // Clear the screen
            ctx.fillStyle = 'black'; 
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            drawShip();
            
            // Draw Bullets
            ctx.fillStyle = GAME_COLOR; // Green color
            bullets.forEach(b => {
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw Enemies
            enemies.forEach(e => {
                drawEnemy(e);
            });

            // Draw Debris 
            debris.forEach(d => {
                // Set color based on type
                ctx.fillStyle = d.type === 'motor' ? 'yellow' : 'cyan';
                
                ctx.fillRect(d.x - d.radius / 2, d.y - d.radius / 2, d.radius, d.radius);
            });
            
            // Draw Explosions (Particles)
            explosions.forEach(p => {
                const ratio = p.life / p.maxLife; 
                const size = p.radius * ratio;
                
                ctx.fillStyle = ratio > 0.5 ? 'yellow' : 'orange'; 
                ctx.fillRect(p.x - size / 2, p.y - size / 2, size, size);
            });
        }
        
        // --- GAME CONTROL ---

        function gameLoop() {
            update();
            draw();
            if (gameRunning) {
                requestAnimationFrame(gameLoop);
            }
        }

        window.startGame = function() {
            // Initialization
            ship = createShip();
            score = 0;
            salvage = 0;
            enemies = [];
            bullets = [];
            debris = [];
            explosions = []; 
            gameRunning = true;
            
            // Start tracking time
            scoreManager.startSession();

            // FIX: Create the Audio object and start playback ONLY HERE, 
            // inside the function tied to the user's click event.
            if (!engineSound) {
                engineSound = new Audio(SOUND_PATHS.engineLoop);
                engineSound.loop = true;
                engineSound.volume = 0.3; 
                document.body.appendChild(engineSound);
            }

            // --- START ENGINE SOUND (Browser should allow this since it's user-initiated) ---
            engineSound.play().catch(e => console.error("Engine sound blocked:", e)); 

            // Hide the start modal and start the loop
            document.getElementById('startModal').style.display = 'none';
            gameLoop();
        }

        function endGame() {
            gameRunning = false;
            
            // Submit score to leaderboard
            scoreManager.submitGameResult(score);
            
            // --- STOP ENGINE AND PLAY GAME OVER SOUND ---
            if (engineSound) {
                engineSound.pause();
                engineSound.currentTime = 0; 
            }
            playSound(SOUND_PATHS.gameOver);

            const playTime = scoreManager.getElapsedTimeFormatted();
            document.getElementById('endModal').style.display = 'flex';
            document.getElementById('finalScore').textContent = score + ' | Time: ' + playTime;
        }

        // Initial settings for canvas text
        ctx.font = '16px var(--font-family)';
        ctx.fillStyle = GAME_COLOR;

    </script>
</body>
</html>
