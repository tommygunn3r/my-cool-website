<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Slider: Waterfall Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a2a6c 0%, #b21f1f 50%, #fdbb2d 100%);
            padding: 20px;
            color: white;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            text-align: center;
            max-width: 90vw;
            color: #333;
        }

        h1 {
            color: #b21f1f;
            margin-bottom: 10px;
            font-size: 2em;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .info {
            color: #666;
            margin-bottom: 20px;
            font-size: 0.9em;
            line-height: 1.5;
        }

        .highlight-text {
            color: #d69e2e;
            font-weight: bold;
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 20px 0;
            font-size: 1.1em;
            color: #555;
            flex-wrap: wrap;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .stat-label {
            font-size: 0.8em;
            color: #888;
        }

        .stat-value {
            font-weight: bold;
            font-size: 1.3em;
            color: #b21f1f;
        }

        .puzzle-grid {
            display: inline-grid;
            gap: 8px;
            margin: 20px 0;
            padding: 20px;
            background: #2d3748;
            border-radius: 10px;
            position: relative;
            /* Add padding at bottom to visually separate the laser row slightly */
            padding-bottom: 25px;
        }

        /* Visual indicator for the Laser Line at the BOTTOM */
        .puzzle-grid::after {
            content: 'LASER ZONE';
            position: absolute;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
            color: #fdbb2d;
            font-size: 0.8em;
            font-weight: bold;
            letter-spacing: 2px;
            pointer-events: none;
        }

        .tile {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            border: none;
            border-radius: 8px;
            font-size: 2em;
            font-weight: bold;
            color: #e2e8f0;
            cursor: pointer;
            transition: all 0.2s ease; /* Faster transition for gravity feel */
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* The specific style for tiles in the Laser Row (Bottom) */
        .tile.laser-active {
            background: linear-gradient(135deg, #ecc94b 0%, #d69e2e 100%);
            color: #744210;
            border: 2px solid #ffeb3b;
            box-shadow: 0 0 15px rgba(236, 201, 75, 0.4);
        }

        .tile:hover {
            transform: translateY(-2px);
        }

        .tile.empty {
            background: #1a202c;
            cursor: default;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
            border: none;
        }

        /* Animation for new tiles appearing at top */
        @keyframes dropIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .tile.new-spawn {
            animation: dropIn 0.4s ease;
        }

        .tile.found {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%) !important;
            color: white !important;
            transform: scale(0.9); /* Shrink slightly before vanishing */
            transition: transform 0.2s;
        }

        .buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            font-size: 1em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .new-game-btn {
            background: #b21f1f;
            color: white;
        }

        .new-game-btn:hover {
            background: #801717;
            transform: translateY(-2px);
        }

        .message {
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            font-weight: bold;
            display: none;
        }

        .message.show {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        .message.success {
            background: #48bb78;
            color: white;
            font-size: 1.2em;
        }

        .message.level-up {
            background: #fdbb2d;
            color: #744210;
            font-size: 1.3em;
            border: 2px solid #b7791f;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .words-found {
            margin-top: 20px;
            padding: 15px;
            background: #f7fafc;
            border-radius: 8px;
            max-height: 150px;
            overflow-y: auto;
        }

        .words-found h3 {
            color: #2d3748;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .word-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
        }

        .found-word {
            background: #2d3748;
            color: #fdbb2d;
            padding: 5px 12px;
            border-radius: 5px;
            font-size: 0.9em;
        }

        .file-input-section {
            margin: 20px 0;
            padding: 15px;
            background: #edf2f7;
            border-radius: 8px;
            border: 2px dashed #cbd5e0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Waterfall Slider</h1>
        <p class="info">Drop letters into the <span class="highlight-text">BOTTOM ROW</span>.<br>
        New letters spawn at the top!</p>
        
        <div class="file-input-section" id="fileSection">
            <div id="loadingMessage" class="message show" 
                 style="display: block; background:#2d3748; color:white;">
                Loading **CSW19.txt** dictionary...
            </div>
        </div>

        <div class="stats">
            <div class="stat-item">
                <span class="stat-label">Score</span>
                <span class="stat-value" id="score">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Level</span>
                <span class="stat-value" id="level">1</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Grid Size</span>
                <span class="stat-value" id="gridSize">5x5</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Words Found</span>
                <span class="stat-value" id="wordCount">0</span>
            </div>
        </div>
        
        <div class="puzzle-grid" id="puzzleGrid"></div>

        <div class="buttons">
            <button class="new-game-btn" onclick="newGame()">New Game</button>
        </div>

        <div class="message" id="message"></div>

        <div class="words-found">
            <h3>Extracted Words:</h3>
            <div class="word-list" id="wordList"></div>
        </div>
    </div>

    <script>
        let dictionary = new Set();
        let grid = [];
        let emptyPos = { row: 0, col: 0 };
        let score = 0;
        let level = 1;
        let gridSize = 5; 
        let targetRow = 4; // Will be gridSize - 1
        let wordsFound = [];
        let tileSize = 70;
        let availableLetters = [];
        let dictionaryLoaded = false;

        const letterWeights = {
            'E': 12, 'A': 9, 'I': 9, 'O': 8, 'N': 6, 'R': 6, 'T': 6, 'L': 4, 'S': 4, 'U': 4,
            'D': 4, 'G': 3, 'B': 2, 'C': 2, 'M': 2, 'P': 2, 'F': 2, 'H': 2, 'V': 2, 'W': 2,
            'Y': 2, 'K': 1, 'J': 1, 'X': 1, 'Q': 1, 'Z': 1
        };

        async function loadDictionary() {
            try {
                const response = await fetch('CSW19.txt');
                if (!response.ok) throw new Error(`Status: ${response.status}`);
                const text = await response.text();
                const words = text.split(/\r?\n/).map(w => w.trim().toUpperCase()).filter(w => w.length >= 3);
                dictionary = new Set(words);
                dictionaryLoaded = true;
                
                document.getElementById('loadingMessage').style.display = 'none';
                showMessage(`System Ready! Drop tiles to the bottom!`, 'success');
                initGame();
            } catch (error) {
                const msg = document.getElementById('loadingMessage');
                msg.textContent = `Error loading CSW19.txt. Please upload manually below.`;
                msg.style.background = '#f56565';
                console.error(error);
                
                document.getElementById('fileSection').innerHTML += `
                    <input type="file" id="dictionaryFile" accept=".txt" style="margin-top:10px;">
                `;
                document.getElementById('dictionaryFile').addEventListener('change', handleManualUpload);
            }
        }

        function handleManualUpload(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const text = event.target.result;
                    const words = text.split(/\r?\n/).map(w => w.trim().toUpperCase()).filter(w => w.length >= 3);
                    dictionary = new Set(words);
                    dictionaryLoaded = true;
                    document.getElementById('loadingMessage').style.display = 'none';
                    showMessage(`Dictionary Loaded!`, 'success');
                    initGame();
                };
                reader.readAsText(file);
            }
        }
        
        function createLetterPool() {
            const pool = [];
            for (const [letter, weight] of Object.entries(letterWeights)) {
                for (let i = 0; i < weight; i++) {
                    pool.push(letter);
                }
            }
            return pool;
        }

        function getRandomLetter() {
            if (availableLetters.length === 0) availableLetters = createLetterPool();
            const index = Math.floor(Math.random() * availableLetters.length);
            const letter = availableLetters[index];
            availableLetters.splice(index, 1);
            return letter;
        }

        function initGame() {
            if (!dictionaryLoaded) return;
            
            // Target is always the bottom row
            targetRow = gridSize - 1;
            
            grid = [];
            availableLetters = createLetterPool();
            const totalTiles = gridSize * gridSize;
            
            for (let i = 0; i < gridSize; i++) {
                grid[i] = [];
                for (let j = 0; j < gridSize; j++) {
                    const index = i * gridSize + j;
                    grid[i][j] = index < totalTiles - 1 ? getRandomLetter() : '';
                }
            }
            
            // Place empty tile in a random spot in the UPPER rows to encourage movement down
            emptyPos = { row: 0, col: Math.floor(Math.random() * gridSize) };
            grid[gridSize-1][gridSize-1] = getRandomLetter(); // Ensure bottom right isn't empty by default
            grid[emptyPos.row][emptyPos.col] = '';

            updateTileSize();
            renderGrid();
        }

        function updateTileSize() {
            if (gridSize <= 5) tileSize = 70;
            else if (gridSize <= 7) tileSize = 55;
            else tileSize = 45;
            document.getElementById('puzzleGrid').style.gridTemplateColumns = `repeat(${gridSize}, ${tileSize}px)`;
        }

        function moveTile(row, col) {
            const rowDiff = Math.abs(row - emptyPos.row);
            const colDiff = Math.abs(col - emptyPos.col);
            
            if ((rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1)) {
                grid[emptyPos.row][emptyPos.col] = grid[row][col];
                grid[row][col] = '';
                emptyPos = { row, col };
                
                renderGrid(); 
                checkForWordsInLaserRow(); 
                return true;
            }
            return false;
        }

        function checkForWordsInLaserRow() {
            if (!dictionaryLoaded) return;

            // Construct string for ONLY the target (bottom) row
            const rowStr = grid[targetRow].map(c => c === '' ? ' ' : c).join('');
            
            // Check this specific row
            checkStringForWords(rowStr, targetRow);
        }

        function checkStringForWords(str, rowIndex) {
            for (let start = 0; start < str.length; start++) {
                for (let end = start + 3; end <= str.length; end++) {
                    const substring = str.substring(start, end);
                    
                    if (substring.includes(' ')) continue;
                    
                    if (dictionary.has(substring)) {
                        foundWord(substring, rowIndex, start, end - 1);
                        return true;
                    }
                }
            }
            return false;
        }

        function foundWord(word, rowIndex, startPos, endPos) {
            const points = calculatePoints(word);
            score += points;
            wordsFound.push(word);
            
            document.getElementById('score').textContent = score;
            document.getElementById('wordCount').textContent = wordsFound.length;
            
            const wordList = document.getElementById('wordList');
            const span = document.createElement('span');
            span.className = 'found-word';
            span.textContent = `${word} (${points})`;
            wordList.insertBefore(span, wordList.firstChild);
            
            if (wordList.children.length > 10) wordList.removeChild(wordList.lastChild);
            
            showMessage(`âš¡ MATCH: ${word}! +${points} âš¡`, 'success');

            highlightWord(rowIndex, startPos, endPos);

            setTimeout(() => {
                applyGravity(startPos, endPos);
                checkLevelUp();
            }, 800); // Slightly faster clear time
        }

        function highlightWord(rowIndex, startPos, endPos) {
            const tiles = document.getElementById('puzzleGrid').children;
            for (let pos = startPos; pos <= endPos; pos++) {
                const tileIndex = rowIndex * gridSize + pos;
                if (tiles[tileIndex]) tiles[tileIndex].classList.add('found');
            }
        }

        // --- NEW FUNCTION: GRAVITY LOGIC ---
        function applyGravity(startCol, endCol) {
            // For every column that was part of the word
            for (let col = startCol; col <= endCol; col++) {
                
                // Shift everything above the targetRow DOWN by 1
                // Loop from bottom-1 up to 0
                for (let row = targetRow; row > 0; row--) {
                    grid[row][col] = grid[row - 1][col];
                }
                
                // Spawn new letter at the top
                grid[0][col] = getRandomLetter();

                // CRITICAL: If the empty tile was in this column, we must update its position tracker!
                if (emptyPos.col === col) {
                    // If empty tile was above the cleared line, it falls down
                    if (emptyPos.row < targetRow) {
                        emptyPos.row++;
                    } 
                    // Note: The empty tile cannot be IN the cleared line because words can't contain spaces.
                }
            }
            
            renderGrid(true); // Pass true to indicate gravity update (for animations if needed)
            
            // Check again! Maybe the gravity formed a new word immediately?
            // Small delay to let visual settle
            setTimeout(() => checkForWordsInLaserRow(), 300);
        }

        function renderGrid(isGravityUpdate = false) {
            const gridElement = document.getElementById('puzzleGrid');
            gridElement.innerHTML = '';
            
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const tile = document.createElement('button');
                    let className = 'tile';
                    
                    if (grid[i][j] === '') className += ' empty';
                    if (i === targetRow && grid[i][j] !== '') className += ' laser-active';
                    
                    // If this is the top row and we just did gravity, animate entrance
                    if (isGravityUpdate && i === 0) className += ' new-spawn';

                    tile.className = className;
                    tile.textContent = grid[i][j];
                    tile.style.width = `${tileSize}px`;
                    tile.style.height = `${tileSize}px`;
                    tile.style.fontSize = `${tileSize * 0.4}px`;
                    
                    tile.onclick = () => moveTile(i, j);
                    gridElement.appendChild(tile);
                }
            }
        }

        function calculatePoints(word) {
            return (word.length * word.length) + 10;
        }

        function checkLevelUp() {
            const newLevel = Math.floor(score / 200) + 1; // Higher threshold
            
            if (newLevel > level) {
                level = newLevel;
                const oldSize = gridSize;
                
                // Increase grid by 1 (since we don't need symmetry for center row anymore)
                gridSize = Math.min(5 + (level - 1), 9);
                
                document.getElementById('level').textContent = level;
                document.getElementById('gridSize').textContent = `${gridSize}x${gridSize}`;
                
                if (gridSize > oldSize) {
                    showMessage(`ðŸš€ GRID EXPANDED! ðŸš€`, 'level-up');
                    setTimeout(() => initGame(), 2000);
                } else {
                    showMessage(`â­ Level ${level}! â­`, 'level-up');
                }
            }
        }

        function showMessage(text, type) {
            const msg = document.getElementById('message');
            msg.textContent = text;
            msg.className = `message ${type} show`;
            setTimeout(() => msg.classList.remove('show'), 2500);
        }

        function newGame() {
            if (!dictionaryLoaded) return;
            if (score > 0 && !confirm('Abandon current session?')) return;
            
            score = 0;
            level = 1;
            gridSize = 5;
            wordsFound = [];
            
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('gridSize').textContent = `${gridSize}x${gridSize}`;
            document.getElementById('wordCount').textContent = 0;
            document.getElementById('wordList').innerHTML = '';
            
            initGame();
            showMessage('Gravity Systems Online...', 'success');
        }

        loadDictionary();
    </script>
</body>
</html>
