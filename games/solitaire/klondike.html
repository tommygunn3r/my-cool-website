<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Klondike Solitaire</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Cormorant+Garamond:wght@300;400;600&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* --- Visuals --- */
        :root {
            --gold: #d4af37;
            --gold-dark: #b8941f;
            --gold-light: #f4e5a7;
            --dark: #1a1410;
        }

        body {
            background-color: #1a472a; 
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: fixed;
            transition: background-image 0.5s ease-in-out;
            
            overscroll-behavior: none;
            user-select: none;
            -webkit-user-select: none;
            font-family: 'Cormorant Garamond', serif;
            touch-action: none; 
        }

        /* Card styling */
        .card {
            width: 100%;
            aspect-ratio: 2.5/3.5;
            background-color: white;
            border-radius: 0.4rem;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.4);
            position: absolute;
            transition: transform 0.1s; 
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 0.3rem; 
            cursor: grab;
            backface-visibility: hidden;
            z-index: 10;
            font-family: 'Cinzel', serif; 
            font-weight: 700;
        }
        
        .card:active { cursor: grabbing; }

        @media (min-width: 640px) {
            .card {
                border-radius: 0.5rem;
                padding: 0.4rem;
                box-shadow: 2px 2px 5px rgba(0,0,0,0.4);
            }
        }

        .card-face-down {
            background-image: url('/games/assets/solitaire/card_back.png');
            background-size: cover;
            background-repeat: no-repeat;
            background-position: center;
            border: 1px solid #ddd;
            cursor: default;
        }
        
        .card-face-down > * { display: none !important; }

        .card.selected {
            transform: translateY(-10px);
            box-shadow: 0 0 0 3px var(--gold), 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            z-index: 50 !important;
        }
        
        .card.dragging {
            box-shadow: 0 15px 35px rgba(0,0,0,0.6);
            z-index: 9999 !important;
            pointer-events: none; 
        }
        
        .card.snapping { transition: top 0.2s ease-out, left 0.2s ease-out; }
        .card.hint-anim { animation: wiggle 0.5s ease-in-out; z-index: 60 !important; }

        @keyframes wiggle {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-5deg); }
            75% { transform: rotate(5deg); }
        }

        /* Suit Colors */
        .suit-red { color: #dc143c; }
        .suit-black { color: #000000; }

        /* Layout */
        .tableau-area {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 0.4rem;
            width: 100%;
            max-width: 900px;
            margin: 0 auto;
            padding: 0.5rem;
        }
        @media (min-width: 768px) { .tableau-area { gap: 0.75rem; } }

        .column { position: relative; min-height: 50vh; }
        
        .column.drag-hover, .foundation-pile.drag-hover, .waste-pile.drag-hover {
            background-color: rgba(212, 175, 55, 0.2);
            border-radius: 0.5rem;
            box-shadow: inset 0 0 20px rgba(212, 175, 55, 0.3);
        }

        .foundation-pile, .stock-pile, .waste-pile {
            position: relative;
            aspect-ratio: 2.5/3.5;
            border: 2px dashed rgba(212, 175, 55, 0.4);
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            min-height: 60px;
            max-height: 100px;
        }

        .foundation-pile.filled, .stock-pile.filled, .waste-pile.filled {
            border-style: solid;
            border-color: var(--gold);
        }

        /* Top Bar */
        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.8rem 1.5rem;
            background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.7) 100%);
            border-bottom: 2px solid var(--gold);
            color: var(--gold);
            font-family: 'Cinzel', serif;
        }

        /* Buttons */
        .game-btn {
            font-family: 'Cinzel', serif;
            background: linear-gradient(135deg, var(--gold) 0%, var(--gold-dark) 100%);
            color: var(--dark);
            border: none;
            font-weight: 700;
            box-shadow: 0 3px 10px rgba(212, 175, 55, 0.3);
            transition: all 0.2s;
        }
        .game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(212, 175, 55, 0.5);
        }
        
        /* Modal */
        .modal { background-color: rgba(0, 0, 0, 0.85); }
        .modal-content {
            background: linear-gradient(135deg, #2a1f1a 0%, var(--dark) 100%);
            border: 3px solid var(--gold);
            color: #f5f3e8;
        }

        #confetti-canvas { position: fixed; top: 0; left: 0; pointer-events: none; z-index: 100; }
        #drag-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9000; }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden font-sans text-gray-900">

    <canvas id="confetti-canvas"></canvas>
    
    <div id="drag-layer"></div>

    <div class="top-bar shrink-0 z-20">
        <div class="flex gap-2">
            <button onclick="toggleMenu()" class="game-btn px-3 py-2 sm:px-4 sm:py-2 rounded text-sm sm:text-base">
                MENU
            </button>
            <button onclick="undoMove()" id="undoBtn" class="bg-gray-700 text-white border border-gray-600 px-3 py-2 sm:px-4 sm:py-2 rounded font-bold hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed text-sm sm:text-base font-cinzel">
                UNDO
            </button>
        </div>
        
        <div class="flex flex-col items-center">
            <div class="text-xl sm:text-2xl font-bold text-gold drop-shadow-md" style="color: var(--gold);" id="scoreDisplay">Score: 0</div>
            <div class="text-xs sm:text-sm font-medium text-yellow-200" id="highScoreDisplay">Best: 0</div>
        </div>

        <div class="flex gap-2 items-center">
             <button onclick="showHint()" class="bg-blue-800 text-white border border-blue-600 px-3 py-2 sm:px-4 sm:py-2 rounded font-bold hover:bg-blue-700 text-sm sm:text-base font-cinzel">
                HINT
            </button>
        </div>
    </div>

    <div class="flex-1 flex flex-col overflow-hidden">
        <!-- Top area: Stock, Waste, Foundations -->
        <div class="shrink-0 px-4 py-1">
            <div class="max-w-900px mx-auto grid grid-cols-7 gap-2 sm:gap-3">
                <!-- Stock Pile -->
                <div class="stock-pile" id="stockPile" onclick="drawFromStock()">
                    <div class="text-3xl text-gold opacity-50">ðŸ‚ </div>
                </div>
                
                <!-- Waste Pile -->
                <div class="waste-pile" id="wastePile">
                </div>
                
                <!-- Spacer -->
                <div></div>
                
                <!-- 4 Foundation Piles -->
                <div class="foundation-pile" id="foundation-0" data-suit="hearts">
                    <div class="text-3xl suit-red opacity-30">â™¥</div>
                </div>
                <div class="foundation-pile" id="foundation-1" data-suit="diamonds">
                    <div class="text-3xl suit-red opacity-30">â™¦</div>
                </div>
                <div class="foundation-pile" id="foundation-2" data-suit="clubs">
                    <div class="text-3xl suit-black opacity-30">â™£</div>
                </div>
                <div class="foundation-pile" id="foundation-3" data-suit="spades">
                    <div class="text-3xl suit-black opacity-30">â™ </div>
                </div>
            </div>
        </div>

        <!-- Tableau Area -->
        <div class="flex-1 relative w-full overflow-hidden">
            <div class="tableau-area h-full pt-2" id="tableau">
            </div>
        </div>
    </div>

    <div id="winModal" class="modal fixed inset-0 hidden flex items-center justify-center z-50">
        <div class="modal-content p-8 rounded-xl shadow-2xl text-center max-w-md mx-4">
            <h2 class="text-4xl font-bold mb-4" style="color: var(--gold); font-family: 'Cinzel', serif;">YOU WON!</h2>
            <p class="text-lg mb-6" style="color: #f5f3e8;">Final Score: <span id="finalScoreDisplay" class="font-bold text-gold" style="color: var(--gold);">0</span></p>
            <button onclick="startNewGame()" class="game-btn px-8 py-3 rounded-full text-xl shadow-lg hover:scale-105 transition">
                PLAY AGAIN
            </button>
        </div>
    </div>

    <div id="menuModal" class="modal fixed inset-0 hidden flex items-center justify-center z-50">
        <div class="modal-content p-6 rounded-xl shadow-2xl max-w-sm w-full mx-4">
            <div class="flex justify-between items-center mb-6 border-b border-gray-600 pb-2">
                <h2 class="text-2xl font-bold" style="color: var(--gold); font-family: 'Cinzel', serif;">SETTINGS</h2>
                <button onclick="toggleMenu()" class="text-gray-400 hover:text-white text-3xl">&times;</button>
            </div>
            
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-semibold mb-2" style="color: var(--gold);">Draw Mode</label>
                    <select id="drawModeSelect" class="w-full bg-gray-800 border border-gray-600 rounded px-3 py-2 text-white">
                        <option value="1">Draw 1</option>
                        <option value="3" selected>Draw 3</option>
                    </select>
                </div>

                <div>
                    <label class="block text-sm font-semibold mb-2" style="color: var(--gold);">Theme</label>
                    <select id="themeSelect" class="w-full bg-gray-800 border border-gray-600 rounded px-3 py-2 text-white">
                        <option value="green">Classic Green</option>
                        <option value="red">Royal Red</option>
                        <option value="blue">Ocean Blue</option>
                    </select>
                </div>
            </div>

            <div class="flex gap-3 mt-6">
                <button onclick="saveAndResume()" class="flex-1 bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded">
                    SAVE & RESUME
                </button>
                <button onclick="confirmNewGame()" class="flex-1 game-btn py-2 px-4 rounded">
                    NEW GAME
                </button>
            </div>
        </div>
    </div>

    <div id="messageToast" class="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-black bg-opacity-90 text-gold border border-gold px-6 py-4 rounded-lg pointer-events-none opacity-0 transition-opacity duration-300 z-50 text-center font-bold text-xl shadow-xl font-cinzel" style="color: var(--gold); border-color: var(--gold);">Message</div>

    <script type="module">
        import { db } from '/firebase-config.js';
        import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { collection, addDoc, serverTimestamp, doc, setDoc, increment } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

        let auth = null;
        let currentUser = null;

        // Gatekeeper: Check if logged in
        async function initGameAuth() {
            try {
                auth = getAuth(db.app);
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        console.log("Player Identified:", user.displayName);
                        currentUser = user;
                        scoreManager.playerName = user.displayName || "Unknown Player";
                    } else {
                        // Not logged in? Kick back to the portal
                        window.location.href = '/index.html';
                    }
                });
            } catch (error) {
                console.error("Auth failed:", error);
            }
        }
        initGameAuth();

        // --- Score Manager ---
        class GameScoreManager {
            constructor(gameName) {
                this.gameName = gameName;
                this.sessionStartTime = null;
                this.playerName = "Loading...";
            }

            startSession() {
                this.sessionStartTime = Date.now();
            }

            getElapsedTime() {
                if (!this.sessionStartTime) return 0;
                return Math.floor((Date.now() - this.sessionStartTime) / 1000);
            }

            getElapsedTimeFormatted() {
                const seconds = this.getElapsedTime();
                if (seconds < 60) return `${seconds}s`;
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins}m ${secs}s`;
            }

            async submitGameResult(score = 0) {
                if (!currentUser) return;

                const timePlayed = this.getElapsedTime();
                
                try {
                    // Public Leaderboard
                    await addDoc(collection(db, 'scores'), {
                        gameName: this.gameName,
                        playerName: this.playerName,
                        score: score,
                        timePlayed: timePlayed,
                        timestamp: serverTimestamp(),
                        uid: currentUser.uid
                    });

                    console.log(`âœ… Score submitted: ${score} for ${this.gameName}`);
                } catch (error) {
                    console.error("Score submission failed:", error);
                }
            }
        }
        const scoreManager = new GameScoreManager('Klondike Solitaire');

        // --- Assets & Constants ---
        const ICONS = { spades: 'â™ ', hearts: 'â™¥', clubs: 'â™£', diamonds: 'â™¦' };
        const SUITS = ['hearts', 'diamonds', 'clubs', 'spades'];
        const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        const VALUES = { 'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13 };
        
        const THEMES = {
            green: '/games/assets/solitaire/greentop.png',
            red: '/games/assets/solitaire/redtop.png',
            blue: '/games/assets/solitaire/bluetop.png'
        };

        let state = {
            tableau: [[], [], [], [], [], [], []],
            stock: [],
            waste: [],
            foundations: [[], [], [], []],
            history: [],
            score: 0,
            highScore: 0,
            drawMode: 3,
            selectedCard: null,
            theme: 'green',
            stockPasses: 0
        };

        let drag = {
            active: false,
            startX: 0, startY: 0,
            sourceType: null, // 'tableau', 'waste', 'foundation'
            sourceIndex: null,
            cardIndex: null,
            elStack: [],
            originalRects: [],
            offsetX: 0, offsetY: 0,
            hasMoved: false
        };

        function init() {
            loadHighScore();
            loadPreferences();
            applyTheme();
            startNewGame();
            setupDragListeners();
        }

        function loadHighScore() {
            state.highScore = parseInt(localStorage.getItem('klondike_highScore') || '0');
            updateHighScoreDisplay();
        }

        function saveHighScore() {
            if (state.score > state.highScore) {
                state.highScore = state.score;
                localStorage.setItem('klondike_highScore', state.highScore);
                updateHighScoreDisplay();
            }
        }

        function loadPreferences() {
            state.drawMode = parseInt(localStorage.getItem('klondike_drawMode') || '3');
            state.theme = localStorage.getItem('klondike_theme') || 'green';
        }

        function startNewGame() {
            scoreManager.startSession();
            state.tableau = [[], [], [], [], [], [], []];
            state.stock = [];
            state.waste = [];
            state.foundations = [[], [], [], []];
            state.history = [];
            state.score = 0;
            state.selectedCard = null;
            state.stockPasses = 0;

            stopConfetti();
            document.getElementById('winModal').classList.add('hidden');
            
            dealNewGame();
            updateScore();
            updateUndoButton();
        }

        function dealNewGame() {
            // Create deck
            const deck = [];
            for (let suit of SUITS) {
                for (let rank of RANKS) {
                    deck.push({ suit, rank, value: VALUES[rank], faceUp: false });
                }
            }
            
            // Shuffle
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }

            // Deal to tableau (1, 2, 3, 4, 5, 6, 7 cards)
            let deckIndex = 0;
            for (let col = 0; col < 7; col++) {
                for (let row = 0; row <= col; row++) {
                    const card = deck[deckIndex++];
                    card.faceUp = (row === col); // Last card face up
                    state.tableau[col].push(card);
                }
            }

            // Remaining cards to stock
            state.stock = deck.slice(deckIndex);
            
            renderBoard();
        }

        function renderBoard() {
            renderTableau();
            renderStock();
            renderWaste();
            renderFoundations();
        }

        function renderTableau() {
            const tableauEl = document.getElementById('tableau');
            tableauEl.innerHTML = '';

            state.tableau.forEach((col, colIndex) => {
                const colEl = document.createElement('div');
                colEl.className = 'column';
                colEl.dataset.col = colIndex;
                colEl.onclick = (e) => { if(e.target === colEl) handleEmptyColumnClick(colIndex); };

                let overlap = 25;
                if (window.innerWidth < 640) overlap = 20;

                col.forEach((card, cardIndex) => {
                    const cardEl = createCardElement(card, cardIndex * overlap);
                    cardEl.dataset.source = 'tableau';
                    cardEl.dataset.sourceIndex = colIndex;
                    cardEl.dataset.cardIndex = cardIndex;

                    if (state.selectedCard && 
                        state.selectedCard.sourceType === 'tableau' && 
                        state.selectedCard.sourceIndex === colIndex && 
                        state.selectedCard.cardIndex === cardIndex) {
                        cardEl.classList.add('selected');
                    }

                    if (card.faceUp) {
                        cardEl.addEventListener('mousedown', (e) => handleInputStart(e, 'tableau', colIndex, cardIndex));
                        cardEl.addEventListener('touchstart', (e) => handleInputStart(e, 'tableau', colIndex, cardIndex), {passive: false});
                    }

                    colEl.appendChild(cardEl);
                });
                tableauEl.appendChild(colEl);
            });
        }

        function renderStock() {
            const stockEl = document.getElementById('stockPile');
            if (state.stock.length === 0) {
                stockEl.classList.remove('filled');
                stockEl.innerHTML = '<div class="text-3xl text-gold opacity-30">â†»</div>';
            } else {
                stockEl.classList.add('filled');
                stockEl.innerHTML = '';
                const cardEl = createCardElement({ faceUp: false }, 0);
                cardEl.style.position = 'relative';
                stockEl.appendChild(cardEl);
            }
        }

        function renderWaste() {
            const wasteEl = document.getElementById('wastePile');
            wasteEl.innerHTML = '';

            if (state.waste.length === 0) {
                wasteEl.classList.remove('filled');
                return;
            }

            wasteEl.classList.add('filled');

            // Show last 3 cards (or less)
            const visibleCount = Math.min(3, state.waste.length);
            const startIndex = state.waste.length - visibleCount;

            for (let i = startIndex; i < state.waste.length; i++) {
                const card = state.waste[i];
                const offset = (i - startIndex) * 20;
                const cardEl = createCardElement(card, 0);
                cardEl.style.position = 'absolute';
                cardEl.style.left = `${offset}px`;
                cardEl.dataset.source = 'waste';
                cardEl.dataset.sourceIndex = i;

                if (i === state.waste.length - 1) { // Only top card is draggable
                    cardEl.addEventListener('mousedown', (e) => handleInputStart(e, 'waste', i, 0));
                    cardEl.addEventListener('touchstart', (e) => handleInputStart(e, 'waste', i, 0), {passive: false});

                    if (state.selectedCard && state.selectedCard.sourceType === 'waste' && state.selectedCard.sourceIndex === i) {
                        cardEl.classList.add('selected');
                    }
                }

                wasteEl.appendChild(cardEl);
            }
        }

        function renderFoundations() {
            for (let i = 0; i < 4; i++) {
                const foundEl = document.getElementById(`foundation-${i}`);
                foundEl.innerHTML = '';

                if (state.foundations[i].length === 0) {
                    foundEl.classList.remove('filled');
                    const suit = foundEl.dataset.suit;
                    foundEl.innerHTML = `<div class="text-3xl ${getSuitColor(suit)} opacity-30">${ICONS[suit]}</div>`;
                } else {
                    foundEl.classList.add('filled');
                    const topCard = state.foundations[i][state.foundations[i].length - 1];
                    const cardEl = createCardElement(topCard, 0);
                    cardEl.style.position = 'relative';
                    foundEl.appendChild(cardEl);
                }
            }
        }

        function createCardElement(card, topOffset) {
            const cardEl = document.createElement('div');
            cardEl.className = `card ${card.faceUp ? '' : 'card-face-down'} ${card.faceUp ? getSuitColor(card.suit) : ''}`;
            cardEl.style.top = `${topOffset}px`;

            if (card.faceUp) {
                const topDiv = document.createElement('div');
                topDiv.className = 'flex flex-col items-center leading-none select-none';
                topDiv.innerHTML = `<span class="text-xl font-bold">${card.rank}</span>`;
                
                const centerDiv = document.createElement('div');
                centerDiv.className = 'absolute inset-0 flex items-center justify-center pointer-events-none';
                centerDiv.innerHTML = `<span class="text-6xl">${ICONS[card.suit]}</span>`;
                
                const botDiv = document.createElement('div');
                botDiv.className = 'flex flex-col items-center leading-none select-none transform rotate-180';
                botDiv.innerHTML = `<span class="text-xl font-bold">${card.rank}</span>`;
                
                cardEl.appendChild(topDiv);
                cardEl.appendChild(centerDiv);
                cardEl.appendChild(botDiv);
            }

            return cardEl;
        }

        // --- Drag & Drop System ---
        function setupDragListeners() {
            document.addEventListener('mousemove', handleInputMove);
            document.addEventListener('touchmove', handleInputMove, {passive: false});
            document.addEventListener('mouseup', handleInputEnd);
            document.addEventListener('touchend', handleInputEnd);
        }

        function handleInputStart(e, sourceType, sourceIndex, cardIndex) {
            e.preventDefault();
            e.stopPropagation();

            const card = getCard(sourceType, sourceIndex, cardIndex);
            if (!card || !card.faceUp) return;

            // Check if card can be moved
            if (sourceType === 'tableau' && cardIndex < state.tableau[sourceIndex].length - 1) {
                // Can only move valid runs in tableau
                if (!isValidTableauRun(sourceIndex, cardIndex)) return;
            }

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            drag.active = true;
            drag.startX = clientX;
            drag.startY = clientY;
            drag.sourceType = sourceType;
            drag.sourceIndex = sourceIndex;
            drag.cardIndex = cardIndex;
            drag.hasMoved = false;

            // Get cards to drag
            const cardsToDrag = getCardsToDrag(sourceType, sourceIndex, cardIndex);
            const cardElements = getCardElements(sourceType, sourceIndex, cardIndex);

            drag.elStack = cardElements;
            drag.originalRects = cardElements.map(el => el.getBoundingClientRect());

            const firstRect = drag.originalRects[0];
            drag.offsetX = clientX - firstRect.left;
            drag.offsetY = clientY - firstRect.top;
        }

        function handleInputMove(e) {
            if (!drag.active) return;
            e.preventDefault();

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const deltaX = Math.abs(clientX - drag.startX);
            const deltaY = Math.abs(clientY - drag.startY);

            if (!drag.hasMoved && (deltaX > 3 || deltaY > 3)) {
                drag.hasMoved = true;
                startDragging();
            }

            if (drag.hasMoved) {
                updateDragPosition(clientX, clientY);
                updateDropHighlight(clientX, clientY);
            }
        }

        function handleInputEnd(e) {
            if (!drag.active) return;

            if (!drag.hasMoved) {
                // Click without drag - select card
                selectCard(drag.sourceType, drag.sourceIndex, drag.cardIndex);
                drag.active = false;
                return;
            }

            const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
            const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;

            const dropTarget = findDropTarget(clientX, clientY);
            
            if (dropTarget) {
                tryMove(drag.sourceType, drag.sourceIndex, drag.cardIndex, dropTarget.type, dropTarget.index);
            }

            endDragging();
            clearDropHighlights();
            drag.active = false;
        }

        function startDragging() {
            const dragLayer = document.getElementById('drag-layer');
            
            drag.elStack.forEach((el, i) => {
                const rect = drag.originalRects[i];
                const clone = el.cloneNode(true);
                clone.classList.add('dragging');
                clone.style.position = 'fixed';
                clone.style.width = `${rect.width}px`;
                clone.style.height = `${rect.height}px`;
                clone.style.left = `${rect.left}px`;
                clone.style.top = `${rect.top}px`;
                clone.style.zIndex = 9000 + i;
                dragLayer.appendChild(clone);
                el.style.opacity = '0.3';
            });
        }

        function updateDragPosition(clientX, clientY) {
            const dragLayer = document.getElementById('drag-layer');
            const clones = Array.from(dragLayer.children);
            
            clones.forEach((clone, i) => {
                const rect = drag.originalRects[i];
                clone.style.left = `${clientX - drag.offsetX}px`;
                clone.style.top = `${clientY - drag.offsetY + (i * 25)}px`;
            });
        }

        function endDragging() {
            const dragLayer = document.getElementById('drag-layer');
            dragLayer.innerHTML = '';
            drag.elStack.forEach(el => el.style.opacity = '1');
        }

        function updateDropHighlight(x, y) {
            clearDropHighlights();
            const target = findDropTarget(x, y);
            if (target) {
                const el = getDropTargetElement(target);
                if (el) el.classList.add('drag-hover');
            }
        }

        function clearDropHighlights() {
            document.querySelectorAll('.drag-hover').forEach(el => el.classList.remove('drag-hover'));
        }

        function findDropTarget(x, y) {
            const el = document.elementFromPoint(x, y);
            if (!el) return null;

            // Check tableau
            const colEl = el.closest('.column');
            if (colEl) {
                return { type: 'tableau', index: parseInt(colEl.dataset.col) };
            }

            // Check foundation
            const foundEl = el.closest('.foundation-pile');
            if (foundEl) {
                const id = foundEl.id;
                const index = parseInt(id.split('-')[1]);
                return { type: 'foundation', index };
            }

            return null;
        }

        function getDropTargetElement(target) {
            if (target.type === 'tableau') {
                return document.querySelector(`.column[data-col="${target.index}"]`);
            } else if (target.type === 'foundation') {
                return document.getElementById(`foundation-${target.index}`);
            }
            return null;
        }

        // --- Game Logic ---
        function getCard(sourceType, sourceIndex, cardIndex) {
            if (sourceType === 'tableau') {
                return state.tableau[sourceIndex][cardIndex];
            } else if (sourceType === 'waste') {
                return state.waste[sourceIndex];
            } else if (sourceType === 'foundation') {
                return state.foundations[sourceIndex][cardIndex];
            }
            return null;
        }

        function getCardsToDrag(sourceType, sourceIndex, cardIndex) {
            if (sourceType === 'tableau') {
                return state.tableau[sourceIndex].slice(cardIndex);
            } else if (sourceType === 'waste') {
                return [state.waste[sourceIndex]];
            }
            return [];
        }

        function getCardElements(sourceType, sourceIndex, cardIndex) {
            if (sourceType === 'tableau') {
                const col = document.querySelector(`.column[data-col="${sourceIndex}"]`);
                const allCards = Array.from(col.querySelectorAll('.card'));
                return allCards.slice(cardIndex);
            } else if (sourceType === 'waste') {
                const waste = document.getElementById('wastePile');
                return [waste.querySelector('.card:last-child')];
            }
            return [];
        }

        function isValidTableauRun(colIndex, startIndex) {
            const cards = state.tableau[colIndex].slice(startIndex);
            for (let i = 0; i < cards.length - 1; i++) {
                const curr = cards[i];
                const next = cards[i + 1];
                if (!curr.faceUp || !next.faceUp) return false;
                if (isRed(curr.suit) === isRed(next.suit)) return false; // Must alternate colors
                if (curr.value !== next.value + 1) return false; // Must be descending
            }
            return true;
        }

        function isRed(suit) {
            return suit === 'hearts' || suit === 'diamonds';
        }

        function canMoveToTableau(cards, targetCol) {
            const targetPile = state.tableau[targetCol];
            const movingCard = cards[0];

            if (targetPile.length === 0) {
                return movingCard.value === 13; // Only King can go to empty column
            }

            const targetCard = targetPile[targetPile.length - 1];
            if (!targetCard.faceUp) return false;
            if (isRed(movingCard.suit) === isRed(targetCard.suit)) return false; // Must alternate colors
            if (movingCard.value !== targetCard.value - 1) return false; // Must be descending

            return true;
        }

        function canMoveToFoundation(card, foundIndex) {
            const foundPile = state.foundations[foundIndex];
            const foundSuit = ['hearts', 'diamonds', 'clubs', 'spades'][foundIndex];

            if (card.suit !== foundSuit) return false;

            if (foundPile.length === 0) {
                return card.value === 1; // Must be Ace
            }

            const topCard = foundPile[foundPile.length - 1];
            return card.value === topCard.value + 1; // Must be ascending
        }

        function tryMove(fromType, fromIndex, cardIndex, toType, toIndex) {
            const cards = getCardsToDrag(fromType, fromIndex, cardIndex);
            if (cards.length === 0) return;

            let valid = false;
            let scoreChange = 0;

            if (toType === 'tableau') {
                valid = canMoveToTableau(cards, toIndex);
                if (valid) {
                    // Move cards
                    removeCards(fromType, fromIndex, cardIndex);
                    state.tableau[toIndex].push(...cards);
                    
                    // Score: +5 for moving from waste to tableau
                    if (fromType === 'waste') scoreChange = 5;
                }
            } else if (toType === 'foundation' && cards.length === 1) {
                valid = canMoveToFoundation(cards[0], toIndex);
                if (valid) {
                    removeCards(fromType, fromIndex, cardIndex);
                    state.foundations[toIndex].push(cards[0]);
                    
                    // Score: +10 for moving to foundation
                    scoreChange = 10;
                }
            }

            if (valid) {
                // Flip face-down card if revealed
                if (fromType === 'tableau' && state.tableau[fromIndex].length > 0) {
                    const topCard = state.tableau[fromIndex][state.tableau[fromIndex].length - 1];
                    if (!topCard.faceUp) {
                        topCard.faceUp = true;
                        scoreChange += 5; // +5 for revealing card
                    }
                }

                state.score += scoreChange;
                updateScore();
                saveHighScore();
                renderBoard();
                checkWin();
            }
        }

        function removeCards(sourceType, sourceIndex, cardIndex) {
            if (sourceType === 'tableau') {
                state.tableau[sourceIndex].splice(cardIndex);
            } else if (sourceType === 'waste') {
                state.waste.pop();
            }
        }

        function selectCard(sourceType, sourceIndex, cardIndex) {
            const card = getCard(sourceType, sourceIndex, cardIndex);
            if (!card || !card.faceUp) return;

            // If clicking same card, deselect
            if (state.selectedCard && 
                state.selectedCard.sourceType === sourceType &&
                state.selectedCard.sourceIndex === sourceIndex &&
                state.selectedCard.cardIndex === cardIndex) {
                state.selectedCard = null;
                renderBoard();
                return;
            }

            // If card is selected, try to move to clicked location
            if (state.selectedCard) {
                const cards = getCardsToDrag(state.selectedCard.sourceType, state.selectedCard.sourceIndex, state.selectedCard.cardIndex);
                
                // Try foundation first (double-click to foundation)
                for (let i = 0; i < 4; i++) {
                    if (cards.length === 1 && canMoveToFoundation(cards[0], i)) {
                        tryMove(state.selectedCard.sourceType, state.selectedCard.sourceIndex, state.selectedCard.cardIndex, 'foundation', i);
                        state.selectedCard = null;
                        return;
                    }
                }

                state.selectedCard = null;
                renderBoard();
                return;
            }

            // Select new card
            state.selectedCard = { sourceType, sourceIndex, cardIndex };
            renderBoard();
        }

        function handleEmptyColumnClick(colIndex) {
            if (!state.selectedCard) return;

            const cards = getCardsToDrag(state.selectedCard.sourceType, state.selectedCard.sourceIndex, state.selectedCard.cardIndex);
            if (cards[0].value === 13) { // Only King
                tryMove(state.selectedCard.sourceType, state.selectedCard.sourceIndex, state.selectedCard.cardIndex, 'tableau', colIndex);
            }
            state.selectedCard = null;
        }

        function drawFromStock() {
            if (state.stock.length === 0) {
                if (state.waste.length === 0) return;
                
                // Reset stock from waste
                state.stock = state.waste.reverse();
                state.waste = [];
                state.stockPasses++;
                
                // Penalty for cycling through stock (after first pass)
                if (state.drawMode === 3 && state.stockPasses > 1) {
                    state.score = Math.max(0, state.score - 20);
                    updateScore();
                }
                
                renderBoard();
                return;
            }

            const drawCount = Math.min(state.drawMode, state.stock.length);
            for (let i = 0; i < drawCount; i++) {
                const card = state.stock.pop();
                card.faceUp = true;
                state.waste.push(card);
            }

            renderBoard();
        }

        function checkWin() {
            const allFoundationsFilled = state.foundations.every(pile => pile.length === 13);
            if (allFoundationsFilled) {
                document.getElementById('finalScoreDisplay').textContent = state.score;
                document.getElementById('winModal').classList.remove('hidden');
                startConfetti();
                scoreManager.submitGameResult(state.score);
            }
        }

        // --- Utils & UI ---
        function getSuitColor(suit) { 
            return (suit === 'hearts' || suit === 'diamonds') ? 'suit-red' : 'suit-black'; 
        }

        function updateScore() { 
            document.getElementById('scoreDisplay').innerText = `Score: ${state.score}`; 
        }

        function updateHighScoreDisplay() { 
            document.getElementById('highScoreDisplay').textContent = `Best: ${state.highScore}`; 
        }

        function updateUndoButton() { 
            document.getElementById('undoBtn').disabled = state.history.length === 0; 
        }

        function undoMove() {
            // TODO: Implement undo system
            showMessage("Undo coming soon!");
        }

        function showMessage(msg) {
            const el = document.getElementById('messageToast');
            el.innerText = msg;
            el.style.opacity = '1';
            setTimeout(() => { el.style.opacity = '0'; }, 2000);
        }

        function toggleMenu() { 
            document.getElementById('menuModal').classList.toggle('hidden'); 
        }
        
        function applyTheme() {
            const url = THEMES[state.theme];
            document.body.style.backgroundImage = `url('${url}')`;
        }

        function saveAndResume() {
            const drawModeSelect = document.getElementById('drawModeSelect');
            state.drawMode = parseInt(drawModeSelect.value);
            localStorage.setItem('klondike_drawMode', state.drawMode);

            const themeSelect = document.getElementById('themeSelect');
            const newTheme = themeSelect.value;
            if (newTheme !== state.theme) {
                state.theme = newTheme;
                localStorage.setItem('klondike_theme', state.theme);
                applyTheme();
            }
            toggleMenu();
        }

        function confirmNewGame() {
            const drawModeSelect = document.getElementById('drawModeSelect');
            state.drawMode = parseInt(drawModeSelect.value);
            localStorage.setItem('klondike_drawMode', state.drawMode);
            
            const themeSelect = document.getElementById('themeSelect');
            state.theme = themeSelect.value;
            localStorage.setItem('klondike_theme', state.theme);
            applyTheme();

            toggleMenu(); 
            startNewGame();
        }

        function showHint() {
            // Check for moves from waste
            if (state.waste.length > 0) {
                const wasteCard = state.waste[state.waste.length - 1];
                
                // Check foundation
                for (let i = 0; i < 4; i++) {
                    if (canMoveToFoundation(wasteCard, i)) {
                        animateHint('waste');
                        return;
                    }
                }
                
                // Check tableau
                for (let i = 0; i < 7; i++) {
                    if (canMoveToTableau([wasteCard], i)) {
                        animateHint('waste');
                        return;
                    }
                }
            }

            // Check for moves from tableau
            for (let col = 0; col < 7; col++) {
                if (state.tableau[col].length === 0) continue;
                
                const len = state.tableau[col].length;
                for (let cardIdx = len - 1; cardIdx >= 0; cardIdx--) {
                    const card = state.tableau[col][cardIdx];
                    if (!card.faceUp) continue;

                    // Check if it's a valid run
                    if (!isValidTableauRun(col, cardIdx)) continue;

                    const cards = state.tableau[col].slice(cardIdx);
                    
                    // Check foundation (only single cards)
                    if (cards.length === 1) {
                        for (let i = 0; i < 4; i++) {
                            if (canMoveToFoundation(card, i)) {
                                animateHint('tableau', col, cardIdx);
                                return;
                            }
                        }
                    }
                    
                    // Check other tableau columns
                    for (let targetCol = 0; targetCol < 7; targetCol++) {
                        if (targetCol === col) continue;
                        if (canMoveToTableau(cards, targetCol)) {
                            animateHint('tableau', col, cardIdx);
                            return;
                        }
                    }
                }
            }

            showMessage("No moves found. Try drawing from stock!");
        }

        function animateHint(sourceType, colIdx, cardIdx) {
            if (sourceType === 'waste') {
                const wasteEl = document.getElementById('wastePile');
                const card = wasteEl.querySelector('.card:last-child');
                if (card) {
                    card.classList.add('hint-anim');
                    setTimeout(() => card.classList.remove('hint-anim'), 500);
                }
            } else if (sourceType === 'tableau') {
                const tableau = document.getElementById('tableau');
                const col = tableau.children[colIdx];
                const card = col.children[cardIdx];
                if (card) {
                    card.classList.add('hint-anim');
                    setTimeout(() => card.classList.remove('hint-anim'), 500);
                }
            }
        }

        let confettiInterval;
        function startConfetti() {
            const canvas = document.getElementById('confetti-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            const pieces = [];
            const colors = ['#d4af37', '#f4e5a7', '#ffffff', '#b8941f'];
            for(let i=0; i<200; i++) {
                pieces.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height - canvas.height,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    size: Math.random() * 8 + 4,
                    speedY: Math.random() * 5 + 2,
                    speedX: Math.random() * 2 - 1
                });
            }
            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                pieces.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x, p.y, p.size, p.size);
                    p.y += p.speedY;
                    p.x += p.speedX;
                    if(p.y > canvas.height) p.y = -20;
                });
                confettiInterval = requestAnimationFrame(animate);
            }
            animate();
        }

        function stopConfetti() {
            if (confettiInterval) cancelAnimationFrame(confettiInterval);
            const canvas = document.getElementById('confetti-canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        window.drawFromStock = drawFromStock;
        window.toggleMenu = toggleMenu;
        window.undoMove = undoMove;
        window.showHint = showHint;
        window.startNewGame = startNewGame;
        window.confirmNewGame = confirmNewGame;
        window.saveAndResume = saveAndResume;
        window.handleEmptyColumnClick = handleEmptyColumnClick;

        init();
    </script>
</body>
</html>
