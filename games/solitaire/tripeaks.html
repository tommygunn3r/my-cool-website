<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TriPeaks Solitaire</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Cormorant+Garamond:wght@300;400;600&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* --- Visuals --- */
        :root {
            --gold: #d4af37;
            --gold-dark: #b8941f;
            --gold-light: #f4e5a7;
            --dark: #1a1410;
        }

        body {
            background-color: #1a472a; 
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: fixed;
            transition: background-image 0.5s ease-in-out;
            
            overscroll-behavior: none;
            user-select: none;
            -webkit-user-select: none;
            font-family: 'Cormorant Garamond', serif;
            touch-action: none; 
        }

        /* Card styling */
        .card {
            width: 100%;
            aspect-ratio: 2.5/3.5;
            background-color: white;
            border-radius: 0.4rem;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.4);
            position: absolute;
            transition: transform 0.1s; 
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 0.3rem; 
            cursor: pointer;
            backface-visibility: hidden;
            z-index: 10;
            font-family: 'Cinzel', serif; 
            font-weight: 700;
        }
        
        .card:hover { transform: scale(1.05); }

        @media (min-width: 640px) {
            .card {
                border-radius: 0.5rem;
                padding: 0.4rem;
                box-shadow: 2px 2px 5px rgba(0,0,0,0.4);
            }
        }

        .card-face-down {
            background-image: url('/games/assets/solitaire/card_back.png');
            background-size: cover;
            background-repeat: no-repeat;
            background-position: center;
            border: 1px solid #ddd;
            cursor: default;
        }
        
        .card-face-down:hover { transform: none; }
        .card-face-down > * { display: none !important; }

        .card.playable {
            box-shadow: 0 0 0 2px var(--gold), 0 4px 10px rgba(212, 175, 55, 0.4);
            cursor: pointer;
        }

        .card.blocked {
            opacity: 0.7;
            cursor: not-allowed;
        }
        
        .card.cleared {
            animation: clearCard 0.3s ease-out forwards;
        }

        @keyframes clearCard {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0.8) translateY(100px); opacity: 0; }
        }

        .card.hint-anim { animation: wiggle 0.5s ease-in-out; z-index: 60 !important; }

        @keyframes wiggle {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-5deg); }
            75% { transform: rotate(5deg); }
        }

        /* Suit Colors */
        .suit-red { color: #dc143c; }
        .suit-black { color: #000000; }

        /* Layout */
        .peaks-container {
            position: relative;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem;
            min-height: 60vh;
        }

        .card-slot {
            position: absolute;
            width: 70px;
            aspect-ratio: 2.5/3.5;
        }

        @media (min-width: 640px) {
            .card-slot { width: 85px; }
        }

        @media (min-width: 1024px) {
            .card-slot { width: 100px; }
        }

        .bottom-area {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 2rem;
            padding: 1rem;
        }

        .stock-pile, .waste-pile {
            position: relative;
            width: 100px;
            aspect-ratio: 2.5/3.5;
            border: 2px dashed rgba(212, 175, 55, 0.4);
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .stock-pile.filled, .waste-pile.filled {
            border-style: solid;
            border-color: var(--gold);
        }

        /* Top Bar */
        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.8rem 1.5rem;
            background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.7) 100%);
            border-bottom: 2px solid var(--gold);
            color: var(--gold);
            font-family: 'Cinzel', serif;
        }

        /* Buttons */
        .game-btn {
            font-family: 'Cinzel', serif;
            background: linear-gradient(135deg, var(--gold) 0%, var(--gold-dark) 100%);
            color: var(--dark);
            border: none;
            font-weight: 700;
            box-shadow: 0 3px 10px rgba(212, 175, 55, 0.3);
            transition: all 0.2s;
        }
        .game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(212, 175, 55, 0.5);
        }
        
        /* Modal */
        .modal { background-color: rgba(0, 0, 0, 0.85); }
        .modal-content {
            background: linear-gradient(135deg, #2a1f1a 0%, var(--dark) 100%);
            border: 3px solid var(--gold);
            color: #f5f3e8;
        }

        #confetti-canvas { position: fixed; top: 0; left: 0; pointer-events: none; z-index: 100; }

        .streak-display {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem;
            font-weight: 900;
            color: var(--gold);
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.8);
            pointer-events: none;
            opacity: 0;
            z-index: 90;
            font-family: 'Cinzel', serif;
        }

        .streak-display.show {
            animation: streakPop 0.6s ease-out;
        }

        @keyframes streakPop {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden font-sans text-gray-900">

    <canvas id="confetti-canvas"></canvas>
    <div id="streakDisplay" class="streak-display"></div>

    <div class="top-bar shrink-0 z-20">
        <div class="flex gap-2">
            <button onclick="toggleMenu()" class="game-btn px-3 py-2 sm:px-4 sm:py-2 rounded text-sm sm:text-base">
                MENU
            </button>
            <button onclick="undoMove()" id="undoBtn" class="bg-gray-700 text-white border border-gray-600 px-3 py-2 sm:px-4 sm:py-2 rounded font-bold hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed text-sm sm:text-base font-cinzel">
                UNDO
            </button>
        </div>
        
        <div class="flex flex-col items-center">
            <div class="text-xl sm:text-2xl font-bold text-gold drop-shadow-md" style="color: var(--gold);" id="scoreDisplay">Score: 0</div>
            <div class="text-xs sm:text-sm font-medium text-yellow-200" id="streakDisplay2">Streak: 0</div>
        </div>

        <div class="flex gap-2 items-center">
             <button onclick="showHint()" class="bg-blue-800 text-white border border-blue-600 px-3 py-2 sm:px-4 sm:py-2 rounded font-bold hover:bg-blue-700 text-sm sm:text-base font-cinzel">
                HINT
            </button>
        </div>
    </div>

    <div class="flex-1 flex flex-col overflow-hidden">
        <!-- Peaks Area -->
        <div class="flex-1 relative w-full overflow-hidden">
            <div class="peaks-container" id="peaksContainer">
            </div>
        </div>

        <!-- Bottom Area: Stock and Waste -->
        <div class="shrink-0 bottom-area">
            <div class="stock-pile" id="stockPile" onclick="drawFromStock()">
                <div class="text-3xl text-gold opacity-50">ðŸ‚ </div>
                <div class="absolute bottom-1 text-xs font-bold text-gold" id="stockCount"></div>
            </div>
            
            <div class="waste-pile" id="wastePile">
            </div>
        </div>
    </div>

    <div id="winModal" class="modal fixed inset-0 hidden flex items-center justify-center z-50">
        <div class="modal-content p-8 rounded-xl shadow-2xl text-center max-w-md mx-4">
            <h2 class="text-4xl font-bold mb-4" style="color: var(--gold); font-family: 'Cinzel', serif;">PEAKS CLEARED!</h2>
            <p class="text-lg mb-2" style="color: #f5f3e8;">Final Score: <span id="finalScoreDisplay" class="font-bold text-gold" style="color: var(--gold);">0</span></p>
            <p class="text-sm mb-6" style="color: #f5f3e8;">Time: <span id="finalTimeDisplay" class="font-bold">0:00</span></p>
            <button onclick="startNewGame()" class="game-btn px-8 py-3 rounded-full text-xl shadow-lg hover:scale-105 transition">
                PLAY AGAIN
            </button>
        </div>
    </div>

    <div id="loseModal" class="modal fixed inset-0 hidden flex items-center justify-center z-50">
        <div class="modal-content p-8 rounded-xl shadow-2xl text-center max-w-md mx-4">
            <h2 class="text-4xl font-bold mb-4" style="color: #dc143c; font-family: 'Cinzel', serif;">NO MORE MOVES</h2>
            <p class="text-lg mb-2" style="color: #f5f3e8;">Final Score: <span id="loseScoreDisplay" class="font-bold text-gold" style="color: var(--gold);">0</span></p>
            <p class="text-sm mb-6" style="color: #f5f3e8;">Cards Remaining: <span id="cardsRemainingDisplay" class="font-bold">0</span></p>
            <button onclick="startNewGame()" class="game-btn px-8 py-3 rounded-full text-xl shadow-lg hover:scale-105 transition">
                TRY AGAIN
            </button>
        </div>
    </div>

    <div id="menuModal" class="modal fixed inset-0 hidden flex items-center justify-center z-50">
        <div class="modal-content p-6 rounded-xl shadow-2xl max-w-sm w-full mx-4">
            <div class="flex justify-between items-center mb-6 border-b border-gray-600 pb-2">
                <h2 class="text-2xl font-bold" style="color: var(--gold); font-family: 'Cinzel', serif;">SETTINGS</h2>
                <button onclick="toggleMenu()" class="text-gray-400 hover:text-white text-3xl">&times;</button>
            </div>
            
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-semibold mb-2" style="color: var(--gold);">Theme</label>
                    <select id="themeSelect" class="w-full bg-gray-800 border border-gray-600 rounded px-3 py-2 text-white">
                        <option value="green">Classic Green</option>
                        <option value="red">Royal Red</option>
                        <option value="blue">Ocean Blue</option>
                    </select>
                </div>

                <div class="text-sm text-gray-400 border-t border-gray-600 pt-4">
                    <p class="mb-2"><strong class="text-gold">How to Play:</strong></p>
                    <p>â€¢ Clear all three peaks by removing cards</p>
                    <p>â€¢ Click cards one higher or lower than the waste pile</p>
                    <p>â€¢ Streaks earn bonus points!</p>
                    <p>â€¢ Aces can wrap (K-A-2)</p>
                </div>
            </div>

            <div class="flex gap-3 mt-6">
                <button onclick="saveAndResume()" class="flex-1 bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded">
                    SAVE & RESUME
                </button>
                <button onclick="confirmNewGame()" class="flex-1 game-btn py-2 px-4 rounded">
                    NEW GAME
                </button>
            </div>
        </div>
    </div>

    <div id="messageToast" class="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-black bg-opacity-90 text-gold border border-gold px-6 py-4 rounded-lg pointer-events-none opacity-0 transition-opacity duration-300 z-50 text-center font-bold text-xl shadow-xl font-cinzel" style="color: var(--gold); border-color: var(--gold);">Message</div>

    <script type="module">
        import { db } from '/firebase-config.js';
        import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { collection, addDoc, serverTimestamp, doc, setDoc, increment } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

        let auth = null;
        let currentUser = null;

        // Gatekeeper: Check if logged in
        async function initGameAuth() {
            try {
                auth = getAuth(db.app);
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        console.log("Player Identified:", user.displayName);
                        currentUser = user;
                        scoreManager.playerName = user.displayName || "Unknown Player";
                    } else {
                        // Not logged in? Kick back to the portal
                        window.location.href = '/index.html';
                    }
                });
            } catch (error) {
                console.error("Auth failed:", error);
            }
        }
        initGameAuth();

        // --- Score Manager ---
        class GameScoreManager {
            constructor(gameName) {
                this.gameName = gameName;
                this.sessionStartTime = null;
                this.playerName = "Loading...";
            }

            startSession() {
                this.sessionStartTime = Date.now();
            }

            getElapsedTime() {
                if (!this.sessionStartTime) return 0;
                return Math.floor((Date.now() - this.sessionStartTime) / 1000);
            }

            getElapsedTimeFormatted() {
                const seconds = this.getElapsedTime();
                if (seconds < 60) return `0:${seconds.toString().padStart(2, '0')}`;
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }

            async submitGameResult(score = 0) {
                if (!currentUser) return;

                const timePlayed = this.getElapsedTime();
                
                try {
                    // Public Leaderboard
                    await addDoc(collection(db, 'scores'), {
                        gameName: this.gameName,
                        playerName: this.playerName,
                        score: score,
                        timePlayed: timePlayed,
                        timestamp: serverTimestamp(),
                        uid: currentUser.uid
                    });

                    console.log(`âœ… Score submitted: ${score} for ${this.gameName}`);
                } catch (error) {
                    console.error("Score submission failed:", error);
                }
            }
        }
        const scoreManager = new GameScoreManager('TriPeaks Solitaire');

        // --- Assets & Constants ---
        const ICONS = { spades: 'â™ ', hearts: 'â™¥', clubs: 'â™£', diamonds: 'â™¦' };
        const SUITS = ['hearts', 'diamonds', 'clubs', 'spades'];
        const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        const VALUES = { 'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13 };
        
        const THEMES = {
            green: '/games/assets/solitaire/greentop.png',
            red: '/games/assets/solitaire/redtop.png',
            blue: '/games/assets/solitaire/bluetop.png'
        };

        // TriPeaks layout: 3 peaks of 4 cards each (18 cards), plus 10 base cards (28 total)
        const LAYOUT = {
            // Each position: [row, col, covers (indices it blocks)]
            0: { row: 0, col: 0, covers: [3, 4] },      // Peak 1 top
            1: { row: 0, col: 6, covers: [7, 8] },      // Peak 2 top
            2: { row: 0, col: 12, covers: [11, 12] },   // Peak 3 top
            
            3: { row: 1, col: -0.5, covers: [13, 14] },
            4: { row: 1, col: 1.5, covers: [14, 15] },
            5: { row: 1, col: 3.5, covers: [15, 16] },  // Missing peak 2 connections
            6: { row: 1, col: 5.5, covers: [16, 17] },
            7: { row: 1, col: 7.5, covers: [17, 18] },
            8: { row: 1, col: 9.5, covers: [18, 19] },
            9: { row: 1, col: 11.5, covers: [19, 20] }, // Missing peak 3 connections
            10: { row: 1, col: 13.5, covers: [20, 21] },
            11: { row: 1, col: 15.5, covers: [21, 22] },
            12: { row: 1, col: 17.5, covers: [22, 23] },

            13: { row: 2, col: 0, covers: [24] },
            14: { row: 2, col: 2, covers: [24, 25] },
            15: { row: 2, col: 4, covers: [25, 26] },
            16: { row: 2, col: 6, covers: [26, 27] },
            17: { row: 2, col: 8, covers: [27, 28] },
            18: { row: 2, col: 10, covers: [28, 29] },
            19: { row: 2, col: 12, covers: [29, 30] },
            20: { row: 2, col: 14, covers: [30, 31] },
            21: { row: 2, col: 16, covers: [31, 32] },
            22: { row: 2, col: 18, covers: [32] },

            // Base row (all face up)
            24: { row: 3, col: 0, covers: [] },
            25: { row: 3, col: 2, covers: [] },
            26: { row: 3, col: 4, covers: [] },
            27: { row: 3, col: 6, covers: [] },
            28: { row: 3, col: 8, covers: [] },
            29: { row: 3, col: 10, covers: [] },
            30: { row: 3, col: 12, covers: [] },
            31: { row: 3, col: 14, covers: [] },
            32: { row: 3, col: 16, covers: [] },
            33: { row: 3, col: 18, covers: [] },
        };

        let state = {
            peaks: [], // 28 cards in peaks
            stock: [], // 24 cards in stock
            waste: null,
            score: 0,
            streak: 0,
            history: [],
            theme: 'green',
            cleared: [] // Track cleared card indices
        };

        function init() {
            loadPreferences();
            applyTheme();
            startNewGame();
        }

        function loadPreferences() {
            state.theme = localStorage.getItem('tripeaks_theme') || 'green';
        }

        function startNewGame() {
            scoreManager.startSession();
            state.peaks = [];
            state.stock = [];
            state.waste = null;
            state.score = 0;
            state.streak = 0;
            state.history = [];
            state.cleared = [];

            stopConfetti();
            document.getElementById('winModal').classList.add('hidden');
            document.getElementById('loseModal').classList.add('hidden');
            
            dealNewGame();
            updateScore();
            updateStreak();
            updateUndoButton();
        }

        function dealNewGame() {
            // Create deck
            const deck = [];
            for (let suit of SUITS) {
                for (let rank of RANKS) {
                    deck.push({ suit, rank, value: VALUES[rank], faceUp: false });
                }
            }
            
            // Shuffle
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }

            // Deal 28 cards to peaks (last 10 are face up)
            for (let i = 0; i < 28; i++) {
                const card = deck[i];
                card.faceUp = (i >= 18); // Base row starts face up
                state.peaks.push(card);
            }

            // Deal 24 to stock
            state.stock = deck.slice(28);
            
            // Draw first card to waste
            if (state.stock.length > 0) {
                state.waste = state.stock.pop();
                state.waste.faceUp = true;
            }

            renderBoard();
        }

        function renderBoard() {
            renderPeaks();
            renderStock();
            renderWaste();
        }

        function renderPeaks() {
            const container = document.getElementById('peaksContainer');
            container.innerHTML = '';

            const containerWidth = container.offsetWidth;
            const cardWidth = window.innerWidth < 640 ? 70 : (window.innerWidth < 1024 ? 85 : 100);
            const spacing = cardWidth * 1.2;
            const baseX = (containerWidth - (19 * spacing)) / 2;

            state.peaks.forEach((card, index) => {
                if (state.cleared.includes(index)) return; // Skip cleared cards

                const layout = LAYOUT[index];
                if (!layout) return;

                const slot = document.createElement('div');
                slot.className = 'card-slot';
                slot.style.left = `${baseX + layout.col * spacing}px`;
                slot.style.top = `${layout.row * 80}px`;

                const cardEl = createCardElement(card);
                cardEl.dataset.index = index;

                const isBlocked = isCardBlocked(index);
                
                if (card.faceUp && !isBlocked) {
                    const canPlay = canPlayCard(card);
                    if (canPlay) {
                        cardEl.classList.add('playable');
                    }
                    cardEl.onclick = () => playCard(index);
                } else if (isBlocked) {
                    cardEl.classList.add('blocked');
                }

                slot.appendChild(cardEl);
                container.appendChild(slot);
            });
        }

        function renderStock() {
            const stockEl = document.getElementById('stockPile');
            const countEl = document.getElementById('stockCount');
            
            if (state.stock.length === 0) {
                stockEl.classList.remove('filled');
                stockEl.innerHTML = '<div class="text-3xl text-gold opacity-30">âˆ…</div>';
                countEl.textContent = '';
            } else {
                stockEl.classList.add('filled');
                stockEl.innerHTML = '';
                const cardEl = createCardElement({ faceUp: false }, 0);
                cardEl.style.position = 'relative';
                stockEl.appendChild(cardEl);
                countEl.textContent = state.stock.length;
            }
        }

        function renderWaste() {
            const wasteEl = document.getElementById('wastePile');
            wasteEl.innerHTML = '';

            if (state.waste) {
                wasteEl.classList.add('filled');
                const cardEl = createCardElement(state.waste, 0);
                cardEl.style.position = 'relative';
                wasteEl.appendChild(cardEl);
            } else {
                wasteEl.classList.remove('filled');
            }
        }

        function createCardElement(card) {
            const cardEl = document.createElement('div');
            cardEl.className = `card ${card.faceUp ? '' : 'card-face-down'} ${card.faceUp ? getSuitColor(card.suit) : ''}`;

            if (card.faceUp) {
                const topDiv = document.createElement('div');
                topDiv.className = 'flex flex-col items-center leading-none select-none';
                topDiv.innerHTML = `<span class="text-xl font-bold">${card.rank}</span>`;
                
                const centerDiv = document.createElement('div');
                centerDiv.className = 'absolute inset-0 flex items-center justify-center pointer-events-none';
                centerDiv.innerHTML = `<span class="text-6xl">${ICONS[card.suit]}</span>`;
                
                const botDiv = document.createElement('div');
                botDiv.className = 'flex flex-col items-center leading-none select-none transform rotate-180';
                botDiv.innerHTML = `<span class="text-xl font-bold">${card.rank}</span>`;
                
                cardEl.appendChild(topDiv);
                cardEl.appendChild(centerDiv);
                cardEl.appendChild(botDiv);
            }

            return cardEl;
        }

        // --- Game Logic ---
        function isCardBlocked(index) {
            // Check if any other card is covering this one
            for (let i = 0; i < state.peaks.length; i++) {
                if (state.cleared.includes(i)) continue;
                const layout = LAYOUT[i];
                if (layout && layout.covers.includes(index)) {
                    return true;
                }
            }
            return false;
        }

        function canPlayCard(card) {
            if (!state.waste) return false;
            const diff = Math.abs(card.value - state.waste.value);
            return diff === 1 || diff === 12; // Adjacent or wrap (K-A)
        }

        function playCard(index) {
            const card = state.peaks[index];
            
            if (!card.faceUp || isCardBlocked(index)) {
                showMessage("Card is blocked!");
                return;
            }

            if (!canPlayCard(card)) {
                showMessage("Can't play that card!");
                return;
            }

            // Animate and clear card
            const cardEl = document.querySelector(`[data-index="${index}"]`);
            if (cardEl) {
                cardEl.classList.add('cleared');
            }

            setTimeout(() => {
                // Move card to waste
                state.waste = card;
                state.cleared.push(index);

                // Increase streak and score
                state.streak++;
                const points = state.streak * 10;
                state.score += points;

                // Show streak bonus
                if (state.streak > 1) {
                    showStreakBonus(state.streak, points);
                }

                // Check for newly uncovered cards and flip them
                flipUncoveredCards();

                updateScore();
                updateStreak();
                renderBoard();
                checkWinOrLose();
            }, 300);
        }

        function flipUncoveredCards() {
            state.peaks.forEach((card, index) => {
                if (!card.faceUp && !isCardBlocked(index)) {
                    card.faceUp = true;
                }
            });
        }

        function drawFromStock() {
            if (state.stock.length === 0) {
                showMessage("No more cards!");
                return;
            }

            const card = state.stock.pop();
            card.faceUp = true;
            state.waste = card;
            
            // Reset streak
            state.streak = 0;
            
            updateStreak();
            renderBoard();
            checkWinOrLose();
        }

        function checkWinOrLose() {
            const peaksCleared = state.cleared.length === 28;
            
            if (peaksCleared) {
                // Win!
                const bonus = state.stock.length * 50;
                state.score += bonus;
                updateScore();
                
                document.getElementById('finalScoreDisplay').textContent = state.score;
                document.getElementById('finalTimeDisplay').textContent = scoreManager.getElapsedTimeFormatted();
                document.getElementById('winModal').classList.remove('hidden');
                startConfetti();
                scoreManager.submitGameResult(state.score);
                return;
            }

            // Check if any moves available
            if (state.stock.length === 0) {
                let hasMove = false;
                for (let i = 0; i < state.peaks.length; i++) {
                    if (state.cleared.includes(i)) continue;
                    const card = state.peaks[i];
                    if (card.faceUp && !isCardBlocked(i) && canPlayCard(card)) {
                        hasMove = true;
                        break;
                    }
                }

                if (!hasMove) {
                    // Lose - no more moves
                    document.getElementById('loseScoreDisplay').textContent = state.score;
                    document.getElementById('cardsRemainingDisplay').textContent = 28 - state.cleared.length;
                    document.getElementById('loseModal').classList.remove('hidden');
                    scoreManager.submitGameResult(state.score);
                }
            }
        }

        function showStreakBonus(streak, points) {
            const el = document.getElementById('streakDisplay');
            el.textContent = `${streak}x STREAK! +${points}`;
            el.classList.remove('show');
            void el.offsetWidth; // Force reflow
            el.classList.add('show');
        }

        // --- Utils & UI ---
        function getSuitColor(suit) { 
            return (suit === 'hearts' || suit === 'diamonds') ? 'suit-red' : 'suit-black'; 
        }

        function updateScore() { 
            document.getElementById('scoreDisplay').innerText = `Score: ${state.score}`; 
        }

        function updateStreak() {
            document.getElementById('streakDisplay2').innerText = `Streak: ${state.streak}`;
        }

        function updateUndoButton() { 
            document.getElementById('undoBtn').disabled = state.history.length === 0; 
        }

        function undoMove() {
            // TODO: Implement undo system
            showMessage("Undo coming soon!");
        }

        function showMessage(msg) {
            const el = document.getElementById('messageToast');
            el.innerText = msg;
            el.style.opacity = '1';
            setTimeout(() => { el.style.opacity = '0'; }, 2000);
        }

        function toggleMenu() { 
            document.getElementById('menuModal').classList.toggle('hidden'); 
        }
        
        function applyTheme() {
            const url = THEMES[state.theme];
            document.body.style.backgroundImage = `url('${url}')`;
        }

        function saveAndResume() {
            const themeSelect = document.getElementById('themeSelect');
            const newTheme = themeSelect.value;
            if (newTheme !== state.theme) {
                state.theme = newTheme;
                localStorage.setItem('tripeaks_theme', state.theme);
                applyTheme();
            }
            toggleMenu();
        }

        function confirmNewGame() {
            const themeSelect = document.getElementById('themeSelect');
            state.theme = themeSelect.value;
            localStorage.setItem('tripeaks_theme', state.theme);
            applyTheme();

            toggleMenu(); 
            startNewGame();
        }

        function showHint() {
            // Find first playable card
            for (let i = 0; i < state.peaks.length; i++) {
                if (state.cleared.includes(i)) continue;
                const card = state.peaks[i];
                if (card.faceUp && !isCardBlocked(i) && canPlayCard(card)) {
                    animateHint(i);
                    return;
                }
            }

            if (state.stock.length > 0) {
                showMessage("No moves - draw from stock!");
            } else {
                showMessage("No moves available!");
            }
        }

        function animateHint(index) {
            const cardEl = document.querySelector(`[data-index="${index}"]`);
            if (cardEl) {
                cardEl.classList.add('hint-anim');
                setTimeout(() => cardEl.classList.remove('hint-anim'), 500);
            }
        }

        let confettiInterval;
        function startConfetti() {
            const canvas = document.getElementById('confetti-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            const pieces = [];
            const colors = ['#d4af37', '#f4e5a7', '#ffffff', '#b8941f'];
            for(let i=0; i<200; i++) {
                pieces.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height - canvas.height,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    size: Math.random() * 8 + 4,
                    speedY: Math.random() * 5 + 2,
                    speedX: Math.random() * 2 - 1
                });
            }
            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                pieces.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x, p.y, p.size, p.size);
                    p.y += p.speedY;
                    p.x += p.speedX;
                    if(p.y > canvas.height) p.y = -20;
                });
                confettiInterval = requestAnimationFrame(animate);
            }
            animate();
        }

        function stopConfetti() {
            if (confettiInterval) cancelAnimationFrame(confettiInterval);
            const canvas = document.getElementById('confetti-canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        window.toggleMenu = toggleMenu;
        window.undoMove = undoMove;
        window.showHint = showHint;
        window.startNewGame = startNewGame;
        window.confirmNewGame = confirmNewGame;
        window.saveAndResume = saveAndResume;
        window.drawFromStock = drawFromStock;

        init();
    </script>
</body>
</html>
